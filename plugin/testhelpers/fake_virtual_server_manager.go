// Code generated by counterfeiter. DO NOT EDIT.
package testhelpers

import (
	"sync"
	"time"

	"github.com/softlayer/softlayer-go/datatypes"
	"github.ibm.com/cgallo/softlayer-cli/plugin/managers"
)

type FakeVirtualServerManager struct {
	CancelInstanceStub        func(int) error
	cancelInstanceMutex       sync.RWMutex
	cancelInstanceArgsForCall []struct {
		arg1 int
	}
	cancelInstanceReturns struct {
		result1 error
	}
	cancelInstanceReturnsOnCall map[int]struct {
		result1 error
	}
	CaptureImageStub        func(int, string, string, bool) (datatypes.Provisioning_Version1_Transaction, error)
	captureImageMutex       sync.RWMutex
	captureImageArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 string
		arg4 bool
	}
	captureImageReturns struct {
		result1 datatypes.Provisioning_Version1_Transaction
		result2 error
	}
	captureImageReturnsOnCall map[int]struct {
		result1 datatypes.Provisioning_Version1_Transaction
		result2 error
	}
	CreateDedicatedHostStub        func(string, string, string, string, string, int) (datatypes.Container_Product_Order_Receipt, error)
	createDedicatedHostMutex       sync.RWMutex
	createDedicatedHostArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 int
	}
	createDedicatedHostReturns struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	createDedicatedHostReturnsOnCall map[int]struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	CreateInstanceStub        func(*datatypes.Virtual_Guest) (datatypes.Virtual_Guest, error)
	createInstanceMutex       sync.RWMutex
	createInstanceArgsForCall []struct {
		arg1 *datatypes.Virtual_Guest
	}
	createInstanceReturns struct {
		result1 datatypes.Virtual_Guest
		result2 error
	}
	createInstanceReturnsOnCall map[int]struct {
		result1 datatypes.Virtual_Guest
		result2 error
	}
	CreateInstancesStub        func([]datatypes.Virtual_Guest) ([]datatypes.Virtual_Guest, error)
	createInstancesMutex       sync.RWMutex
	createInstancesArgsForCall []struct {
		arg1 []datatypes.Virtual_Guest
	}
	createInstancesReturns struct {
		result1 []datatypes.Virtual_Guest
		result2 error
	}
	createInstancesReturnsOnCall map[int]struct {
		result1 []datatypes.Virtual_Guest
		result2 error
	}
	EditInstanceStub        func(int, string, string, string, string, *int, *int) ([]bool, []string)
	editInstanceMutex       sync.RWMutex
	editInstanceArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 *int
		arg7 *int
	}
	editInstanceReturns struct {
		result1 []bool
		result2 []string
	}
	editInstanceReturnsOnCall map[int]struct {
		result1 []bool
		result2 []string
	}
	GenerateInstanceCreationTemplateStub        func(*datatypes.Virtual_Guest, map[string]interface{}) (*datatypes.Virtual_Guest, error)
	generateInstanceCreationTemplateMutex       sync.RWMutex
	generateInstanceCreationTemplateArgsForCall []struct {
		arg1 *datatypes.Virtual_Guest
		arg2 map[string]interface{}
	}
	generateInstanceCreationTemplateReturns struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}
	generateInstanceCreationTemplateReturnsOnCall map[int]struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}
	GetCreateOptionsStub        func() (datatypes.Container_Virtual_Guest_Configuration, error)
	getCreateOptionsMutex       sync.RWMutex
	getCreateOptionsArgsForCall []struct {
	}
	getCreateOptionsReturns struct {
		result1 datatypes.Container_Virtual_Guest_Configuration
		result2 error
	}
	getCreateOptionsReturnsOnCall map[int]struct {
		result1 datatypes.Container_Virtual_Guest_Configuration
		result2 error
	}
	GetDedicatedHostStub        func(int) (datatypes.Virtual_DedicatedHost, error)
	getDedicatedHostMutex       sync.RWMutex
	getDedicatedHostArgsForCall []struct {
		arg1 int
	}
	getDedicatedHostReturns struct {
		result1 datatypes.Virtual_DedicatedHost
		result2 error
	}
	getDedicatedHostReturnsOnCall map[int]struct {
		result1 datatypes.Virtual_DedicatedHost
		result2 error
	}
	GetInstanceStub        func(int, string) (datatypes.Virtual_Guest, error)
	getInstanceMutex       sync.RWMutex
	getInstanceArgsForCall []struct {
		arg1 int
		arg2 string
	}
	getInstanceReturns struct {
		result1 datatypes.Virtual_Guest
		result2 error
	}
	getInstanceReturnsOnCall map[int]struct {
		result1 datatypes.Virtual_Guest
		result2 error
	}
	GetLikedInstanceStub        func(*datatypes.Virtual_Guest, int) (*datatypes.Virtual_Guest, error)
	getLikedInstanceMutex       sync.RWMutex
	getLikedInstanceArgsForCall []struct {
		arg1 *datatypes.Virtual_Guest
		arg2 int
	}
	getLikedInstanceReturns struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}
	getLikedInstanceReturnsOnCall map[int]struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}
	InstanceIsReadyStub        func(int, time.Time) (bool, string, error)
	instanceIsReadyMutex       sync.RWMutex
	instanceIsReadyArgsForCall []struct {
		arg1 int
		arg2 time.Time
	}
	instanceIsReadyReturns struct {
		result1 bool
		result2 string
		result3 error
	}
	instanceIsReadyReturnsOnCall map[int]struct {
		result1 bool
		result2 string
		result3 error
	}
	ListDedicatedHostStub        func(string, string, string, int) ([]datatypes.Virtual_DedicatedHost, error)
	listDedicatedHostMutex       sync.RWMutex
	listDedicatedHostArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 int
	}
	listDedicatedHostReturns struct {
		result1 []datatypes.Virtual_DedicatedHost
		result2 error
	}
	listDedicatedHostReturnsOnCall map[int]struct {
		result1 []datatypes.Virtual_DedicatedHost
		result2 error
	}
	ListInstancesStub        func(bool, bool, string, string, string, string, string, string, int, int, int, int, []string, string) ([]datatypes.Virtual_Guest, error)
	listInstancesMutex       sync.RWMutex
	listInstancesArgsForCall []struct {
		arg1  bool
		arg2  bool
		arg3  string
		arg4  string
		arg5  string
		arg6  string
		arg7  string
		arg8  string
		arg9  int
		arg10 int
		arg11 int
		arg12 int
		arg13 []string
		arg14 string
	}
	listInstancesReturns struct {
		result1 []datatypes.Virtual_Guest
		result2 error
	}
	listInstancesReturnsOnCall map[int]struct {
		result1 []datatypes.Virtual_Guest
		result2 error
	}
	PauseInstanceStub        func(int) error
	pauseInstanceMutex       sync.RWMutex
	pauseInstanceArgsForCall []struct {
		arg1 int
	}
	pauseInstanceReturns struct {
		result1 error
	}
	pauseInstanceReturnsOnCall map[int]struct {
		result1 error
	}
	PowerOffInstanceStub        func(int, bool, bool) error
	powerOffInstanceMutex       sync.RWMutex
	powerOffInstanceArgsForCall []struct {
		arg1 int
		arg2 bool
		arg3 bool
	}
	powerOffInstanceReturns struct {
		result1 error
	}
	powerOffInstanceReturnsOnCall map[int]struct {
		result1 error
	}
	PowerOnInstanceStub        func(int) error
	powerOnInstanceMutex       sync.RWMutex
	powerOnInstanceArgsForCall []struct {
		arg1 int
	}
	powerOnInstanceReturns struct {
		result1 error
	}
	powerOnInstanceReturnsOnCall map[int]struct {
		result1 error
	}
	RebootInstanceStub        func(int, bool, bool) error
	rebootInstanceMutex       sync.RWMutex
	rebootInstanceArgsForCall []struct {
		arg1 int
		arg2 bool
		arg3 bool
	}
	rebootInstanceReturns struct {
		result1 error
	}
	rebootInstanceReturnsOnCall map[int]struct {
		result1 error
	}
	ReloadInstanceStub        func(int, string, []int, int) error
	reloadInstanceMutex       sync.RWMutex
	reloadInstanceArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 []int
		arg4 int
	}
	reloadInstanceReturns struct {
		result1 error
	}
	reloadInstanceReturnsOnCall map[int]struct {
		result1 error
	}
	RescueInstanceStub        func(int) error
	rescueInstanceMutex       sync.RWMutex
	rescueInstanceArgsForCall []struct {
		arg1 int
	}
	rescueInstanceReturns struct {
		result1 error
	}
	rescueInstanceReturnsOnCall map[int]struct {
		result1 error
	}
	ResumeInstanceStub        func(int) error
	resumeInstanceMutex       sync.RWMutex
	resumeInstanceArgsForCall []struct {
		arg1 int
	}
	resumeInstanceReturns struct {
		result1 error
	}
	resumeInstanceReturnsOnCall map[int]struct {
		result1 error
	}
	SetNetworkPortSpeedStub        func(int, bool, int) error
	setNetworkPortSpeedMutex       sync.RWMutex
	setNetworkPortSpeedArgsForCall []struct {
		arg1 int
		arg2 bool
		arg3 int
	}
	setNetworkPortSpeedReturns struct {
		result1 error
	}
	setNetworkPortSpeedReturnsOnCall map[int]struct {
		result1 error
	}
	SetTagsStub        func(int, string) error
	setTagsMutex       sync.RWMutex
	setTagsArgsForCall []struct {
		arg1 int
		arg2 string
	}
	setTagsReturns struct {
		result1 error
	}
	setTagsReturnsOnCall map[int]struct {
		result1 error
	}
	SetUserMetadataStub        func(int, []string) error
	setUserMetadataMutex       sync.RWMutex
	setUserMetadataArgsForCall []struct {
		arg1 int
		arg2 []string
	}
	setUserMetadataReturns struct {
		result1 error
	}
	setUserMetadataReturnsOnCall map[int]struct {
		result1 error
	}
	UpgradeInstanceStub        func(int, int, int, int, bool, string) (datatypes.Container_Product_Order_Receipt, error)
	upgradeInstanceMutex       sync.RWMutex
	upgradeInstanceArgsForCall []struct {
		arg1 int
		arg2 int
		arg3 int
		arg4 int
		arg5 bool
		arg6 string
	}
	upgradeInstanceReturns struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	upgradeInstanceReturnsOnCall map[int]struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	VerifyInstanceCreationStub        func(datatypes.Virtual_Guest) (datatypes.Container_Product_Order, error)
	verifyInstanceCreationMutex       sync.RWMutex
	verifyInstanceCreationArgsForCall []struct {
		arg1 datatypes.Virtual_Guest
	}
	verifyInstanceCreationReturns struct {
		result1 datatypes.Container_Product_Order
		result2 error
	}
	verifyInstanceCreationReturnsOnCall map[int]struct {
		result1 datatypes.Container_Product_Order
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeVirtualServerManager) CancelInstance(arg1 int) error {
	fake.cancelInstanceMutex.Lock()
	ret, specificReturn := fake.cancelInstanceReturnsOnCall[len(fake.cancelInstanceArgsForCall)]
	fake.cancelInstanceArgsForCall = append(fake.cancelInstanceArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("CancelInstance", []interface{}{arg1})
	fake.cancelInstanceMutex.Unlock()
	if fake.CancelInstanceStub != nil {
		return fake.CancelInstanceStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.cancelInstanceReturns
	return fakeReturns.result1
}

func (fake *FakeVirtualServerManager) CancelInstanceCallCount() int {
	fake.cancelInstanceMutex.RLock()
	defer fake.cancelInstanceMutex.RUnlock()
	return len(fake.cancelInstanceArgsForCall)
}

func (fake *FakeVirtualServerManager) CancelInstanceCalls(stub func(int) error) {
	fake.cancelInstanceMutex.Lock()
	defer fake.cancelInstanceMutex.Unlock()
	fake.CancelInstanceStub = stub
}

func (fake *FakeVirtualServerManager) CancelInstanceArgsForCall(i int) int {
	fake.cancelInstanceMutex.RLock()
	defer fake.cancelInstanceMutex.RUnlock()
	argsForCall := fake.cancelInstanceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeVirtualServerManager) CancelInstanceReturns(result1 error) {
	fake.cancelInstanceMutex.Lock()
	defer fake.cancelInstanceMutex.Unlock()
	fake.CancelInstanceStub = nil
	fake.cancelInstanceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVirtualServerManager) CancelInstanceReturnsOnCall(i int, result1 error) {
	fake.cancelInstanceMutex.Lock()
	defer fake.cancelInstanceMutex.Unlock()
	fake.CancelInstanceStub = nil
	if fake.cancelInstanceReturnsOnCall == nil {
		fake.cancelInstanceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelInstanceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVirtualServerManager) CaptureImage(arg1 int, arg2 string, arg3 string, arg4 bool) (datatypes.Provisioning_Version1_Transaction, error) {
	fake.captureImageMutex.Lock()
	ret, specificReturn := fake.captureImageReturnsOnCall[len(fake.captureImageArgsForCall)]
	fake.captureImageArgsForCall = append(fake.captureImageArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 string
		arg4 bool
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("CaptureImage", []interface{}{arg1, arg2, arg3, arg4})
	fake.captureImageMutex.Unlock()
	if fake.CaptureImageStub != nil {
		return fake.CaptureImageStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.captureImageReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVirtualServerManager) CaptureImageCallCount() int {
	fake.captureImageMutex.RLock()
	defer fake.captureImageMutex.RUnlock()
	return len(fake.captureImageArgsForCall)
}

func (fake *FakeVirtualServerManager) CaptureImageCalls(stub func(int, string, string, bool) (datatypes.Provisioning_Version1_Transaction, error)) {
	fake.captureImageMutex.Lock()
	defer fake.captureImageMutex.Unlock()
	fake.CaptureImageStub = stub
}

func (fake *FakeVirtualServerManager) CaptureImageArgsForCall(i int) (int, string, string, bool) {
	fake.captureImageMutex.RLock()
	defer fake.captureImageMutex.RUnlock()
	argsForCall := fake.captureImageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeVirtualServerManager) CaptureImageReturns(result1 datatypes.Provisioning_Version1_Transaction, result2 error) {
	fake.captureImageMutex.Lock()
	defer fake.captureImageMutex.Unlock()
	fake.CaptureImageStub = nil
	fake.captureImageReturns = struct {
		result1 datatypes.Provisioning_Version1_Transaction
		result2 error
	}{result1, result2}
}

func (fake *FakeVirtualServerManager) CaptureImageReturnsOnCall(i int, result1 datatypes.Provisioning_Version1_Transaction, result2 error) {
	fake.captureImageMutex.Lock()
	defer fake.captureImageMutex.Unlock()
	fake.CaptureImageStub = nil
	if fake.captureImageReturnsOnCall == nil {
		fake.captureImageReturnsOnCall = make(map[int]struct {
			result1 datatypes.Provisioning_Version1_Transaction
			result2 error
		})
	}
	fake.captureImageReturnsOnCall[i] = struct {
		result1 datatypes.Provisioning_Version1_Transaction
		result2 error
	}{result1, result2}
}

func (fake *FakeVirtualServerManager) CreateDedicatedHost(arg1 string, arg2 string, arg3 string, arg4 string, arg5 string, arg6 int) (datatypes.Container_Product_Order_Receipt, error) {
	fake.createDedicatedHostMutex.Lock()
	ret, specificReturn := fake.createDedicatedHostReturnsOnCall[len(fake.createDedicatedHostArgsForCall)]
	fake.createDedicatedHostArgsForCall = append(fake.createDedicatedHostArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 int
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.recordInvocation("CreateDedicatedHost", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.createDedicatedHostMutex.Unlock()
	if fake.CreateDedicatedHostStub != nil {
		return fake.CreateDedicatedHostStub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createDedicatedHostReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVirtualServerManager) CreateDedicatedHostCallCount() int {
	fake.createDedicatedHostMutex.RLock()
	defer fake.createDedicatedHostMutex.RUnlock()
	return len(fake.createDedicatedHostArgsForCall)
}

func (fake *FakeVirtualServerManager) CreateDedicatedHostCalls(stub func(string, string, string, string, string, int) (datatypes.Container_Product_Order_Receipt, error)) {
	fake.createDedicatedHostMutex.Lock()
	defer fake.createDedicatedHostMutex.Unlock()
	fake.CreateDedicatedHostStub = stub
}

func (fake *FakeVirtualServerManager) CreateDedicatedHostArgsForCall(i int) (string, string, string, string, string, int) {
	fake.createDedicatedHostMutex.RLock()
	defer fake.createDedicatedHostMutex.RUnlock()
	argsForCall := fake.createDedicatedHostArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeVirtualServerManager) CreateDedicatedHostReturns(result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.createDedicatedHostMutex.Lock()
	defer fake.createDedicatedHostMutex.Unlock()
	fake.CreateDedicatedHostStub = nil
	fake.createDedicatedHostReturns = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeVirtualServerManager) CreateDedicatedHostReturnsOnCall(i int, result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.createDedicatedHostMutex.Lock()
	defer fake.createDedicatedHostMutex.Unlock()
	fake.CreateDedicatedHostStub = nil
	if fake.createDedicatedHostReturnsOnCall == nil {
		fake.createDedicatedHostReturnsOnCall = make(map[int]struct {
			result1 datatypes.Container_Product_Order_Receipt
			result2 error
		})
	}
	fake.createDedicatedHostReturnsOnCall[i] = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeVirtualServerManager) CreateInstance(arg1 *datatypes.Virtual_Guest) (datatypes.Virtual_Guest, error) {
	fake.createInstanceMutex.Lock()
	ret, specificReturn := fake.createInstanceReturnsOnCall[len(fake.createInstanceArgsForCall)]
	fake.createInstanceArgsForCall = append(fake.createInstanceArgsForCall, struct {
		arg1 *datatypes.Virtual_Guest
	}{arg1})
	fake.recordInvocation("CreateInstance", []interface{}{arg1})
	fake.createInstanceMutex.Unlock()
	if fake.CreateInstanceStub != nil {
		return fake.CreateInstanceStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createInstanceReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVirtualServerManager) CreateInstanceCallCount() int {
	fake.createInstanceMutex.RLock()
	defer fake.createInstanceMutex.RUnlock()
	return len(fake.createInstanceArgsForCall)
}

func (fake *FakeVirtualServerManager) CreateInstanceCalls(stub func(*datatypes.Virtual_Guest) (datatypes.Virtual_Guest, error)) {
	fake.createInstanceMutex.Lock()
	defer fake.createInstanceMutex.Unlock()
	fake.CreateInstanceStub = stub
}

func (fake *FakeVirtualServerManager) CreateInstanceArgsForCall(i int) *datatypes.Virtual_Guest {
	fake.createInstanceMutex.RLock()
	defer fake.createInstanceMutex.RUnlock()
	argsForCall := fake.createInstanceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeVirtualServerManager) CreateInstanceReturns(result1 datatypes.Virtual_Guest, result2 error) {
	fake.createInstanceMutex.Lock()
	defer fake.createInstanceMutex.Unlock()
	fake.CreateInstanceStub = nil
	fake.createInstanceReturns = struct {
		result1 datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeVirtualServerManager) CreateInstanceReturnsOnCall(i int, result1 datatypes.Virtual_Guest, result2 error) {
	fake.createInstanceMutex.Lock()
	defer fake.createInstanceMutex.Unlock()
	fake.CreateInstanceStub = nil
	if fake.createInstanceReturnsOnCall == nil {
		fake.createInstanceReturnsOnCall = make(map[int]struct {
			result1 datatypes.Virtual_Guest
			result2 error
		})
	}
	fake.createInstanceReturnsOnCall[i] = struct {
		result1 datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeVirtualServerManager) CreateInstances(arg1 []datatypes.Virtual_Guest) ([]datatypes.Virtual_Guest, error) {
	var arg1Copy []datatypes.Virtual_Guest
	if arg1 != nil {
		arg1Copy = make([]datatypes.Virtual_Guest, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.createInstancesMutex.Lock()
	ret, specificReturn := fake.createInstancesReturnsOnCall[len(fake.createInstancesArgsForCall)]
	fake.createInstancesArgsForCall = append(fake.createInstancesArgsForCall, struct {
		arg1 []datatypes.Virtual_Guest
	}{arg1Copy})
	fake.recordInvocation("CreateInstances", []interface{}{arg1Copy})
	fake.createInstancesMutex.Unlock()
	if fake.CreateInstancesStub != nil {
		return fake.CreateInstancesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createInstancesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVirtualServerManager) CreateInstancesCallCount() int {
	fake.createInstancesMutex.RLock()
	defer fake.createInstancesMutex.RUnlock()
	return len(fake.createInstancesArgsForCall)
}

func (fake *FakeVirtualServerManager) CreateInstancesCalls(stub func([]datatypes.Virtual_Guest) ([]datatypes.Virtual_Guest, error)) {
	fake.createInstancesMutex.Lock()
	defer fake.createInstancesMutex.Unlock()
	fake.CreateInstancesStub = stub
}

func (fake *FakeVirtualServerManager) CreateInstancesArgsForCall(i int) []datatypes.Virtual_Guest {
	fake.createInstancesMutex.RLock()
	defer fake.createInstancesMutex.RUnlock()
	argsForCall := fake.createInstancesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeVirtualServerManager) CreateInstancesReturns(result1 []datatypes.Virtual_Guest, result2 error) {
	fake.createInstancesMutex.Lock()
	defer fake.createInstancesMutex.Unlock()
	fake.CreateInstancesStub = nil
	fake.createInstancesReturns = struct {
		result1 []datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeVirtualServerManager) CreateInstancesReturnsOnCall(i int, result1 []datatypes.Virtual_Guest, result2 error) {
	fake.createInstancesMutex.Lock()
	defer fake.createInstancesMutex.Unlock()
	fake.CreateInstancesStub = nil
	if fake.createInstancesReturnsOnCall == nil {
		fake.createInstancesReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Virtual_Guest
			result2 error
		})
	}
	fake.createInstancesReturnsOnCall[i] = struct {
		result1 []datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeVirtualServerManager) EditInstance(arg1 int, arg2 string, arg3 string, arg4 string, arg5 string, arg6 *int, arg7 *int) ([]bool, []string) {
	fake.editInstanceMutex.Lock()
	ret, specificReturn := fake.editInstanceReturnsOnCall[len(fake.editInstanceArgsForCall)]
	fake.editInstanceArgsForCall = append(fake.editInstanceArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 *int
		arg7 *int
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.recordInvocation("EditInstance", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.editInstanceMutex.Unlock()
	if fake.EditInstanceStub != nil {
		return fake.EditInstanceStub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.editInstanceReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVirtualServerManager) EditInstanceCallCount() int {
	fake.editInstanceMutex.RLock()
	defer fake.editInstanceMutex.RUnlock()
	return len(fake.editInstanceArgsForCall)
}

func (fake *FakeVirtualServerManager) EditInstanceCalls(stub func(int, string, string, string, string, *int, *int) ([]bool, []string)) {
	fake.editInstanceMutex.Lock()
	defer fake.editInstanceMutex.Unlock()
	fake.EditInstanceStub = stub
}

func (fake *FakeVirtualServerManager) EditInstanceArgsForCall(i int) (int, string, string, string, string, *int, *int) {
	fake.editInstanceMutex.RLock()
	defer fake.editInstanceMutex.RUnlock()
	argsForCall := fake.editInstanceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeVirtualServerManager) EditInstanceReturns(result1 []bool, result2 []string) {
	fake.editInstanceMutex.Lock()
	defer fake.editInstanceMutex.Unlock()
	fake.EditInstanceStub = nil
	fake.editInstanceReturns = struct {
		result1 []bool
		result2 []string
	}{result1, result2}
}

func (fake *FakeVirtualServerManager) EditInstanceReturnsOnCall(i int, result1 []bool, result2 []string) {
	fake.editInstanceMutex.Lock()
	defer fake.editInstanceMutex.Unlock()
	fake.EditInstanceStub = nil
	if fake.editInstanceReturnsOnCall == nil {
		fake.editInstanceReturnsOnCall = make(map[int]struct {
			result1 []bool
			result2 []string
		})
	}
	fake.editInstanceReturnsOnCall[i] = struct {
		result1 []bool
		result2 []string
	}{result1, result2}
}

func (fake *FakeVirtualServerManager) GenerateInstanceCreationTemplate(arg1 *datatypes.Virtual_Guest, arg2 map[string]interface{}) (*datatypes.Virtual_Guest, error) {
	fake.generateInstanceCreationTemplateMutex.Lock()
	ret, specificReturn := fake.generateInstanceCreationTemplateReturnsOnCall[len(fake.generateInstanceCreationTemplateArgsForCall)]
	fake.generateInstanceCreationTemplateArgsForCall = append(fake.generateInstanceCreationTemplateArgsForCall, struct {
		arg1 *datatypes.Virtual_Guest
		arg2 map[string]interface{}
	}{arg1, arg2})
	fake.recordInvocation("GenerateInstanceCreationTemplate", []interface{}{arg1, arg2})
	fake.generateInstanceCreationTemplateMutex.Unlock()
	if fake.GenerateInstanceCreationTemplateStub != nil {
		return fake.GenerateInstanceCreationTemplateStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.generateInstanceCreationTemplateReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVirtualServerManager) GenerateInstanceCreationTemplateCallCount() int {
	fake.generateInstanceCreationTemplateMutex.RLock()
	defer fake.generateInstanceCreationTemplateMutex.RUnlock()
	return len(fake.generateInstanceCreationTemplateArgsForCall)
}

func (fake *FakeVirtualServerManager) GenerateInstanceCreationTemplateCalls(stub func(*datatypes.Virtual_Guest, map[string]interface{}) (*datatypes.Virtual_Guest, error)) {
	fake.generateInstanceCreationTemplateMutex.Lock()
	defer fake.generateInstanceCreationTemplateMutex.Unlock()
	fake.GenerateInstanceCreationTemplateStub = stub
}

func (fake *FakeVirtualServerManager) GenerateInstanceCreationTemplateArgsForCall(i int) (*datatypes.Virtual_Guest, map[string]interface{}) {
	fake.generateInstanceCreationTemplateMutex.RLock()
	defer fake.generateInstanceCreationTemplateMutex.RUnlock()
	argsForCall := fake.generateInstanceCreationTemplateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeVirtualServerManager) GenerateInstanceCreationTemplateReturns(result1 *datatypes.Virtual_Guest, result2 error) {
	fake.generateInstanceCreationTemplateMutex.Lock()
	defer fake.generateInstanceCreationTemplateMutex.Unlock()
	fake.GenerateInstanceCreationTemplateStub = nil
	fake.generateInstanceCreationTemplateReturns = struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeVirtualServerManager) GenerateInstanceCreationTemplateReturnsOnCall(i int, result1 *datatypes.Virtual_Guest, result2 error) {
	fake.generateInstanceCreationTemplateMutex.Lock()
	defer fake.generateInstanceCreationTemplateMutex.Unlock()
	fake.GenerateInstanceCreationTemplateStub = nil
	if fake.generateInstanceCreationTemplateReturnsOnCall == nil {
		fake.generateInstanceCreationTemplateReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Virtual_Guest
			result2 error
		})
	}
	fake.generateInstanceCreationTemplateReturnsOnCall[i] = struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeVirtualServerManager) GetCreateOptions() (datatypes.Container_Virtual_Guest_Configuration, error) {
	fake.getCreateOptionsMutex.Lock()
	ret, specificReturn := fake.getCreateOptionsReturnsOnCall[len(fake.getCreateOptionsArgsForCall)]
	fake.getCreateOptionsArgsForCall = append(fake.getCreateOptionsArgsForCall, struct {
	}{})
	fake.recordInvocation("GetCreateOptions", []interface{}{})
	fake.getCreateOptionsMutex.Unlock()
	if fake.GetCreateOptionsStub != nil {
		return fake.GetCreateOptionsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getCreateOptionsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVirtualServerManager) GetCreateOptionsCallCount() int {
	fake.getCreateOptionsMutex.RLock()
	defer fake.getCreateOptionsMutex.RUnlock()
	return len(fake.getCreateOptionsArgsForCall)
}

func (fake *FakeVirtualServerManager) GetCreateOptionsCalls(stub func() (datatypes.Container_Virtual_Guest_Configuration, error)) {
	fake.getCreateOptionsMutex.Lock()
	defer fake.getCreateOptionsMutex.Unlock()
	fake.GetCreateOptionsStub = stub
}

func (fake *FakeVirtualServerManager) GetCreateOptionsReturns(result1 datatypes.Container_Virtual_Guest_Configuration, result2 error) {
	fake.getCreateOptionsMutex.Lock()
	defer fake.getCreateOptionsMutex.Unlock()
	fake.GetCreateOptionsStub = nil
	fake.getCreateOptionsReturns = struct {
		result1 datatypes.Container_Virtual_Guest_Configuration
		result2 error
	}{result1, result2}
}

func (fake *FakeVirtualServerManager) GetCreateOptionsReturnsOnCall(i int, result1 datatypes.Container_Virtual_Guest_Configuration, result2 error) {
	fake.getCreateOptionsMutex.Lock()
	defer fake.getCreateOptionsMutex.Unlock()
	fake.GetCreateOptionsStub = nil
	if fake.getCreateOptionsReturnsOnCall == nil {
		fake.getCreateOptionsReturnsOnCall = make(map[int]struct {
			result1 datatypes.Container_Virtual_Guest_Configuration
			result2 error
		})
	}
	fake.getCreateOptionsReturnsOnCall[i] = struct {
		result1 datatypes.Container_Virtual_Guest_Configuration
		result2 error
	}{result1, result2}
}

func (fake *FakeVirtualServerManager) GetDedicatedHost(arg1 int) (datatypes.Virtual_DedicatedHost, error) {
	fake.getDedicatedHostMutex.Lock()
	ret, specificReturn := fake.getDedicatedHostReturnsOnCall[len(fake.getDedicatedHostArgsForCall)]
	fake.getDedicatedHostArgsForCall = append(fake.getDedicatedHostArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("GetDedicatedHost", []interface{}{arg1})
	fake.getDedicatedHostMutex.Unlock()
	if fake.GetDedicatedHostStub != nil {
		return fake.GetDedicatedHostStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getDedicatedHostReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVirtualServerManager) GetDedicatedHostCallCount() int {
	fake.getDedicatedHostMutex.RLock()
	defer fake.getDedicatedHostMutex.RUnlock()
	return len(fake.getDedicatedHostArgsForCall)
}

func (fake *FakeVirtualServerManager) GetDedicatedHostCalls(stub func(int) (datatypes.Virtual_DedicatedHost, error)) {
	fake.getDedicatedHostMutex.Lock()
	defer fake.getDedicatedHostMutex.Unlock()
	fake.GetDedicatedHostStub = stub
}

func (fake *FakeVirtualServerManager) GetDedicatedHostArgsForCall(i int) int {
	fake.getDedicatedHostMutex.RLock()
	defer fake.getDedicatedHostMutex.RUnlock()
	argsForCall := fake.getDedicatedHostArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeVirtualServerManager) GetDedicatedHostReturns(result1 datatypes.Virtual_DedicatedHost, result2 error) {
	fake.getDedicatedHostMutex.Lock()
	defer fake.getDedicatedHostMutex.Unlock()
	fake.GetDedicatedHostStub = nil
	fake.getDedicatedHostReturns = struct {
		result1 datatypes.Virtual_DedicatedHost
		result2 error
	}{result1, result2}
}

func (fake *FakeVirtualServerManager) GetDedicatedHostReturnsOnCall(i int, result1 datatypes.Virtual_DedicatedHost, result2 error) {
	fake.getDedicatedHostMutex.Lock()
	defer fake.getDedicatedHostMutex.Unlock()
	fake.GetDedicatedHostStub = nil
	if fake.getDedicatedHostReturnsOnCall == nil {
		fake.getDedicatedHostReturnsOnCall = make(map[int]struct {
			result1 datatypes.Virtual_DedicatedHost
			result2 error
		})
	}
	fake.getDedicatedHostReturnsOnCall[i] = struct {
		result1 datatypes.Virtual_DedicatedHost
		result2 error
	}{result1, result2}
}

func (fake *FakeVirtualServerManager) GetInstance(arg1 int, arg2 string) (datatypes.Virtual_Guest, error) {
	fake.getInstanceMutex.Lock()
	ret, specificReturn := fake.getInstanceReturnsOnCall[len(fake.getInstanceArgsForCall)]
	fake.getInstanceArgsForCall = append(fake.getInstanceArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetInstance", []interface{}{arg1, arg2})
	fake.getInstanceMutex.Unlock()
	if fake.GetInstanceStub != nil {
		return fake.GetInstanceStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getInstanceReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVirtualServerManager) GetInstanceCallCount() int {
	fake.getInstanceMutex.RLock()
	defer fake.getInstanceMutex.RUnlock()
	return len(fake.getInstanceArgsForCall)
}

func (fake *FakeVirtualServerManager) GetInstanceCalls(stub func(int, string) (datatypes.Virtual_Guest, error)) {
	fake.getInstanceMutex.Lock()
	defer fake.getInstanceMutex.Unlock()
	fake.GetInstanceStub = stub
}

func (fake *FakeVirtualServerManager) GetInstanceArgsForCall(i int) (int, string) {
	fake.getInstanceMutex.RLock()
	defer fake.getInstanceMutex.RUnlock()
	argsForCall := fake.getInstanceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeVirtualServerManager) GetInstanceReturns(result1 datatypes.Virtual_Guest, result2 error) {
	fake.getInstanceMutex.Lock()
	defer fake.getInstanceMutex.Unlock()
	fake.GetInstanceStub = nil
	fake.getInstanceReturns = struct {
		result1 datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeVirtualServerManager) GetInstanceReturnsOnCall(i int, result1 datatypes.Virtual_Guest, result2 error) {
	fake.getInstanceMutex.Lock()
	defer fake.getInstanceMutex.Unlock()
	fake.GetInstanceStub = nil
	if fake.getInstanceReturnsOnCall == nil {
		fake.getInstanceReturnsOnCall = make(map[int]struct {
			result1 datatypes.Virtual_Guest
			result2 error
		})
	}
	fake.getInstanceReturnsOnCall[i] = struct {
		result1 datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeVirtualServerManager) GetLikedInstance(arg1 *datatypes.Virtual_Guest, arg2 int) (*datatypes.Virtual_Guest, error) {
	fake.getLikedInstanceMutex.Lock()
	ret, specificReturn := fake.getLikedInstanceReturnsOnCall[len(fake.getLikedInstanceArgsForCall)]
	fake.getLikedInstanceArgsForCall = append(fake.getLikedInstanceArgsForCall, struct {
		arg1 *datatypes.Virtual_Guest
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("GetLikedInstance", []interface{}{arg1, arg2})
	fake.getLikedInstanceMutex.Unlock()
	if fake.GetLikedInstanceStub != nil {
		return fake.GetLikedInstanceStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getLikedInstanceReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVirtualServerManager) GetLikedInstanceCallCount() int {
	fake.getLikedInstanceMutex.RLock()
	defer fake.getLikedInstanceMutex.RUnlock()
	return len(fake.getLikedInstanceArgsForCall)
}

func (fake *FakeVirtualServerManager) GetLikedInstanceCalls(stub func(*datatypes.Virtual_Guest, int) (*datatypes.Virtual_Guest, error)) {
	fake.getLikedInstanceMutex.Lock()
	defer fake.getLikedInstanceMutex.Unlock()
	fake.GetLikedInstanceStub = stub
}

func (fake *FakeVirtualServerManager) GetLikedInstanceArgsForCall(i int) (*datatypes.Virtual_Guest, int) {
	fake.getLikedInstanceMutex.RLock()
	defer fake.getLikedInstanceMutex.RUnlock()
	argsForCall := fake.getLikedInstanceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeVirtualServerManager) GetLikedInstanceReturns(result1 *datatypes.Virtual_Guest, result2 error) {
	fake.getLikedInstanceMutex.Lock()
	defer fake.getLikedInstanceMutex.Unlock()
	fake.GetLikedInstanceStub = nil
	fake.getLikedInstanceReturns = struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeVirtualServerManager) GetLikedInstanceReturnsOnCall(i int, result1 *datatypes.Virtual_Guest, result2 error) {
	fake.getLikedInstanceMutex.Lock()
	defer fake.getLikedInstanceMutex.Unlock()
	fake.GetLikedInstanceStub = nil
	if fake.getLikedInstanceReturnsOnCall == nil {
		fake.getLikedInstanceReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Virtual_Guest
			result2 error
		})
	}
	fake.getLikedInstanceReturnsOnCall[i] = struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeVirtualServerManager) InstanceIsReady(arg1 int, arg2 time.Time) (bool, string, error) {
	fake.instanceIsReadyMutex.Lock()
	ret, specificReturn := fake.instanceIsReadyReturnsOnCall[len(fake.instanceIsReadyArgsForCall)]
	fake.instanceIsReadyArgsForCall = append(fake.instanceIsReadyArgsForCall, struct {
		arg1 int
		arg2 time.Time
	}{arg1, arg2})
	fake.recordInvocation("InstanceIsReady", []interface{}{arg1, arg2})
	fake.instanceIsReadyMutex.Unlock()
	if fake.InstanceIsReadyStub != nil {
		return fake.InstanceIsReadyStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.instanceIsReadyReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeVirtualServerManager) InstanceIsReadyCallCount() int {
	fake.instanceIsReadyMutex.RLock()
	defer fake.instanceIsReadyMutex.RUnlock()
	return len(fake.instanceIsReadyArgsForCall)
}

func (fake *FakeVirtualServerManager) InstanceIsReadyCalls(stub func(int, time.Time) (bool, string, error)) {
	fake.instanceIsReadyMutex.Lock()
	defer fake.instanceIsReadyMutex.Unlock()
	fake.InstanceIsReadyStub = stub
}

func (fake *FakeVirtualServerManager) InstanceIsReadyArgsForCall(i int) (int, time.Time) {
	fake.instanceIsReadyMutex.RLock()
	defer fake.instanceIsReadyMutex.RUnlock()
	argsForCall := fake.instanceIsReadyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeVirtualServerManager) InstanceIsReadyReturns(result1 bool, result2 string, result3 error) {
	fake.instanceIsReadyMutex.Lock()
	defer fake.instanceIsReadyMutex.Unlock()
	fake.InstanceIsReadyStub = nil
	fake.instanceIsReadyReturns = struct {
		result1 bool
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeVirtualServerManager) InstanceIsReadyReturnsOnCall(i int, result1 bool, result2 string, result3 error) {
	fake.instanceIsReadyMutex.Lock()
	defer fake.instanceIsReadyMutex.Unlock()
	fake.InstanceIsReadyStub = nil
	if fake.instanceIsReadyReturnsOnCall == nil {
		fake.instanceIsReadyReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 string
			result3 error
		})
	}
	fake.instanceIsReadyReturnsOnCall[i] = struct {
		result1 bool
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeVirtualServerManager) ListDedicatedHost(arg1 string, arg2 string, arg3 string, arg4 int) ([]datatypes.Virtual_DedicatedHost, error) {
	fake.listDedicatedHostMutex.Lock()
	ret, specificReturn := fake.listDedicatedHostReturnsOnCall[len(fake.listDedicatedHostArgsForCall)]
	fake.listDedicatedHostArgsForCall = append(fake.listDedicatedHostArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 int
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("ListDedicatedHost", []interface{}{arg1, arg2, arg3, arg4})
	fake.listDedicatedHostMutex.Unlock()
	if fake.ListDedicatedHostStub != nil {
		return fake.ListDedicatedHostStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listDedicatedHostReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVirtualServerManager) ListDedicatedHostCallCount() int {
	fake.listDedicatedHostMutex.RLock()
	defer fake.listDedicatedHostMutex.RUnlock()
	return len(fake.listDedicatedHostArgsForCall)
}

func (fake *FakeVirtualServerManager) ListDedicatedHostCalls(stub func(string, string, string, int) ([]datatypes.Virtual_DedicatedHost, error)) {
	fake.listDedicatedHostMutex.Lock()
	defer fake.listDedicatedHostMutex.Unlock()
	fake.ListDedicatedHostStub = stub
}

func (fake *FakeVirtualServerManager) ListDedicatedHostArgsForCall(i int) (string, string, string, int) {
	fake.listDedicatedHostMutex.RLock()
	defer fake.listDedicatedHostMutex.RUnlock()
	argsForCall := fake.listDedicatedHostArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeVirtualServerManager) ListDedicatedHostReturns(result1 []datatypes.Virtual_DedicatedHost, result2 error) {
	fake.listDedicatedHostMutex.Lock()
	defer fake.listDedicatedHostMutex.Unlock()
	fake.ListDedicatedHostStub = nil
	fake.listDedicatedHostReturns = struct {
		result1 []datatypes.Virtual_DedicatedHost
		result2 error
	}{result1, result2}
}

func (fake *FakeVirtualServerManager) ListDedicatedHostReturnsOnCall(i int, result1 []datatypes.Virtual_DedicatedHost, result2 error) {
	fake.listDedicatedHostMutex.Lock()
	defer fake.listDedicatedHostMutex.Unlock()
	fake.ListDedicatedHostStub = nil
	if fake.listDedicatedHostReturnsOnCall == nil {
		fake.listDedicatedHostReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Virtual_DedicatedHost
			result2 error
		})
	}
	fake.listDedicatedHostReturnsOnCall[i] = struct {
		result1 []datatypes.Virtual_DedicatedHost
		result2 error
	}{result1, result2}
}

func (fake *FakeVirtualServerManager) ListInstances(arg1 bool, arg2 bool, arg3 string, arg4 string, arg5 string, arg6 string, arg7 string, arg8 string, arg9 int, arg10 int, arg11 int, arg12 int, arg13 []string, arg14 string) ([]datatypes.Virtual_Guest, error) {
	var arg13Copy []string
	if arg13 != nil {
		arg13Copy = make([]string, len(arg13))
		copy(arg13Copy, arg13)
	}
	fake.listInstancesMutex.Lock()
	ret, specificReturn := fake.listInstancesReturnsOnCall[len(fake.listInstancesArgsForCall)]
	fake.listInstancesArgsForCall = append(fake.listInstancesArgsForCall, struct {
		arg1  bool
		arg2  bool
		arg3  string
		arg4  string
		arg5  string
		arg6  string
		arg7  string
		arg8  string
		arg9  int
		arg10 int
		arg11 int
		arg12 int
		arg13 []string
		arg14 string
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13Copy, arg14})
	fake.recordInvocation("ListInstances", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13Copy, arg14})
	fake.listInstancesMutex.Unlock()
	if fake.ListInstancesStub != nil {
		return fake.ListInstancesStub(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listInstancesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVirtualServerManager) ListInstancesCallCount() int {
	fake.listInstancesMutex.RLock()
	defer fake.listInstancesMutex.RUnlock()
	return len(fake.listInstancesArgsForCall)
}

func (fake *FakeVirtualServerManager) ListInstancesCalls(stub func(bool, bool, string, string, string, string, string, string, int, int, int, int, []string, string) ([]datatypes.Virtual_Guest, error)) {
	fake.listInstancesMutex.Lock()
	defer fake.listInstancesMutex.Unlock()
	fake.ListInstancesStub = stub
}

func (fake *FakeVirtualServerManager) ListInstancesArgsForCall(i int) (bool, bool, string, string, string, string, string, string, int, int, int, int, []string, string) {
	fake.listInstancesMutex.RLock()
	defer fake.listInstancesMutex.RUnlock()
	argsForCall := fake.listInstancesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7, argsForCall.arg8, argsForCall.arg9, argsForCall.arg10, argsForCall.arg11, argsForCall.arg12, argsForCall.arg13, argsForCall.arg14
}

func (fake *FakeVirtualServerManager) ListInstancesReturns(result1 []datatypes.Virtual_Guest, result2 error) {
	fake.listInstancesMutex.Lock()
	defer fake.listInstancesMutex.Unlock()
	fake.ListInstancesStub = nil
	fake.listInstancesReturns = struct {
		result1 []datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeVirtualServerManager) ListInstancesReturnsOnCall(i int, result1 []datatypes.Virtual_Guest, result2 error) {
	fake.listInstancesMutex.Lock()
	defer fake.listInstancesMutex.Unlock()
	fake.ListInstancesStub = nil
	if fake.listInstancesReturnsOnCall == nil {
		fake.listInstancesReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Virtual_Guest
			result2 error
		})
	}
	fake.listInstancesReturnsOnCall[i] = struct {
		result1 []datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeVirtualServerManager) PauseInstance(arg1 int) error {
	fake.pauseInstanceMutex.Lock()
	ret, specificReturn := fake.pauseInstanceReturnsOnCall[len(fake.pauseInstanceArgsForCall)]
	fake.pauseInstanceArgsForCall = append(fake.pauseInstanceArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("PauseInstance", []interface{}{arg1})
	fake.pauseInstanceMutex.Unlock()
	if fake.PauseInstanceStub != nil {
		return fake.PauseInstanceStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pauseInstanceReturns
	return fakeReturns.result1
}

func (fake *FakeVirtualServerManager) PauseInstanceCallCount() int {
	fake.pauseInstanceMutex.RLock()
	defer fake.pauseInstanceMutex.RUnlock()
	return len(fake.pauseInstanceArgsForCall)
}

func (fake *FakeVirtualServerManager) PauseInstanceCalls(stub func(int) error) {
	fake.pauseInstanceMutex.Lock()
	defer fake.pauseInstanceMutex.Unlock()
	fake.PauseInstanceStub = stub
}

func (fake *FakeVirtualServerManager) PauseInstanceArgsForCall(i int) int {
	fake.pauseInstanceMutex.RLock()
	defer fake.pauseInstanceMutex.RUnlock()
	argsForCall := fake.pauseInstanceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeVirtualServerManager) PauseInstanceReturns(result1 error) {
	fake.pauseInstanceMutex.Lock()
	defer fake.pauseInstanceMutex.Unlock()
	fake.PauseInstanceStub = nil
	fake.pauseInstanceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVirtualServerManager) PauseInstanceReturnsOnCall(i int, result1 error) {
	fake.pauseInstanceMutex.Lock()
	defer fake.pauseInstanceMutex.Unlock()
	fake.PauseInstanceStub = nil
	if fake.pauseInstanceReturnsOnCall == nil {
		fake.pauseInstanceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pauseInstanceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVirtualServerManager) PowerOffInstance(arg1 int, arg2 bool, arg3 bool) error {
	fake.powerOffInstanceMutex.Lock()
	ret, specificReturn := fake.powerOffInstanceReturnsOnCall[len(fake.powerOffInstanceArgsForCall)]
	fake.powerOffInstanceArgsForCall = append(fake.powerOffInstanceArgsForCall, struct {
		arg1 int
		arg2 bool
		arg3 bool
	}{arg1, arg2, arg3})
	fake.recordInvocation("PowerOffInstance", []interface{}{arg1, arg2, arg3})
	fake.powerOffInstanceMutex.Unlock()
	if fake.PowerOffInstanceStub != nil {
		return fake.PowerOffInstanceStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.powerOffInstanceReturns
	return fakeReturns.result1
}

func (fake *FakeVirtualServerManager) PowerOffInstanceCallCount() int {
	fake.powerOffInstanceMutex.RLock()
	defer fake.powerOffInstanceMutex.RUnlock()
	return len(fake.powerOffInstanceArgsForCall)
}

func (fake *FakeVirtualServerManager) PowerOffInstanceCalls(stub func(int, bool, bool) error) {
	fake.powerOffInstanceMutex.Lock()
	defer fake.powerOffInstanceMutex.Unlock()
	fake.PowerOffInstanceStub = stub
}

func (fake *FakeVirtualServerManager) PowerOffInstanceArgsForCall(i int) (int, bool, bool) {
	fake.powerOffInstanceMutex.RLock()
	defer fake.powerOffInstanceMutex.RUnlock()
	argsForCall := fake.powerOffInstanceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeVirtualServerManager) PowerOffInstanceReturns(result1 error) {
	fake.powerOffInstanceMutex.Lock()
	defer fake.powerOffInstanceMutex.Unlock()
	fake.PowerOffInstanceStub = nil
	fake.powerOffInstanceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVirtualServerManager) PowerOffInstanceReturnsOnCall(i int, result1 error) {
	fake.powerOffInstanceMutex.Lock()
	defer fake.powerOffInstanceMutex.Unlock()
	fake.PowerOffInstanceStub = nil
	if fake.powerOffInstanceReturnsOnCall == nil {
		fake.powerOffInstanceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.powerOffInstanceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVirtualServerManager) PowerOnInstance(arg1 int) error {
	fake.powerOnInstanceMutex.Lock()
	ret, specificReturn := fake.powerOnInstanceReturnsOnCall[len(fake.powerOnInstanceArgsForCall)]
	fake.powerOnInstanceArgsForCall = append(fake.powerOnInstanceArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("PowerOnInstance", []interface{}{arg1})
	fake.powerOnInstanceMutex.Unlock()
	if fake.PowerOnInstanceStub != nil {
		return fake.PowerOnInstanceStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.powerOnInstanceReturns
	return fakeReturns.result1
}

func (fake *FakeVirtualServerManager) PowerOnInstanceCallCount() int {
	fake.powerOnInstanceMutex.RLock()
	defer fake.powerOnInstanceMutex.RUnlock()
	return len(fake.powerOnInstanceArgsForCall)
}

func (fake *FakeVirtualServerManager) PowerOnInstanceCalls(stub func(int) error) {
	fake.powerOnInstanceMutex.Lock()
	defer fake.powerOnInstanceMutex.Unlock()
	fake.PowerOnInstanceStub = stub
}

func (fake *FakeVirtualServerManager) PowerOnInstanceArgsForCall(i int) int {
	fake.powerOnInstanceMutex.RLock()
	defer fake.powerOnInstanceMutex.RUnlock()
	argsForCall := fake.powerOnInstanceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeVirtualServerManager) PowerOnInstanceReturns(result1 error) {
	fake.powerOnInstanceMutex.Lock()
	defer fake.powerOnInstanceMutex.Unlock()
	fake.PowerOnInstanceStub = nil
	fake.powerOnInstanceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVirtualServerManager) PowerOnInstanceReturnsOnCall(i int, result1 error) {
	fake.powerOnInstanceMutex.Lock()
	defer fake.powerOnInstanceMutex.Unlock()
	fake.PowerOnInstanceStub = nil
	if fake.powerOnInstanceReturnsOnCall == nil {
		fake.powerOnInstanceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.powerOnInstanceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVirtualServerManager) RebootInstance(arg1 int, arg2 bool, arg3 bool) error {
	fake.rebootInstanceMutex.Lock()
	ret, specificReturn := fake.rebootInstanceReturnsOnCall[len(fake.rebootInstanceArgsForCall)]
	fake.rebootInstanceArgsForCall = append(fake.rebootInstanceArgsForCall, struct {
		arg1 int
		arg2 bool
		arg3 bool
	}{arg1, arg2, arg3})
	fake.recordInvocation("RebootInstance", []interface{}{arg1, arg2, arg3})
	fake.rebootInstanceMutex.Unlock()
	if fake.RebootInstanceStub != nil {
		return fake.RebootInstanceStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.rebootInstanceReturns
	return fakeReturns.result1
}

func (fake *FakeVirtualServerManager) RebootInstanceCallCount() int {
	fake.rebootInstanceMutex.RLock()
	defer fake.rebootInstanceMutex.RUnlock()
	return len(fake.rebootInstanceArgsForCall)
}

func (fake *FakeVirtualServerManager) RebootInstanceCalls(stub func(int, bool, bool) error) {
	fake.rebootInstanceMutex.Lock()
	defer fake.rebootInstanceMutex.Unlock()
	fake.RebootInstanceStub = stub
}

func (fake *FakeVirtualServerManager) RebootInstanceArgsForCall(i int) (int, bool, bool) {
	fake.rebootInstanceMutex.RLock()
	defer fake.rebootInstanceMutex.RUnlock()
	argsForCall := fake.rebootInstanceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeVirtualServerManager) RebootInstanceReturns(result1 error) {
	fake.rebootInstanceMutex.Lock()
	defer fake.rebootInstanceMutex.Unlock()
	fake.RebootInstanceStub = nil
	fake.rebootInstanceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVirtualServerManager) RebootInstanceReturnsOnCall(i int, result1 error) {
	fake.rebootInstanceMutex.Lock()
	defer fake.rebootInstanceMutex.Unlock()
	fake.RebootInstanceStub = nil
	if fake.rebootInstanceReturnsOnCall == nil {
		fake.rebootInstanceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.rebootInstanceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVirtualServerManager) ReloadInstance(arg1 int, arg2 string, arg3 []int, arg4 int) error {
	var arg3Copy []int
	if arg3 != nil {
		arg3Copy = make([]int, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.reloadInstanceMutex.Lock()
	ret, specificReturn := fake.reloadInstanceReturnsOnCall[len(fake.reloadInstanceArgsForCall)]
	fake.reloadInstanceArgsForCall = append(fake.reloadInstanceArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 []int
		arg4 int
	}{arg1, arg2, arg3Copy, arg4})
	fake.recordInvocation("ReloadInstance", []interface{}{arg1, arg2, arg3Copy, arg4})
	fake.reloadInstanceMutex.Unlock()
	if fake.ReloadInstanceStub != nil {
		return fake.ReloadInstanceStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.reloadInstanceReturns
	return fakeReturns.result1
}

func (fake *FakeVirtualServerManager) ReloadInstanceCallCount() int {
	fake.reloadInstanceMutex.RLock()
	defer fake.reloadInstanceMutex.RUnlock()
	return len(fake.reloadInstanceArgsForCall)
}

func (fake *FakeVirtualServerManager) ReloadInstanceCalls(stub func(int, string, []int, int) error) {
	fake.reloadInstanceMutex.Lock()
	defer fake.reloadInstanceMutex.Unlock()
	fake.ReloadInstanceStub = stub
}

func (fake *FakeVirtualServerManager) ReloadInstanceArgsForCall(i int) (int, string, []int, int) {
	fake.reloadInstanceMutex.RLock()
	defer fake.reloadInstanceMutex.RUnlock()
	argsForCall := fake.reloadInstanceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeVirtualServerManager) ReloadInstanceReturns(result1 error) {
	fake.reloadInstanceMutex.Lock()
	defer fake.reloadInstanceMutex.Unlock()
	fake.ReloadInstanceStub = nil
	fake.reloadInstanceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVirtualServerManager) ReloadInstanceReturnsOnCall(i int, result1 error) {
	fake.reloadInstanceMutex.Lock()
	defer fake.reloadInstanceMutex.Unlock()
	fake.ReloadInstanceStub = nil
	if fake.reloadInstanceReturnsOnCall == nil {
		fake.reloadInstanceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.reloadInstanceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVirtualServerManager) RescueInstance(arg1 int) error {
	fake.rescueInstanceMutex.Lock()
	ret, specificReturn := fake.rescueInstanceReturnsOnCall[len(fake.rescueInstanceArgsForCall)]
	fake.rescueInstanceArgsForCall = append(fake.rescueInstanceArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("RescueInstance", []interface{}{arg1})
	fake.rescueInstanceMutex.Unlock()
	if fake.RescueInstanceStub != nil {
		return fake.RescueInstanceStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.rescueInstanceReturns
	return fakeReturns.result1
}

func (fake *FakeVirtualServerManager) RescueInstanceCallCount() int {
	fake.rescueInstanceMutex.RLock()
	defer fake.rescueInstanceMutex.RUnlock()
	return len(fake.rescueInstanceArgsForCall)
}

func (fake *FakeVirtualServerManager) RescueInstanceCalls(stub func(int) error) {
	fake.rescueInstanceMutex.Lock()
	defer fake.rescueInstanceMutex.Unlock()
	fake.RescueInstanceStub = stub
}

func (fake *FakeVirtualServerManager) RescueInstanceArgsForCall(i int) int {
	fake.rescueInstanceMutex.RLock()
	defer fake.rescueInstanceMutex.RUnlock()
	argsForCall := fake.rescueInstanceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeVirtualServerManager) RescueInstanceReturns(result1 error) {
	fake.rescueInstanceMutex.Lock()
	defer fake.rescueInstanceMutex.Unlock()
	fake.RescueInstanceStub = nil
	fake.rescueInstanceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVirtualServerManager) RescueInstanceReturnsOnCall(i int, result1 error) {
	fake.rescueInstanceMutex.Lock()
	defer fake.rescueInstanceMutex.Unlock()
	fake.RescueInstanceStub = nil
	if fake.rescueInstanceReturnsOnCall == nil {
		fake.rescueInstanceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.rescueInstanceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVirtualServerManager) ResumeInstance(arg1 int) error {
	fake.resumeInstanceMutex.Lock()
	ret, specificReturn := fake.resumeInstanceReturnsOnCall[len(fake.resumeInstanceArgsForCall)]
	fake.resumeInstanceArgsForCall = append(fake.resumeInstanceArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("ResumeInstance", []interface{}{arg1})
	fake.resumeInstanceMutex.Unlock()
	if fake.ResumeInstanceStub != nil {
		return fake.ResumeInstanceStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.resumeInstanceReturns
	return fakeReturns.result1
}

func (fake *FakeVirtualServerManager) ResumeInstanceCallCount() int {
	fake.resumeInstanceMutex.RLock()
	defer fake.resumeInstanceMutex.RUnlock()
	return len(fake.resumeInstanceArgsForCall)
}

func (fake *FakeVirtualServerManager) ResumeInstanceCalls(stub func(int) error) {
	fake.resumeInstanceMutex.Lock()
	defer fake.resumeInstanceMutex.Unlock()
	fake.ResumeInstanceStub = stub
}

func (fake *FakeVirtualServerManager) ResumeInstanceArgsForCall(i int) int {
	fake.resumeInstanceMutex.RLock()
	defer fake.resumeInstanceMutex.RUnlock()
	argsForCall := fake.resumeInstanceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeVirtualServerManager) ResumeInstanceReturns(result1 error) {
	fake.resumeInstanceMutex.Lock()
	defer fake.resumeInstanceMutex.Unlock()
	fake.ResumeInstanceStub = nil
	fake.resumeInstanceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVirtualServerManager) ResumeInstanceReturnsOnCall(i int, result1 error) {
	fake.resumeInstanceMutex.Lock()
	defer fake.resumeInstanceMutex.Unlock()
	fake.ResumeInstanceStub = nil
	if fake.resumeInstanceReturnsOnCall == nil {
		fake.resumeInstanceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resumeInstanceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVirtualServerManager) SetNetworkPortSpeed(arg1 int, arg2 bool, arg3 int) error {
	fake.setNetworkPortSpeedMutex.Lock()
	ret, specificReturn := fake.setNetworkPortSpeedReturnsOnCall[len(fake.setNetworkPortSpeedArgsForCall)]
	fake.setNetworkPortSpeedArgsForCall = append(fake.setNetworkPortSpeedArgsForCall, struct {
		arg1 int
		arg2 bool
		arg3 int
	}{arg1, arg2, arg3})
	fake.recordInvocation("SetNetworkPortSpeed", []interface{}{arg1, arg2, arg3})
	fake.setNetworkPortSpeedMutex.Unlock()
	if fake.SetNetworkPortSpeedStub != nil {
		return fake.SetNetworkPortSpeedStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setNetworkPortSpeedReturns
	return fakeReturns.result1
}

func (fake *FakeVirtualServerManager) SetNetworkPortSpeedCallCount() int {
	fake.setNetworkPortSpeedMutex.RLock()
	defer fake.setNetworkPortSpeedMutex.RUnlock()
	return len(fake.setNetworkPortSpeedArgsForCall)
}

func (fake *FakeVirtualServerManager) SetNetworkPortSpeedCalls(stub func(int, bool, int) error) {
	fake.setNetworkPortSpeedMutex.Lock()
	defer fake.setNetworkPortSpeedMutex.Unlock()
	fake.SetNetworkPortSpeedStub = stub
}

func (fake *FakeVirtualServerManager) SetNetworkPortSpeedArgsForCall(i int) (int, bool, int) {
	fake.setNetworkPortSpeedMutex.RLock()
	defer fake.setNetworkPortSpeedMutex.RUnlock()
	argsForCall := fake.setNetworkPortSpeedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeVirtualServerManager) SetNetworkPortSpeedReturns(result1 error) {
	fake.setNetworkPortSpeedMutex.Lock()
	defer fake.setNetworkPortSpeedMutex.Unlock()
	fake.SetNetworkPortSpeedStub = nil
	fake.setNetworkPortSpeedReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVirtualServerManager) SetNetworkPortSpeedReturnsOnCall(i int, result1 error) {
	fake.setNetworkPortSpeedMutex.Lock()
	defer fake.setNetworkPortSpeedMutex.Unlock()
	fake.SetNetworkPortSpeedStub = nil
	if fake.setNetworkPortSpeedReturnsOnCall == nil {
		fake.setNetworkPortSpeedReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setNetworkPortSpeedReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVirtualServerManager) SetTags(arg1 int, arg2 string) error {
	fake.setTagsMutex.Lock()
	ret, specificReturn := fake.setTagsReturnsOnCall[len(fake.setTagsArgsForCall)]
	fake.setTagsArgsForCall = append(fake.setTagsArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("SetTags", []interface{}{arg1, arg2})
	fake.setTagsMutex.Unlock()
	if fake.SetTagsStub != nil {
		return fake.SetTagsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setTagsReturns
	return fakeReturns.result1
}

func (fake *FakeVirtualServerManager) SetTagsCallCount() int {
	fake.setTagsMutex.RLock()
	defer fake.setTagsMutex.RUnlock()
	return len(fake.setTagsArgsForCall)
}

func (fake *FakeVirtualServerManager) SetTagsCalls(stub func(int, string) error) {
	fake.setTagsMutex.Lock()
	defer fake.setTagsMutex.Unlock()
	fake.SetTagsStub = stub
}

func (fake *FakeVirtualServerManager) SetTagsArgsForCall(i int) (int, string) {
	fake.setTagsMutex.RLock()
	defer fake.setTagsMutex.RUnlock()
	argsForCall := fake.setTagsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeVirtualServerManager) SetTagsReturns(result1 error) {
	fake.setTagsMutex.Lock()
	defer fake.setTagsMutex.Unlock()
	fake.SetTagsStub = nil
	fake.setTagsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVirtualServerManager) SetTagsReturnsOnCall(i int, result1 error) {
	fake.setTagsMutex.Lock()
	defer fake.setTagsMutex.Unlock()
	fake.SetTagsStub = nil
	if fake.setTagsReturnsOnCall == nil {
		fake.setTagsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setTagsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVirtualServerManager) SetUserMetadata(arg1 int, arg2 []string) error {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.setUserMetadataMutex.Lock()
	ret, specificReturn := fake.setUserMetadataReturnsOnCall[len(fake.setUserMetadataArgsForCall)]
	fake.setUserMetadataArgsForCall = append(fake.setUserMetadataArgsForCall, struct {
		arg1 int
		arg2 []string
	}{arg1, arg2Copy})
	fake.recordInvocation("SetUserMetadata", []interface{}{arg1, arg2Copy})
	fake.setUserMetadataMutex.Unlock()
	if fake.SetUserMetadataStub != nil {
		return fake.SetUserMetadataStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setUserMetadataReturns
	return fakeReturns.result1
}

func (fake *FakeVirtualServerManager) SetUserMetadataCallCount() int {
	fake.setUserMetadataMutex.RLock()
	defer fake.setUserMetadataMutex.RUnlock()
	return len(fake.setUserMetadataArgsForCall)
}

func (fake *FakeVirtualServerManager) SetUserMetadataCalls(stub func(int, []string) error) {
	fake.setUserMetadataMutex.Lock()
	defer fake.setUserMetadataMutex.Unlock()
	fake.SetUserMetadataStub = stub
}

func (fake *FakeVirtualServerManager) SetUserMetadataArgsForCall(i int) (int, []string) {
	fake.setUserMetadataMutex.RLock()
	defer fake.setUserMetadataMutex.RUnlock()
	argsForCall := fake.setUserMetadataArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeVirtualServerManager) SetUserMetadataReturns(result1 error) {
	fake.setUserMetadataMutex.Lock()
	defer fake.setUserMetadataMutex.Unlock()
	fake.SetUserMetadataStub = nil
	fake.setUserMetadataReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVirtualServerManager) SetUserMetadataReturnsOnCall(i int, result1 error) {
	fake.setUserMetadataMutex.Lock()
	defer fake.setUserMetadataMutex.Unlock()
	fake.SetUserMetadataStub = nil
	if fake.setUserMetadataReturnsOnCall == nil {
		fake.setUserMetadataReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setUserMetadataReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVirtualServerManager) UpgradeInstance(arg1 int, arg2 int, arg3 int, arg4 int, arg5 bool, arg6 string) (datatypes.Container_Product_Order_Receipt, error) {
	fake.upgradeInstanceMutex.Lock()
	ret, specificReturn := fake.upgradeInstanceReturnsOnCall[len(fake.upgradeInstanceArgsForCall)]
	fake.upgradeInstanceArgsForCall = append(fake.upgradeInstanceArgsForCall, struct {
		arg1 int
		arg2 int
		arg3 int
		arg4 int
		arg5 bool
		arg6 string
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.recordInvocation("UpgradeInstance", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.upgradeInstanceMutex.Unlock()
	if fake.UpgradeInstanceStub != nil {
		return fake.UpgradeInstanceStub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.upgradeInstanceReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVirtualServerManager) UpgradeInstanceCallCount() int {
	fake.upgradeInstanceMutex.RLock()
	defer fake.upgradeInstanceMutex.RUnlock()
	return len(fake.upgradeInstanceArgsForCall)
}

func (fake *FakeVirtualServerManager) UpgradeInstanceCalls(stub func(int, int, int, int, bool, string) (datatypes.Container_Product_Order_Receipt, error)) {
	fake.upgradeInstanceMutex.Lock()
	defer fake.upgradeInstanceMutex.Unlock()
	fake.UpgradeInstanceStub = stub
}

func (fake *FakeVirtualServerManager) UpgradeInstanceArgsForCall(i int) (int, int, int, int, bool, string) {
	fake.upgradeInstanceMutex.RLock()
	defer fake.upgradeInstanceMutex.RUnlock()
	argsForCall := fake.upgradeInstanceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeVirtualServerManager) UpgradeInstanceReturns(result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.upgradeInstanceMutex.Lock()
	defer fake.upgradeInstanceMutex.Unlock()
	fake.UpgradeInstanceStub = nil
	fake.upgradeInstanceReturns = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeVirtualServerManager) UpgradeInstanceReturnsOnCall(i int, result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.upgradeInstanceMutex.Lock()
	defer fake.upgradeInstanceMutex.Unlock()
	fake.UpgradeInstanceStub = nil
	if fake.upgradeInstanceReturnsOnCall == nil {
		fake.upgradeInstanceReturnsOnCall = make(map[int]struct {
			result1 datatypes.Container_Product_Order_Receipt
			result2 error
		})
	}
	fake.upgradeInstanceReturnsOnCall[i] = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeVirtualServerManager) VerifyInstanceCreation(arg1 datatypes.Virtual_Guest) (datatypes.Container_Product_Order, error) {
	fake.verifyInstanceCreationMutex.Lock()
	ret, specificReturn := fake.verifyInstanceCreationReturnsOnCall[len(fake.verifyInstanceCreationArgsForCall)]
	fake.verifyInstanceCreationArgsForCall = append(fake.verifyInstanceCreationArgsForCall, struct {
		arg1 datatypes.Virtual_Guest
	}{arg1})
	fake.recordInvocation("VerifyInstanceCreation", []interface{}{arg1})
	fake.verifyInstanceCreationMutex.Unlock()
	if fake.VerifyInstanceCreationStub != nil {
		return fake.VerifyInstanceCreationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.verifyInstanceCreationReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVirtualServerManager) VerifyInstanceCreationCallCount() int {
	fake.verifyInstanceCreationMutex.RLock()
	defer fake.verifyInstanceCreationMutex.RUnlock()
	return len(fake.verifyInstanceCreationArgsForCall)
}

func (fake *FakeVirtualServerManager) VerifyInstanceCreationCalls(stub func(datatypes.Virtual_Guest) (datatypes.Container_Product_Order, error)) {
	fake.verifyInstanceCreationMutex.Lock()
	defer fake.verifyInstanceCreationMutex.Unlock()
	fake.VerifyInstanceCreationStub = stub
}

func (fake *FakeVirtualServerManager) VerifyInstanceCreationArgsForCall(i int) datatypes.Virtual_Guest {
	fake.verifyInstanceCreationMutex.RLock()
	defer fake.verifyInstanceCreationMutex.RUnlock()
	argsForCall := fake.verifyInstanceCreationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeVirtualServerManager) VerifyInstanceCreationReturns(result1 datatypes.Container_Product_Order, result2 error) {
	fake.verifyInstanceCreationMutex.Lock()
	defer fake.verifyInstanceCreationMutex.Unlock()
	fake.VerifyInstanceCreationStub = nil
	fake.verifyInstanceCreationReturns = struct {
		result1 datatypes.Container_Product_Order
		result2 error
	}{result1, result2}
}

func (fake *FakeVirtualServerManager) VerifyInstanceCreationReturnsOnCall(i int, result1 datatypes.Container_Product_Order, result2 error) {
	fake.verifyInstanceCreationMutex.Lock()
	defer fake.verifyInstanceCreationMutex.Unlock()
	fake.VerifyInstanceCreationStub = nil
	if fake.verifyInstanceCreationReturnsOnCall == nil {
		fake.verifyInstanceCreationReturnsOnCall = make(map[int]struct {
			result1 datatypes.Container_Product_Order
			result2 error
		})
	}
	fake.verifyInstanceCreationReturnsOnCall[i] = struct {
		result1 datatypes.Container_Product_Order
		result2 error
	}{result1, result2}
}

func (fake *FakeVirtualServerManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cancelInstanceMutex.RLock()
	defer fake.cancelInstanceMutex.RUnlock()
	fake.captureImageMutex.RLock()
	defer fake.captureImageMutex.RUnlock()
	fake.createDedicatedHostMutex.RLock()
	defer fake.createDedicatedHostMutex.RUnlock()
	fake.createInstanceMutex.RLock()
	defer fake.createInstanceMutex.RUnlock()
	fake.createInstancesMutex.RLock()
	defer fake.createInstancesMutex.RUnlock()
	fake.editInstanceMutex.RLock()
	defer fake.editInstanceMutex.RUnlock()
	fake.generateInstanceCreationTemplateMutex.RLock()
	defer fake.generateInstanceCreationTemplateMutex.RUnlock()
	fake.getCreateOptionsMutex.RLock()
	defer fake.getCreateOptionsMutex.RUnlock()
	fake.getDedicatedHostMutex.RLock()
	defer fake.getDedicatedHostMutex.RUnlock()
	fake.getInstanceMutex.RLock()
	defer fake.getInstanceMutex.RUnlock()
	fake.getLikedInstanceMutex.RLock()
	defer fake.getLikedInstanceMutex.RUnlock()
	fake.instanceIsReadyMutex.RLock()
	defer fake.instanceIsReadyMutex.RUnlock()
	fake.listDedicatedHostMutex.RLock()
	defer fake.listDedicatedHostMutex.RUnlock()
	fake.listInstancesMutex.RLock()
	defer fake.listInstancesMutex.RUnlock()
	fake.pauseInstanceMutex.RLock()
	defer fake.pauseInstanceMutex.RUnlock()
	fake.powerOffInstanceMutex.RLock()
	defer fake.powerOffInstanceMutex.RUnlock()
	fake.powerOnInstanceMutex.RLock()
	defer fake.powerOnInstanceMutex.RUnlock()
	fake.rebootInstanceMutex.RLock()
	defer fake.rebootInstanceMutex.RUnlock()
	fake.reloadInstanceMutex.RLock()
	defer fake.reloadInstanceMutex.RUnlock()
	fake.rescueInstanceMutex.RLock()
	defer fake.rescueInstanceMutex.RUnlock()
	fake.resumeInstanceMutex.RLock()
	defer fake.resumeInstanceMutex.RUnlock()
	fake.setNetworkPortSpeedMutex.RLock()
	defer fake.setNetworkPortSpeedMutex.RUnlock()
	fake.setTagsMutex.RLock()
	defer fake.setTagsMutex.RUnlock()
	fake.setUserMetadataMutex.RLock()
	defer fake.setUserMetadataMutex.RUnlock()
	fake.upgradeInstanceMutex.RLock()
	defer fake.upgradeInstanceMutex.RUnlock()
	fake.verifyInstanceCreationMutex.RLock()
	defer fake.verifyInstanceCreationMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeVirtualServerManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ managers.VirtualServerManager = new(FakeVirtualServerManager)
