// Code generated by counterfeiter. DO NOT EDIT.
package testhelpers

import (
	"sync"

	"github.com/softlayer/softlayer-go/datatypes"
	"github.ibm.com/SoftLayer/softlayer-cli/plugin/managers"
)

type FakeTagsManager struct {
	DeleteTagStub        func(string) (bool, error)
	deleteTagMutex       sync.RWMutex
	deleteTagArgsForCall []struct {
		arg1 string
	}
	deleteTagReturns struct {
		result1 bool
		result2 error
	}
	deleteTagReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	GetTagByTagNameStub        func(string) ([]datatypes.Tag, error)
	getTagByTagNameMutex       sync.RWMutex
	getTagByTagNameArgsForCall []struct {
		arg1 string
	}
	getTagByTagNameReturns struct {
		result1 []datatypes.Tag
		result2 error
	}
	getTagByTagNameReturnsOnCall map[int]struct {
		result1 []datatypes.Tag
		result2 error
	}
	GetTagReferencesStub        func(int) ([]datatypes.Tag_Reference, error)
	getTagReferencesMutex       sync.RWMutex
	getTagReferencesArgsForCall []struct {
		arg1 int
	}
	getTagReferencesReturns struct {
		result1 []datatypes.Tag_Reference
		result2 error
	}
	getTagReferencesReturnsOnCall map[int]struct {
		result1 []datatypes.Tag_Reference
		result2 error
	}
	GetUnattachedTagsStub        func(string) ([]datatypes.Tag, error)
	getUnattachedTagsMutex       sync.RWMutex
	getUnattachedTagsArgsForCall []struct {
		arg1 string
	}
	getUnattachedTagsReturns struct {
		result1 []datatypes.Tag
		result2 error
	}
	getUnattachedTagsReturnsOnCall map[int]struct {
		result1 []datatypes.Tag
		result2 error
	}
	ListEmptyTagsStub        func() ([]datatypes.Tag, error)
	listEmptyTagsMutex       sync.RWMutex
	listEmptyTagsArgsForCall []struct {
	}
	listEmptyTagsReturns struct {
		result1 []datatypes.Tag
		result2 error
	}
	listEmptyTagsReturnsOnCall map[int]struct {
		result1 []datatypes.Tag
		result2 error
	}
	ListTagsStub        func() ([]datatypes.Tag, error)
	listTagsMutex       sync.RWMutex
	listTagsArgsForCall []struct {
	}
	listTagsReturns struct {
		result1 []datatypes.Tag
		result2 error
	}
	listTagsReturnsOnCall map[int]struct {
		result1 []datatypes.Tag
		result2 error
	}
	ReferenceLookupStub        func(string, int) string
	referenceLookupMutex       sync.RWMutex
	referenceLookupArgsForCall []struct {
		arg1 string
		arg2 int
	}
	referenceLookupReturns struct {
		result1 string
	}
	referenceLookupReturnsOnCall map[int]struct {
		result1 string
	}
	SetTagsStub        func(string, string, int) (bool, error)
	setTagsMutex       sync.RWMutex
	setTagsArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 int
	}
	setTagsReturns struct {
		result1 bool
		result2 error
	}
	setTagsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeTagsManager) DeleteTag(arg1 string) (bool, error) {
	fake.deleteTagMutex.Lock()
	ret, specificReturn := fake.deleteTagReturnsOnCall[len(fake.deleteTagArgsForCall)]
	fake.deleteTagArgsForCall = append(fake.deleteTagArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteTagStub
	fakeReturns := fake.deleteTagReturns
	fake.recordInvocation("DeleteTag", []interface{}{arg1})
	fake.deleteTagMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTagsManager) DeleteTagCallCount() int {
	fake.deleteTagMutex.RLock()
	defer fake.deleteTagMutex.RUnlock()
	return len(fake.deleteTagArgsForCall)
}

func (fake *FakeTagsManager) DeleteTagCalls(stub func(string) (bool, error)) {
	fake.deleteTagMutex.Lock()
	defer fake.deleteTagMutex.Unlock()
	fake.DeleteTagStub = stub
}

func (fake *FakeTagsManager) DeleteTagArgsForCall(i int) string {
	fake.deleteTagMutex.RLock()
	defer fake.deleteTagMutex.RUnlock()
	argsForCall := fake.deleteTagArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTagsManager) DeleteTagReturns(result1 bool, result2 error) {
	fake.deleteTagMutex.Lock()
	defer fake.deleteTagMutex.Unlock()
	fake.DeleteTagStub = nil
	fake.deleteTagReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTagsManager) DeleteTagReturnsOnCall(i int, result1 bool, result2 error) {
	fake.deleteTagMutex.Lock()
	defer fake.deleteTagMutex.Unlock()
	fake.DeleteTagStub = nil
	if fake.deleteTagReturnsOnCall == nil {
		fake.deleteTagReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.deleteTagReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTagsManager) GetTagByTagName(arg1 string) ([]datatypes.Tag, error) {
	fake.getTagByTagNameMutex.Lock()
	ret, specificReturn := fake.getTagByTagNameReturnsOnCall[len(fake.getTagByTagNameArgsForCall)]
	fake.getTagByTagNameArgsForCall = append(fake.getTagByTagNameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetTagByTagNameStub
	fakeReturns := fake.getTagByTagNameReturns
	fake.recordInvocation("GetTagByTagName", []interface{}{arg1})
	fake.getTagByTagNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTagsManager) GetTagByTagNameCallCount() int {
	fake.getTagByTagNameMutex.RLock()
	defer fake.getTagByTagNameMutex.RUnlock()
	return len(fake.getTagByTagNameArgsForCall)
}

func (fake *FakeTagsManager) GetTagByTagNameCalls(stub func(string) ([]datatypes.Tag, error)) {
	fake.getTagByTagNameMutex.Lock()
	defer fake.getTagByTagNameMutex.Unlock()
	fake.GetTagByTagNameStub = stub
}

func (fake *FakeTagsManager) GetTagByTagNameArgsForCall(i int) string {
	fake.getTagByTagNameMutex.RLock()
	defer fake.getTagByTagNameMutex.RUnlock()
	argsForCall := fake.getTagByTagNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTagsManager) GetTagByTagNameReturns(result1 []datatypes.Tag, result2 error) {
	fake.getTagByTagNameMutex.Lock()
	defer fake.getTagByTagNameMutex.Unlock()
	fake.GetTagByTagNameStub = nil
	fake.getTagByTagNameReturns = struct {
		result1 []datatypes.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeTagsManager) GetTagByTagNameReturnsOnCall(i int, result1 []datatypes.Tag, result2 error) {
	fake.getTagByTagNameMutex.Lock()
	defer fake.getTagByTagNameMutex.Unlock()
	fake.GetTagByTagNameStub = nil
	if fake.getTagByTagNameReturnsOnCall == nil {
		fake.getTagByTagNameReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Tag
			result2 error
		})
	}
	fake.getTagByTagNameReturnsOnCall[i] = struct {
		result1 []datatypes.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeTagsManager) GetTagReferences(arg1 int) ([]datatypes.Tag_Reference, error) {
	fake.getTagReferencesMutex.Lock()
	ret, specificReturn := fake.getTagReferencesReturnsOnCall[len(fake.getTagReferencesArgsForCall)]
	fake.getTagReferencesArgsForCall = append(fake.getTagReferencesArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.GetTagReferencesStub
	fakeReturns := fake.getTagReferencesReturns
	fake.recordInvocation("GetTagReferences", []interface{}{arg1})
	fake.getTagReferencesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTagsManager) GetTagReferencesCallCount() int {
	fake.getTagReferencesMutex.RLock()
	defer fake.getTagReferencesMutex.RUnlock()
	return len(fake.getTagReferencesArgsForCall)
}

func (fake *FakeTagsManager) GetTagReferencesCalls(stub func(int) ([]datatypes.Tag_Reference, error)) {
	fake.getTagReferencesMutex.Lock()
	defer fake.getTagReferencesMutex.Unlock()
	fake.GetTagReferencesStub = stub
}

func (fake *FakeTagsManager) GetTagReferencesArgsForCall(i int) int {
	fake.getTagReferencesMutex.RLock()
	defer fake.getTagReferencesMutex.RUnlock()
	argsForCall := fake.getTagReferencesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTagsManager) GetTagReferencesReturns(result1 []datatypes.Tag_Reference, result2 error) {
	fake.getTagReferencesMutex.Lock()
	defer fake.getTagReferencesMutex.Unlock()
	fake.GetTagReferencesStub = nil
	fake.getTagReferencesReturns = struct {
		result1 []datatypes.Tag_Reference
		result2 error
	}{result1, result2}
}

func (fake *FakeTagsManager) GetTagReferencesReturnsOnCall(i int, result1 []datatypes.Tag_Reference, result2 error) {
	fake.getTagReferencesMutex.Lock()
	defer fake.getTagReferencesMutex.Unlock()
	fake.GetTagReferencesStub = nil
	if fake.getTagReferencesReturnsOnCall == nil {
		fake.getTagReferencesReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Tag_Reference
			result2 error
		})
	}
	fake.getTagReferencesReturnsOnCall[i] = struct {
		result1 []datatypes.Tag_Reference
		result2 error
	}{result1, result2}
}

func (fake *FakeTagsManager) GetUnattachedTags(arg1 string) ([]datatypes.Tag, error) {
	fake.getUnattachedTagsMutex.Lock()
	ret, specificReturn := fake.getUnattachedTagsReturnsOnCall[len(fake.getUnattachedTagsArgsForCall)]
	fake.getUnattachedTagsArgsForCall = append(fake.getUnattachedTagsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetUnattachedTagsStub
	fakeReturns := fake.getUnattachedTagsReturns
	fake.recordInvocation("GetUnattachedTags", []interface{}{arg1})
	fake.getUnattachedTagsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTagsManager) GetUnattachedTagsCallCount() int {
	fake.getUnattachedTagsMutex.RLock()
	defer fake.getUnattachedTagsMutex.RUnlock()
	return len(fake.getUnattachedTagsArgsForCall)
}

func (fake *FakeTagsManager) GetUnattachedTagsCalls(stub func(string) ([]datatypes.Tag, error)) {
	fake.getUnattachedTagsMutex.Lock()
	defer fake.getUnattachedTagsMutex.Unlock()
	fake.GetUnattachedTagsStub = stub
}

func (fake *FakeTagsManager) GetUnattachedTagsArgsForCall(i int) string {
	fake.getUnattachedTagsMutex.RLock()
	defer fake.getUnattachedTagsMutex.RUnlock()
	argsForCall := fake.getUnattachedTagsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTagsManager) GetUnattachedTagsReturns(result1 []datatypes.Tag, result2 error) {
	fake.getUnattachedTagsMutex.Lock()
	defer fake.getUnattachedTagsMutex.Unlock()
	fake.GetUnattachedTagsStub = nil
	fake.getUnattachedTagsReturns = struct {
		result1 []datatypes.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeTagsManager) GetUnattachedTagsReturnsOnCall(i int, result1 []datatypes.Tag, result2 error) {
	fake.getUnattachedTagsMutex.Lock()
	defer fake.getUnattachedTagsMutex.Unlock()
	fake.GetUnattachedTagsStub = nil
	if fake.getUnattachedTagsReturnsOnCall == nil {
		fake.getUnattachedTagsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Tag
			result2 error
		})
	}
	fake.getUnattachedTagsReturnsOnCall[i] = struct {
		result1 []datatypes.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeTagsManager) ListEmptyTags() ([]datatypes.Tag, error) {
	fake.listEmptyTagsMutex.Lock()
	ret, specificReturn := fake.listEmptyTagsReturnsOnCall[len(fake.listEmptyTagsArgsForCall)]
	fake.listEmptyTagsArgsForCall = append(fake.listEmptyTagsArgsForCall, struct {
	}{})
	stub := fake.ListEmptyTagsStub
	fakeReturns := fake.listEmptyTagsReturns
	fake.recordInvocation("ListEmptyTags", []interface{}{})
	fake.listEmptyTagsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTagsManager) ListEmptyTagsCallCount() int {
	fake.listEmptyTagsMutex.RLock()
	defer fake.listEmptyTagsMutex.RUnlock()
	return len(fake.listEmptyTagsArgsForCall)
}

func (fake *FakeTagsManager) ListEmptyTagsCalls(stub func() ([]datatypes.Tag, error)) {
	fake.listEmptyTagsMutex.Lock()
	defer fake.listEmptyTagsMutex.Unlock()
	fake.ListEmptyTagsStub = stub
}

func (fake *FakeTagsManager) ListEmptyTagsReturns(result1 []datatypes.Tag, result2 error) {
	fake.listEmptyTagsMutex.Lock()
	defer fake.listEmptyTagsMutex.Unlock()
	fake.ListEmptyTagsStub = nil
	fake.listEmptyTagsReturns = struct {
		result1 []datatypes.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeTagsManager) ListEmptyTagsReturnsOnCall(i int, result1 []datatypes.Tag, result2 error) {
	fake.listEmptyTagsMutex.Lock()
	defer fake.listEmptyTagsMutex.Unlock()
	fake.ListEmptyTagsStub = nil
	if fake.listEmptyTagsReturnsOnCall == nil {
		fake.listEmptyTagsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Tag
			result2 error
		})
	}
	fake.listEmptyTagsReturnsOnCall[i] = struct {
		result1 []datatypes.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeTagsManager) ListTags() ([]datatypes.Tag, error) {
	fake.listTagsMutex.Lock()
	ret, specificReturn := fake.listTagsReturnsOnCall[len(fake.listTagsArgsForCall)]
	fake.listTagsArgsForCall = append(fake.listTagsArgsForCall, struct {
	}{})
	stub := fake.ListTagsStub
	fakeReturns := fake.listTagsReturns
	fake.recordInvocation("ListTags", []interface{}{})
	fake.listTagsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTagsManager) ListTagsCallCount() int {
	fake.listTagsMutex.RLock()
	defer fake.listTagsMutex.RUnlock()
	return len(fake.listTagsArgsForCall)
}

func (fake *FakeTagsManager) ListTagsCalls(stub func() ([]datatypes.Tag, error)) {
	fake.listTagsMutex.Lock()
	defer fake.listTagsMutex.Unlock()
	fake.ListTagsStub = stub
}

func (fake *FakeTagsManager) ListTagsReturns(result1 []datatypes.Tag, result2 error) {
	fake.listTagsMutex.Lock()
	defer fake.listTagsMutex.Unlock()
	fake.ListTagsStub = nil
	fake.listTagsReturns = struct {
		result1 []datatypes.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeTagsManager) ListTagsReturnsOnCall(i int, result1 []datatypes.Tag, result2 error) {
	fake.listTagsMutex.Lock()
	defer fake.listTagsMutex.Unlock()
	fake.ListTagsStub = nil
	if fake.listTagsReturnsOnCall == nil {
		fake.listTagsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Tag
			result2 error
		})
	}
	fake.listTagsReturnsOnCall[i] = struct {
		result1 []datatypes.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeTagsManager) ReferenceLookup(arg1 string, arg2 int) string {
	fake.referenceLookupMutex.Lock()
	ret, specificReturn := fake.referenceLookupReturnsOnCall[len(fake.referenceLookupArgsForCall)]
	fake.referenceLookupArgsForCall = append(fake.referenceLookupArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	stub := fake.ReferenceLookupStub
	fakeReturns := fake.referenceLookupReturns
	fake.recordInvocation("ReferenceLookup", []interface{}{arg1, arg2})
	fake.referenceLookupMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTagsManager) ReferenceLookupCallCount() int {
	fake.referenceLookupMutex.RLock()
	defer fake.referenceLookupMutex.RUnlock()
	return len(fake.referenceLookupArgsForCall)
}

func (fake *FakeTagsManager) ReferenceLookupCalls(stub func(string, int) string) {
	fake.referenceLookupMutex.Lock()
	defer fake.referenceLookupMutex.Unlock()
	fake.ReferenceLookupStub = stub
}

func (fake *FakeTagsManager) ReferenceLookupArgsForCall(i int) (string, int) {
	fake.referenceLookupMutex.RLock()
	defer fake.referenceLookupMutex.RUnlock()
	argsForCall := fake.referenceLookupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTagsManager) ReferenceLookupReturns(result1 string) {
	fake.referenceLookupMutex.Lock()
	defer fake.referenceLookupMutex.Unlock()
	fake.ReferenceLookupStub = nil
	fake.referenceLookupReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTagsManager) ReferenceLookupReturnsOnCall(i int, result1 string) {
	fake.referenceLookupMutex.Lock()
	defer fake.referenceLookupMutex.Unlock()
	fake.ReferenceLookupStub = nil
	if fake.referenceLookupReturnsOnCall == nil {
		fake.referenceLookupReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.referenceLookupReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTagsManager) SetTags(arg1 string, arg2 string, arg3 int) (bool, error) {
	fake.setTagsMutex.Lock()
	ret, specificReturn := fake.setTagsReturnsOnCall[len(fake.setTagsArgsForCall)]
	fake.setTagsArgsForCall = append(fake.setTagsArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.SetTagsStub
	fakeReturns := fake.setTagsReturns
	fake.recordInvocation("SetTags", []interface{}{arg1, arg2, arg3})
	fake.setTagsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTagsManager) SetTagsCallCount() int {
	fake.setTagsMutex.RLock()
	defer fake.setTagsMutex.RUnlock()
	return len(fake.setTagsArgsForCall)
}

func (fake *FakeTagsManager) SetTagsCalls(stub func(string, string, int) (bool, error)) {
	fake.setTagsMutex.Lock()
	defer fake.setTagsMutex.Unlock()
	fake.SetTagsStub = stub
}

func (fake *FakeTagsManager) SetTagsArgsForCall(i int) (string, string, int) {
	fake.setTagsMutex.RLock()
	defer fake.setTagsMutex.RUnlock()
	argsForCall := fake.setTagsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeTagsManager) SetTagsReturns(result1 bool, result2 error) {
	fake.setTagsMutex.Lock()
	defer fake.setTagsMutex.Unlock()
	fake.SetTagsStub = nil
	fake.setTagsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTagsManager) SetTagsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.setTagsMutex.Lock()
	defer fake.setTagsMutex.Unlock()
	fake.SetTagsStub = nil
	if fake.setTagsReturnsOnCall == nil {
		fake.setTagsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.setTagsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTagsManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.deleteTagMutex.RLock()
	defer fake.deleteTagMutex.RUnlock()
	fake.getTagByTagNameMutex.RLock()
	defer fake.getTagByTagNameMutex.RUnlock()
	fake.getTagReferencesMutex.RLock()
	defer fake.getTagReferencesMutex.RUnlock()
	fake.getUnattachedTagsMutex.RLock()
	defer fake.getUnattachedTagsMutex.RUnlock()
	fake.listEmptyTagsMutex.RLock()
	defer fake.listEmptyTagsMutex.RUnlock()
	fake.listTagsMutex.RLock()
	defer fake.listTagsMutex.RUnlock()
	fake.referenceLookupMutex.RLock()
	defer fake.referenceLookupMutex.RUnlock()
	fake.setTagsMutex.RLock()
	defer fake.setTagsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeTagsManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ managers.TagsManager = new(FakeTagsManager)
