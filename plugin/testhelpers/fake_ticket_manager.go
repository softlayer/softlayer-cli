// Code generated by counterfeiter. DO NOT EDIT.
package testhelpers

import (
	"sync"

	"github.com/softlayer/softlayer-go/datatypes"
	"github.ibm.com/SoftLayer/softlayer-cli/plugin/managers"
)

type FakeTicketManager struct {
	AddUpdateStub        func(int, string) error
	addUpdateMutex       sync.RWMutex
	addUpdateArgsForCall []struct {
		arg1 int
		arg2 string
	}
	addUpdateReturns struct {
		result1 error
	}
	addUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	AttachDeviceToTicketStub        func(int, int, bool) error
	attachDeviceToTicketMutex       sync.RWMutex
	attachDeviceToTicketArgsForCall []struct {
		arg1 int
		arg2 int
		arg3 bool
	}
	attachDeviceToTicketReturns struct {
		result1 error
	}
	attachDeviceToTicketReturnsOnCall map[int]struct {
		result1 error
	}
	AttachFileToTicketStub        func(int, string, string) error
	attachFileToTicketMutex       sync.RWMutex
	attachFileToTicketArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 string
	}
	attachFileToTicketReturns struct {
		result1 error
	}
	attachFileToTicketReturnsOnCall map[int]struct {
		result1 error
	}
	CreateStandardTicketStub        func(*managers.TicketArguments) (*int, error)
	createStandardTicketMutex       sync.RWMutex
	createStandardTicketArgsForCall []struct {
		arg1 *managers.TicketArguments
	}
	createStandardTicketReturns struct {
		result1 *int
		result2 error
	}
	createStandardTicketReturnsOnCall map[int]struct {
		result1 *int
		result2 error
	}
	GetAllUpdatesStub        func(int) ([]datatypes.Ticket_Update, error)
	getAllUpdatesMutex       sync.RWMutex
	getAllUpdatesArgsForCall []struct {
		arg1 int
	}
	getAllUpdatesReturns struct {
		result1 []datatypes.Ticket_Update
		result2 error
	}
	getAllUpdatesReturnsOnCall map[int]struct {
		result1 []datatypes.Ticket_Update
		result2 error
	}
	GetSubjectsStub        func() (*[]datatypes.Ticket_Subject, error)
	getSubjectsMutex       sync.RWMutex
	getSubjectsArgsForCall []struct {
	}
	getSubjectsReturns struct {
		result1 *[]datatypes.Ticket_Subject
		result2 error
	}
	getSubjectsReturnsOnCall map[int]struct {
		result1 *[]datatypes.Ticket_Subject
		result2 error
	}
	GetTextStub        func() (string, error)
	getTextMutex       sync.RWMutex
	getTextArgsForCall []struct {
	}
	getTextReturns struct {
		result1 string
		result2 error
	}
	getTextReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetTicketStub        func(int) (datatypes.Ticket, error)
	getTicketMutex       sync.RWMutex
	getTicketArgsForCall []struct {
		arg1 int
	}
	getTicketReturns struct {
		result1 datatypes.Ticket
		result2 error
	}
	getTicketReturnsOnCall map[int]struct {
		result1 datatypes.Ticket
		result2 error
	}
	ListCloseTicketsStub        func() ([]datatypes.Ticket, error)
	listCloseTicketsMutex       sync.RWMutex
	listCloseTicketsArgsForCall []struct {
	}
	listCloseTicketsReturns struct {
		result1 []datatypes.Ticket
		result2 error
	}
	listCloseTicketsReturnsOnCall map[int]struct {
		result1 []datatypes.Ticket
		result2 error
	}
	ListOpenTicketsStub        func() ([]datatypes.Ticket, error)
	listOpenTicketsMutex       sync.RWMutex
	listOpenTicketsArgsForCall []struct {
	}
	listOpenTicketsReturns struct {
		result1 []datatypes.Ticket
		result2 error
	}
	listOpenTicketsReturnsOnCall map[int]struct {
		result1 []datatypes.Ticket
		result2 error
	}
	ListTicketsStub        func() ([]datatypes.Ticket, error)
	listTicketsMutex       sync.RWMutex
	listTicketsArgsForCall []struct {
	}
	listTicketsReturns struct {
		result1 []datatypes.Ticket
		result2 error
	}
	listTicketsReturnsOnCall map[int]struct {
		result1 []datatypes.Ticket
		result2 error
	}
	RemoveDeviceFromTicketStub        func(int, int, bool) error
	removeDeviceFromTicketMutex       sync.RWMutex
	removeDeviceFromTicketArgsForCall []struct {
		arg1 int
		arg2 int
		arg3 bool
	}
	removeDeviceFromTicketReturns struct {
		result1 error
	}
	removeDeviceFromTicketReturnsOnCall map[int]struct {
		result1 error
	}
	SummaryStub        func() (*managers.TicketSummary, error)
	summaryMutex       sync.RWMutex
	summaryArgsForCall []struct {
	}
	summaryReturns struct {
		result1 *managers.TicketSummary
		result2 error
	}
	summaryReturnsOnCall map[int]struct {
		result1 *managers.TicketSummary
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeTicketManager) AddUpdate(arg1 int, arg2 string) error {
	fake.addUpdateMutex.Lock()
	ret, specificReturn := fake.addUpdateReturnsOnCall[len(fake.addUpdateArgsForCall)]
	fake.addUpdateArgsForCall = append(fake.addUpdateArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.AddUpdateStub
	fakeReturns := fake.addUpdateReturns
	fake.recordInvocation("AddUpdate", []interface{}{arg1, arg2})
	fake.addUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTicketManager) AddUpdateCallCount() int {
	fake.addUpdateMutex.RLock()
	defer fake.addUpdateMutex.RUnlock()
	return len(fake.addUpdateArgsForCall)
}

func (fake *FakeTicketManager) AddUpdateCalls(stub func(int, string) error) {
	fake.addUpdateMutex.Lock()
	defer fake.addUpdateMutex.Unlock()
	fake.AddUpdateStub = stub
}

func (fake *FakeTicketManager) AddUpdateArgsForCall(i int) (int, string) {
	fake.addUpdateMutex.RLock()
	defer fake.addUpdateMutex.RUnlock()
	argsForCall := fake.addUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTicketManager) AddUpdateReturns(result1 error) {
	fake.addUpdateMutex.Lock()
	defer fake.addUpdateMutex.Unlock()
	fake.AddUpdateStub = nil
	fake.addUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTicketManager) AddUpdateReturnsOnCall(i int, result1 error) {
	fake.addUpdateMutex.Lock()
	defer fake.addUpdateMutex.Unlock()
	fake.AddUpdateStub = nil
	if fake.addUpdateReturnsOnCall == nil {
		fake.addUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTicketManager) AttachDeviceToTicket(arg1 int, arg2 int, arg3 bool) error {
	fake.attachDeviceToTicketMutex.Lock()
	ret, specificReturn := fake.attachDeviceToTicketReturnsOnCall[len(fake.attachDeviceToTicketArgsForCall)]
	fake.attachDeviceToTicketArgsForCall = append(fake.attachDeviceToTicketArgsForCall, struct {
		arg1 int
		arg2 int
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.AttachDeviceToTicketStub
	fakeReturns := fake.attachDeviceToTicketReturns
	fake.recordInvocation("AttachDeviceToTicket", []interface{}{arg1, arg2, arg3})
	fake.attachDeviceToTicketMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTicketManager) AttachDeviceToTicketCallCount() int {
	fake.attachDeviceToTicketMutex.RLock()
	defer fake.attachDeviceToTicketMutex.RUnlock()
	return len(fake.attachDeviceToTicketArgsForCall)
}

func (fake *FakeTicketManager) AttachDeviceToTicketCalls(stub func(int, int, bool) error) {
	fake.attachDeviceToTicketMutex.Lock()
	defer fake.attachDeviceToTicketMutex.Unlock()
	fake.AttachDeviceToTicketStub = stub
}

func (fake *FakeTicketManager) AttachDeviceToTicketArgsForCall(i int) (int, int, bool) {
	fake.attachDeviceToTicketMutex.RLock()
	defer fake.attachDeviceToTicketMutex.RUnlock()
	argsForCall := fake.attachDeviceToTicketArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeTicketManager) AttachDeviceToTicketReturns(result1 error) {
	fake.attachDeviceToTicketMutex.Lock()
	defer fake.attachDeviceToTicketMutex.Unlock()
	fake.AttachDeviceToTicketStub = nil
	fake.attachDeviceToTicketReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTicketManager) AttachDeviceToTicketReturnsOnCall(i int, result1 error) {
	fake.attachDeviceToTicketMutex.Lock()
	defer fake.attachDeviceToTicketMutex.Unlock()
	fake.AttachDeviceToTicketStub = nil
	if fake.attachDeviceToTicketReturnsOnCall == nil {
		fake.attachDeviceToTicketReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.attachDeviceToTicketReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTicketManager) AttachFileToTicket(arg1 int, arg2 string, arg3 string) error {
	fake.attachFileToTicketMutex.Lock()
	ret, specificReturn := fake.attachFileToTicketReturnsOnCall[len(fake.attachFileToTicketArgsForCall)]
	fake.attachFileToTicketArgsForCall = append(fake.attachFileToTicketArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.AttachFileToTicketStub
	fakeReturns := fake.attachFileToTicketReturns
	fake.recordInvocation("AttachFileToTicket", []interface{}{arg1, arg2, arg3})
	fake.attachFileToTicketMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTicketManager) AttachFileToTicketCallCount() int {
	fake.attachFileToTicketMutex.RLock()
	defer fake.attachFileToTicketMutex.RUnlock()
	return len(fake.attachFileToTicketArgsForCall)
}

func (fake *FakeTicketManager) AttachFileToTicketCalls(stub func(int, string, string) error) {
	fake.attachFileToTicketMutex.Lock()
	defer fake.attachFileToTicketMutex.Unlock()
	fake.AttachFileToTicketStub = stub
}

func (fake *FakeTicketManager) AttachFileToTicketArgsForCall(i int) (int, string, string) {
	fake.attachFileToTicketMutex.RLock()
	defer fake.attachFileToTicketMutex.RUnlock()
	argsForCall := fake.attachFileToTicketArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeTicketManager) AttachFileToTicketReturns(result1 error) {
	fake.attachFileToTicketMutex.Lock()
	defer fake.attachFileToTicketMutex.Unlock()
	fake.AttachFileToTicketStub = nil
	fake.attachFileToTicketReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTicketManager) AttachFileToTicketReturnsOnCall(i int, result1 error) {
	fake.attachFileToTicketMutex.Lock()
	defer fake.attachFileToTicketMutex.Unlock()
	fake.AttachFileToTicketStub = nil
	if fake.attachFileToTicketReturnsOnCall == nil {
		fake.attachFileToTicketReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.attachFileToTicketReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTicketManager) CreateStandardTicket(arg1 *managers.TicketArguments) (*int, error) {
	fake.createStandardTicketMutex.Lock()
	ret, specificReturn := fake.createStandardTicketReturnsOnCall[len(fake.createStandardTicketArgsForCall)]
	fake.createStandardTicketArgsForCall = append(fake.createStandardTicketArgsForCall, struct {
		arg1 *managers.TicketArguments
	}{arg1})
	stub := fake.CreateStandardTicketStub
	fakeReturns := fake.createStandardTicketReturns
	fake.recordInvocation("CreateStandardTicket", []interface{}{arg1})
	fake.createStandardTicketMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTicketManager) CreateStandardTicketCallCount() int {
	fake.createStandardTicketMutex.RLock()
	defer fake.createStandardTicketMutex.RUnlock()
	return len(fake.createStandardTicketArgsForCall)
}

func (fake *FakeTicketManager) CreateStandardTicketCalls(stub func(*managers.TicketArguments) (*int, error)) {
	fake.createStandardTicketMutex.Lock()
	defer fake.createStandardTicketMutex.Unlock()
	fake.CreateStandardTicketStub = stub
}

func (fake *FakeTicketManager) CreateStandardTicketArgsForCall(i int) *managers.TicketArguments {
	fake.createStandardTicketMutex.RLock()
	defer fake.createStandardTicketMutex.RUnlock()
	argsForCall := fake.createStandardTicketArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTicketManager) CreateStandardTicketReturns(result1 *int, result2 error) {
	fake.createStandardTicketMutex.Lock()
	defer fake.createStandardTicketMutex.Unlock()
	fake.CreateStandardTicketStub = nil
	fake.createStandardTicketReturns = struct {
		result1 *int
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) CreateStandardTicketReturnsOnCall(i int, result1 *int, result2 error) {
	fake.createStandardTicketMutex.Lock()
	defer fake.createStandardTicketMutex.Unlock()
	fake.CreateStandardTicketStub = nil
	if fake.createStandardTicketReturnsOnCall == nil {
		fake.createStandardTicketReturnsOnCall = make(map[int]struct {
			result1 *int
			result2 error
		})
	}
	fake.createStandardTicketReturnsOnCall[i] = struct {
		result1 *int
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) GetAllUpdates(arg1 int) ([]datatypes.Ticket_Update, error) {
	fake.getAllUpdatesMutex.Lock()
	ret, specificReturn := fake.getAllUpdatesReturnsOnCall[len(fake.getAllUpdatesArgsForCall)]
	fake.getAllUpdatesArgsForCall = append(fake.getAllUpdatesArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.GetAllUpdatesStub
	fakeReturns := fake.getAllUpdatesReturns
	fake.recordInvocation("GetAllUpdates", []interface{}{arg1})
	fake.getAllUpdatesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTicketManager) GetAllUpdatesCallCount() int {
	fake.getAllUpdatesMutex.RLock()
	defer fake.getAllUpdatesMutex.RUnlock()
	return len(fake.getAllUpdatesArgsForCall)
}

func (fake *FakeTicketManager) GetAllUpdatesCalls(stub func(int) ([]datatypes.Ticket_Update, error)) {
	fake.getAllUpdatesMutex.Lock()
	defer fake.getAllUpdatesMutex.Unlock()
	fake.GetAllUpdatesStub = stub
}

func (fake *FakeTicketManager) GetAllUpdatesArgsForCall(i int) int {
	fake.getAllUpdatesMutex.RLock()
	defer fake.getAllUpdatesMutex.RUnlock()
	argsForCall := fake.getAllUpdatesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTicketManager) GetAllUpdatesReturns(result1 []datatypes.Ticket_Update, result2 error) {
	fake.getAllUpdatesMutex.Lock()
	defer fake.getAllUpdatesMutex.Unlock()
	fake.GetAllUpdatesStub = nil
	fake.getAllUpdatesReturns = struct {
		result1 []datatypes.Ticket_Update
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) GetAllUpdatesReturnsOnCall(i int, result1 []datatypes.Ticket_Update, result2 error) {
	fake.getAllUpdatesMutex.Lock()
	defer fake.getAllUpdatesMutex.Unlock()
	fake.GetAllUpdatesStub = nil
	if fake.getAllUpdatesReturnsOnCall == nil {
		fake.getAllUpdatesReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Ticket_Update
			result2 error
		})
	}
	fake.getAllUpdatesReturnsOnCall[i] = struct {
		result1 []datatypes.Ticket_Update
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) GetSubjects() (*[]datatypes.Ticket_Subject, error) {
	fake.getSubjectsMutex.Lock()
	ret, specificReturn := fake.getSubjectsReturnsOnCall[len(fake.getSubjectsArgsForCall)]
	fake.getSubjectsArgsForCall = append(fake.getSubjectsArgsForCall, struct {
	}{})
	stub := fake.GetSubjectsStub
	fakeReturns := fake.getSubjectsReturns
	fake.recordInvocation("GetSubjects", []interface{}{})
	fake.getSubjectsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTicketManager) GetSubjectsCallCount() int {
	fake.getSubjectsMutex.RLock()
	defer fake.getSubjectsMutex.RUnlock()
	return len(fake.getSubjectsArgsForCall)
}

func (fake *FakeTicketManager) GetSubjectsCalls(stub func() (*[]datatypes.Ticket_Subject, error)) {
	fake.getSubjectsMutex.Lock()
	defer fake.getSubjectsMutex.Unlock()
	fake.GetSubjectsStub = stub
}

func (fake *FakeTicketManager) GetSubjectsReturns(result1 *[]datatypes.Ticket_Subject, result2 error) {
	fake.getSubjectsMutex.Lock()
	defer fake.getSubjectsMutex.Unlock()
	fake.GetSubjectsStub = nil
	fake.getSubjectsReturns = struct {
		result1 *[]datatypes.Ticket_Subject
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) GetSubjectsReturnsOnCall(i int, result1 *[]datatypes.Ticket_Subject, result2 error) {
	fake.getSubjectsMutex.Lock()
	defer fake.getSubjectsMutex.Unlock()
	fake.GetSubjectsStub = nil
	if fake.getSubjectsReturnsOnCall == nil {
		fake.getSubjectsReturnsOnCall = make(map[int]struct {
			result1 *[]datatypes.Ticket_Subject
			result2 error
		})
	}
	fake.getSubjectsReturnsOnCall[i] = struct {
		result1 *[]datatypes.Ticket_Subject
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) GetText() (string, error) {
	fake.getTextMutex.Lock()
	ret, specificReturn := fake.getTextReturnsOnCall[len(fake.getTextArgsForCall)]
	fake.getTextArgsForCall = append(fake.getTextArgsForCall, struct {
	}{})
	stub := fake.GetTextStub
	fakeReturns := fake.getTextReturns
	fake.recordInvocation("GetText", []interface{}{})
	fake.getTextMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTicketManager) GetTextCallCount() int {
	fake.getTextMutex.RLock()
	defer fake.getTextMutex.RUnlock()
	return len(fake.getTextArgsForCall)
}

func (fake *FakeTicketManager) GetTextCalls(stub func() (string, error)) {
	fake.getTextMutex.Lock()
	defer fake.getTextMutex.Unlock()
	fake.GetTextStub = stub
}

func (fake *FakeTicketManager) GetTextReturns(result1 string, result2 error) {
	fake.getTextMutex.Lock()
	defer fake.getTextMutex.Unlock()
	fake.GetTextStub = nil
	fake.getTextReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) GetTextReturnsOnCall(i int, result1 string, result2 error) {
	fake.getTextMutex.Lock()
	defer fake.getTextMutex.Unlock()
	fake.GetTextStub = nil
	if fake.getTextReturnsOnCall == nil {
		fake.getTextReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getTextReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) GetTicket(arg1 int) (datatypes.Ticket, error) {
	fake.getTicketMutex.Lock()
	ret, specificReturn := fake.getTicketReturnsOnCall[len(fake.getTicketArgsForCall)]
	fake.getTicketArgsForCall = append(fake.getTicketArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.GetTicketStub
	fakeReturns := fake.getTicketReturns
	fake.recordInvocation("GetTicket", []interface{}{arg1})
	fake.getTicketMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTicketManager) GetTicketCallCount() int {
	fake.getTicketMutex.RLock()
	defer fake.getTicketMutex.RUnlock()
	return len(fake.getTicketArgsForCall)
}

func (fake *FakeTicketManager) GetTicketCalls(stub func(int) (datatypes.Ticket, error)) {
	fake.getTicketMutex.Lock()
	defer fake.getTicketMutex.Unlock()
	fake.GetTicketStub = stub
}

func (fake *FakeTicketManager) GetTicketArgsForCall(i int) int {
	fake.getTicketMutex.RLock()
	defer fake.getTicketMutex.RUnlock()
	argsForCall := fake.getTicketArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTicketManager) GetTicketReturns(result1 datatypes.Ticket, result2 error) {
	fake.getTicketMutex.Lock()
	defer fake.getTicketMutex.Unlock()
	fake.GetTicketStub = nil
	fake.getTicketReturns = struct {
		result1 datatypes.Ticket
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) GetTicketReturnsOnCall(i int, result1 datatypes.Ticket, result2 error) {
	fake.getTicketMutex.Lock()
	defer fake.getTicketMutex.Unlock()
	fake.GetTicketStub = nil
	if fake.getTicketReturnsOnCall == nil {
		fake.getTicketReturnsOnCall = make(map[int]struct {
			result1 datatypes.Ticket
			result2 error
		})
	}
	fake.getTicketReturnsOnCall[i] = struct {
		result1 datatypes.Ticket
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) ListCloseTickets() ([]datatypes.Ticket, error) {
	fake.listCloseTicketsMutex.Lock()
	ret, specificReturn := fake.listCloseTicketsReturnsOnCall[len(fake.listCloseTicketsArgsForCall)]
	fake.listCloseTicketsArgsForCall = append(fake.listCloseTicketsArgsForCall, struct {
	}{})
	stub := fake.ListCloseTicketsStub
	fakeReturns := fake.listCloseTicketsReturns
	fake.recordInvocation("ListCloseTickets", []interface{}{})
	fake.listCloseTicketsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTicketManager) ListCloseTicketsCallCount() int {
	fake.listCloseTicketsMutex.RLock()
	defer fake.listCloseTicketsMutex.RUnlock()
	return len(fake.listCloseTicketsArgsForCall)
}

func (fake *FakeTicketManager) ListCloseTicketsCalls(stub func() ([]datatypes.Ticket, error)) {
	fake.listCloseTicketsMutex.Lock()
	defer fake.listCloseTicketsMutex.Unlock()
	fake.ListCloseTicketsStub = stub
}

func (fake *FakeTicketManager) ListCloseTicketsReturns(result1 []datatypes.Ticket, result2 error) {
	fake.listCloseTicketsMutex.Lock()
	defer fake.listCloseTicketsMutex.Unlock()
	fake.ListCloseTicketsStub = nil
	fake.listCloseTicketsReturns = struct {
		result1 []datatypes.Ticket
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) ListCloseTicketsReturnsOnCall(i int, result1 []datatypes.Ticket, result2 error) {
	fake.listCloseTicketsMutex.Lock()
	defer fake.listCloseTicketsMutex.Unlock()
	fake.ListCloseTicketsStub = nil
	if fake.listCloseTicketsReturnsOnCall == nil {
		fake.listCloseTicketsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Ticket
			result2 error
		})
	}
	fake.listCloseTicketsReturnsOnCall[i] = struct {
		result1 []datatypes.Ticket
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) ListOpenTickets() ([]datatypes.Ticket, error) {
	fake.listOpenTicketsMutex.Lock()
	ret, specificReturn := fake.listOpenTicketsReturnsOnCall[len(fake.listOpenTicketsArgsForCall)]
	fake.listOpenTicketsArgsForCall = append(fake.listOpenTicketsArgsForCall, struct {
	}{})
	stub := fake.ListOpenTicketsStub
	fakeReturns := fake.listOpenTicketsReturns
	fake.recordInvocation("ListOpenTickets", []interface{}{})
	fake.listOpenTicketsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTicketManager) ListOpenTicketsCallCount() int {
	fake.listOpenTicketsMutex.RLock()
	defer fake.listOpenTicketsMutex.RUnlock()
	return len(fake.listOpenTicketsArgsForCall)
}

func (fake *FakeTicketManager) ListOpenTicketsCalls(stub func() ([]datatypes.Ticket, error)) {
	fake.listOpenTicketsMutex.Lock()
	defer fake.listOpenTicketsMutex.Unlock()
	fake.ListOpenTicketsStub = stub
}

func (fake *FakeTicketManager) ListOpenTicketsReturns(result1 []datatypes.Ticket, result2 error) {
	fake.listOpenTicketsMutex.Lock()
	defer fake.listOpenTicketsMutex.Unlock()
	fake.ListOpenTicketsStub = nil
	fake.listOpenTicketsReturns = struct {
		result1 []datatypes.Ticket
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) ListOpenTicketsReturnsOnCall(i int, result1 []datatypes.Ticket, result2 error) {
	fake.listOpenTicketsMutex.Lock()
	defer fake.listOpenTicketsMutex.Unlock()
	fake.ListOpenTicketsStub = nil
	if fake.listOpenTicketsReturnsOnCall == nil {
		fake.listOpenTicketsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Ticket
			result2 error
		})
	}
	fake.listOpenTicketsReturnsOnCall[i] = struct {
		result1 []datatypes.Ticket
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) ListTickets() ([]datatypes.Ticket, error) {
	fake.listTicketsMutex.Lock()
	ret, specificReturn := fake.listTicketsReturnsOnCall[len(fake.listTicketsArgsForCall)]
	fake.listTicketsArgsForCall = append(fake.listTicketsArgsForCall, struct {
	}{})
	stub := fake.ListTicketsStub
	fakeReturns := fake.listTicketsReturns
	fake.recordInvocation("ListTickets", []interface{}{})
	fake.listTicketsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTicketManager) ListTicketsCallCount() int {
	fake.listTicketsMutex.RLock()
	defer fake.listTicketsMutex.RUnlock()
	return len(fake.listTicketsArgsForCall)
}

func (fake *FakeTicketManager) ListTicketsCalls(stub func() ([]datatypes.Ticket, error)) {
	fake.listTicketsMutex.Lock()
	defer fake.listTicketsMutex.Unlock()
	fake.ListTicketsStub = stub
}

func (fake *FakeTicketManager) ListTicketsReturns(result1 []datatypes.Ticket, result2 error) {
	fake.listTicketsMutex.Lock()
	defer fake.listTicketsMutex.Unlock()
	fake.ListTicketsStub = nil
	fake.listTicketsReturns = struct {
		result1 []datatypes.Ticket
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) ListTicketsReturnsOnCall(i int, result1 []datatypes.Ticket, result2 error) {
	fake.listTicketsMutex.Lock()
	defer fake.listTicketsMutex.Unlock()
	fake.ListTicketsStub = nil
	if fake.listTicketsReturnsOnCall == nil {
		fake.listTicketsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Ticket
			result2 error
		})
	}
	fake.listTicketsReturnsOnCall[i] = struct {
		result1 []datatypes.Ticket
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) RemoveDeviceFromTicket(arg1 int, arg2 int, arg3 bool) error {
	fake.removeDeviceFromTicketMutex.Lock()
	ret, specificReturn := fake.removeDeviceFromTicketReturnsOnCall[len(fake.removeDeviceFromTicketArgsForCall)]
	fake.removeDeviceFromTicketArgsForCall = append(fake.removeDeviceFromTicketArgsForCall, struct {
		arg1 int
		arg2 int
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.RemoveDeviceFromTicketStub
	fakeReturns := fake.removeDeviceFromTicketReturns
	fake.recordInvocation("RemoveDeviceFromTicket", []interface{}{arg1, arg2, arg3})
	fake.removeDeviceFromTicketMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTicketManager) RemoveDeviceFromTicketCallCount() int {
	fake.removeDeviceFromTicketMutex.RLock()
	defer fake.removeDeviceFromTicketMutex.RUnlock()
	return len(fake.removeDeviceFromTicketArgsForCall)
}

func (fake *FakeTicketManager) RemoveDeviceFromTicketCalls(stub func(int, int, bool) error) {
	fake.removeDeviceFromTicketMutex.Lock()
	defer fake.removeDeviceFromTicketMutex.Unlock()
	fake.RemoveDeviceFromTicketStub = stub
}

func (fake *FakeTicketManager) RemoveDeviceFromTicketArgsForCall(i int) (int, int, bool) {
	fake.removeDeviceFromTicketMutex.RLock()
	defer fake.removeDeviceFromTicketMutex.RUnlock()
	argsForCall := fake.removeDeviceFromTicketArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeTicketManager) RemoveDeviceFromTicketReturns(result1 error) {
	fake.removeDeviceFromTicketMutex.Lock()
	defer fake.removeDeviceFromTicketMutex.Unlock()
	fake.RemoveDeviceFromTicketStub = nil
	fake.removeDeviceFromTicketReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTicketManager) RemoveDeviceFromTicketReturnsOnCall(i int, result1 error) {
	fake.removeDeviceFromTicketMutex.Lock()
	defer fake.removeDeviceFromTicketMutex.Unlock()
	fake.RemoveDeviceFromTicketStub = nil
	if fake.removeDeviceFromTicketReturnsOnCall == nil {
		fake.removeDeviceFromTicketReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeDeviceFromTicketReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTicketManager) Summary() (*managers.TicketSummary, error) {
	fake.summaryMutex.Lock()
	ret, specificReturn := fake.summaryReturnsOnCall[len(fake.summaryArgsForCall)]
	fake.summaryArgsForCall = append(fake.summaryArgsForCall, struct {
	}{})
	stub := fake.SummaryStub
	fakeReturns := fake.summaryReturns
	fake.recordInvocation("Summary", []interface{}{})
	fake.summaryMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTicketManager) SummaryCallCount() int {
	fake.summaryMutex.RLock()
	defer fake.summaryMutex.RUnlock()
	return len(fake.summaryArgsForCall)
}

func (fake *FakeTicketManager) SummaryCalls(stub func() (*managers.TicketSummary, error)) {
	fake.summaryMutex.Lock()
	defer fake.summaryMutex.Unlock()
	fake.SummaryStub = stub
}

func (fake *FakeTicketManager) SummaryReturns(result1 *managers.TicketSummary, result2 error) {
	fake.summaryMutex.Lock()
	defer fake.summaryMutex.Unlock()
	fake.SummaryStub = nil
	fake.summaryReturns = struct {
		result1 *managers.TicketSummary
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) SummaryReturnsOnCall(i int, result1 *managers.TicketSummary, result2 error) {
	fake.summaryMutex.Lock()
	defer fake.summaryMutex.Unlock()
	fake.SummaryStub = nil
	if fake.summaryReturnsOnCall == nil {
		fake.summaryReturnsOnCall = make(map[int]struct {
			result1 *managers.TicketSummary
			result2 error
		})
	}
	fake.summaryReturnsOnCall[i] = struct {
		result1 *managers.TicketSummary
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeTicketManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ managers.TicketManager = new(FakeTicketManager)
