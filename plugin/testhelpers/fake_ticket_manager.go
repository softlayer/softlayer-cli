// Code generated by counterfeiter. DO NOT EDIT.
package testhelpers

import (
	"sync"

	"github.com/softlayer/softlayer-go/datatypes"
	"github.ibm.com/cgallo/softlayer-cli/plugin/managers"
)

type FakeTicketManager struct {
	AddUpdateStub        func(int, string) error
	addUpdateMutex       sync.RWMutex
	addUpdateArgsForCall []struct {
		arg1 int
		arg2 string
	}
	addUpdateReturns struct {
		result1 error
	}
	addUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	AttachDeviceToTicketStub        func(int, int, bool) error
	attachDeviceToTicketMutex       sync.RWMutex
	attachDeviceToTicketArgsForCall []struct {
		arg1 int
		arg2 int
		arg3 bool
	}
	attachDeviceToTicketReturns struct {
		result1 error
	}
	attachDeviceToTicketReturnsOnCall map[int]struct {
		result1 error
	}
	AttachFileToTicketStub        func(int, string, string) error
	attachFileToTicketMutex       sync.RWMutex
	attachFileToTicketArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 string
	}
	attachFileToTicketReturns struct {
		result1 error
	}
	attachFileToTicketReturnsOnCall map[int]struct {
		result1 error
	}
	CreateStandardTicketStub        func(*managers.TicketArguments) (*int, error)
	createStandardTicketMutex       sync.RWMutex
	createStandardTicketArgsForCall []struct {
		arg1 *managers.TicketArguments
	}
	createStandardTicketReturns struct {
		result1 *int
		result2 error
	}
	createStandardTicketReturnsOnCall map[int]struct {
		result1 *int
		result2 error
	}
	GetAllUpdatesStub        func(int) ([]datatypes.Ticket_Update, error)
	getAllUpdatesMutex       sync.RWMutex
	getAllUpdatesArgsForCall []struct {
		arg1 int
	}
	getAllUpdatesReturns struct {
		result1 []datatypes.Ticket_Update
		result2 error
	}
	getAllUpdatesReturnsOnCall map[int]struct {
		result1 []datatypes.Ticket_Update
		result2 error
	}
	GetSubjectsStub        func() (*[]datatypes.Ticket_Subject, error)
	getSubjectsMutex       sync.RWMutex
	getSubjectsArgsForCall []struct {
	}
	getSubjectsReturns struct {
		result1 *[]datatypes.Ticket_Subject
		result2 error
	}
	getSubjectsReturnsOnCall map[int]struct {
		result1 *[]datatypes.Ticket_Subject
		result2 error
	}
	GetTextStub        func() (string, error)
	getTextMutex       sync.RWMutex
	getTextArgsForCall []struct {
	}
	getTextReturns struct {
		result1 string
		result2 error
	}
	getTextReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetTicketStub        func(int) (datatypes.Ticket, error)
	getTicketMutex       sync.RWMutex
	getTicketArgsForCall []struct {
		arg1 int
	}
	getTicketReturns struct {
		result1 datatypes.Ticket
		result2 error
	}
	getTicketReturnsOnCall map[int]struct {
		result1 datatypes.Ticket
		result2 error
	}
	ListCloseTicketsStub        func() ([]datatypes.Ticket, error)
	listCloseTicketsMutex       sync.RWMutex
	listCloseTicketsArgsForCall []struct {
	}
	listCloseTicketsReturns struct {
		result1 []datatypes.Ticket
		result2 error
	}
	listCloseTicketsReturnsOnCall map[int]struct {
		result1 []datatypes.Ticket
		result2 error
	}
	ListOpenTicketsStub        func() ([]datatypes.Ticket, error)
	listOpenTicketsMutex       sync.RWMutex
	listOpenTicketsArgsForCall []struct {
	}
	listOpenTicketsReturns struct {
		result1 []datatypes.Ticket
		result2 error
	}
	listOpenTicketsReturnsOnCall map[int]struct {
		result1 []datatypes.Ticket
		result2 error
	}
	ListTicketsStub        func() ([]datatypes.Ticket, error)
	listTicketsMutex       sync.RWMutex
	listTicketsArgsForCall []struct {
	}
	listTicketsReturns struct {
		result1 []datatypes.Ticket
		result2 error
	}
	listTicketsReturnsOnCall map[int]struct {
		result1 []datatypes.Ticket
		result2 error
	}
	RemoveDeviceFromTicketStub        func(int, int, bool) error
	removeDeviceFromTicketMutex       sync.RWMutex
	removeDeviceFromTicketArgsForCall []struct {
		arg1 int
		arg2 int
		arg3 bool
	}
	removeDeviceFromTicketReturns struct {
		result1 error
	}
	removeDeviceFromTicketReturnsOnCall map[int]struct {
		result1 error
	}
	SummaryStub        func() (*managers.TicketSummary, error)
	summaryMutex       sync.RWMutex
	summaryArgsForCall []struct {
	}
	summaryReturns struct {
		result1 *managers.TicketSummary
		result2 error
	}
	summaryReturnsOnCall map[int]struct {
		result1 *managers.TicketSummary
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeTicketManager) AddUpdate(arg1 int, arg2 string) error {
	fake.addUpdateMutex.Lock()
	ret, specificReturn := fake.addUpdateReturnsOnCall[len(fake.addUpdateArgsForCall)]
	fake.addUpdateArgsForCall = append(fake.addUpdateArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("AddUpdate", []interface{}{arg1, arg2})
	fake.addUpdateMutex.Unlock()
	if fake.AddUpdateStub != nil {
		return fake.AddUpdateStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.addUpdateReturns
	return fakeReturns.result1
}

func (fake *FakeTicketManager) AddUpdateCallCount() int {
	fake.addUpdateMutex.RLock()
	defer fake.addUpdateMutex.RUnlock()
	return len(fake.addUpdateArgsForCall)
}

func (fake *FakeTicketManager) AddUpdateCalls(stub func(int, string) error) {
	fake.addUpdateMutex.Lock()
	defer fake.addUpdateMutex.Unlock()
	fake.AddUpdateStub = stub
}

func (fake *FakeTicketManager) AddUpdateArgsForCall(i int) (int, string) {
	fake.addUpdateMutex.RLock()
	defer fake.addUpdateMutex.RUnlock()
	argsForCall := fake.addUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTicketManager) AddUpdateReturns(result1 error) {
	fake.addUpdateMutex.Lock()
	defer fake.addUpdateMutex.Unlock()
	fake.AddUpdateStub = nil
	fake.addUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTicketManager) AddUpdateReturnsOnCall(i int, result1 error) {
	fake.addUpdateMutex.Lock()
	defer fake.addUpdateMutex.Unlock()
	fake.AddUpdateStub = nil
	if fake.addUpdateReturnsOnCall == nil {
		fake.addUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTicketManager) AttachDeviceToTicket(arg1 int, arg2 int, arg3 bool) error {
	fake.attachDeviceToTicketMutex.Lock()
	ret, specificReturn := fake.attachDeviceToTicketReturnsOnCall[len(fake.attachDeviceToTicketArgsForCall)]
	fake.attachDeviceToTicketArgsForCall = append(fake.attachDeviceToTicketArgsForCall, struct {
		arg1 int
		arg2 int
		arg3 bool
	}{arg1, arg2, arg3})
	fake.recordInvocation("AttachDeviceToTicket", []interface{}{arg1, arg2, arg3})
	fake.attachDeviceToTicketMutex.Unlock()
	if fake.AttachDeviceToTicketStub != nil {
		return fake.AttachDeviceToTicketStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.attachDeviceToTicketReturns
	return fakeReturns.result1
}

func (fake *FakeTicketManager) AttachDeviceToTicketCallCount() int {
	fake.attachDeviceToTicketMutex.RLock()
	defer fake.attachDeviceToTicketMutex.RUnlock()
	return len(fake.attachDeviceToTicketArgsForCall)
}

func (fake *FakeTicketManager) AttachDeviceToTicketCalls(stub func(int, int, bool) error) {
	fake.attachDeviceToTicketMutex.Lock()
	defer fake.attachDeviceToTicketMutex.Unlock()
	fake.AttachDeviceToTicketStub = stub
}

func (fake *FakeTicketManager) AttachDeviceToTicketArgsForCall(i int) (int, int, bool) {
	fake.attachDeviceToTicketMutex.RLock()
	defer fake.attachDeviceToTicketMutex.RUnlock()
	argsForCall := fake.attachDeviceToTicketArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeTicketManager) AttachDeviceToTicketReturns(result1 error) {
	fake.attachDeviceToTicketMutex.Lock()
	defer fake.attachDeviceToTicketMutex.Unlock()
	fake.AttachDeviceToTicketStub = nil
	fake.attachDeviceToTicketReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTicketManager) AttachDeviceToTicketReturnsOnCall(i int, result1 error) {
	fake.attachDeviceToTicketMutex.Lock()
	defer fake.attachDeviceToTicketMutex.Unlock()
	fake.AttachDeviceToTicketStub = nil
	if fake.attachDeviceToTicketReturnsOnCall == nil {
		fake.attachDeviceToTicketReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.attachDeviceToTicketReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTicketManager) AttachFileToTicket(arg1 int, arg2 string, arg3 string) error {
	fake.attachFileToTicketMutex.Lock()
	ret, specificReturn := fake.attachFileToTicketReturnsOnCall[len(fake.attachFileToTicketArgsForCall)]
	fake.attachFileToTicketArgsForCall = append(fake.attachFileToTicketArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("AttachFileToTicket", []interface{}{arg1, arg2, arg3})
	fake.attachFileToTicketMutex.Unlock()
	if fake.AttachFileToTicketStub != nil {
		return fake.AttachFileToTicketStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.attachFileToTicketReturns
	return fakeReturns.result1
}

func (fake *FakeTicketManager) AttachFileToTicketCallCount() int {
	fake.attachFileToTicketMutex.RLock()
	defer fake.attachFileToTicketMutex.RUnlock()
	return len(fake.attachFileToTicketArgsForCall)
}

func (fake *FakeTicketManager) AttachFileToTicketCalls(stub func(int, string, string) error) {
	fake.attachFileToTicketMutex.Lock()
	defer fake.attachFileToTicketMutex.Unlock()
	fake.AttachFileToTicketStub = stub
}

func (fake *FakeTicketManager) AttachFileToTicketArgsForCall(i int) (int, string, string) {
	fake.attachFileToTicketMutex.RLock()
	defer fake.attachFileToTicketMutex.RUnlock()
	argsForCall := fake.attachFileToTicketArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeTicketManager) AttachFileToTicketReturns(result1 error) {
	fake.attachFileToTicketMutex.Lock()
	defer fake.attachFileToTicketMutex.Unlock()
	fake.AttachFileToTicketStub = nil
	fake.attachFileToTicketReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTicketManager) AttachFileToTicketReturnsOnCall(i int, result1 error) {
	fake.attachFileToTicketMutex.Lock()
	defer fake.attachFileToTicketMutex.Unlock()
	fake.AttachFileToTicketStub = nil
	if fake.attachFileToTicketReturnsOnCall == nil {
		fake.attachFileToTicketReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.attachFileToTicketReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTicketManager) CreateStandardTicket(arg1 *managers.TicketArguments) (*int, error) {
	fake.createStandardTicketMutex.Lock()
	ret, specificReturn := fake.createStandardTicketReturnsOnCall[len(fake.createStandardTicketArgsForCall)]
	fake.createStandardTicketArgsForCall = append(fake.createStandardTicketArgsForCall, struct {
		arg1 *managers.TicketArguments
	}{arg1})
	fake.recordInvocation("CreateStandardTicket", []interface{}{arg1})
	fake.createStandardTicketMutex.Unlock()
	if fake.CreateStandardTicketStub != nil {
		return fake.CreateStandardTicketStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createStandardTicketReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTicketManager) CreateStandardTicketCallCount() int {
	fake.createStandardTicketMutex.RLock()
	defer fake.createStandardTicketMutex.RUnlock()
	return len(fake.createStandardTicketArgsForCall)
}

func (fake *FakeTicketManager) CreateStandardTicketCalls(stub func(*managers.TicketArguments) (*int, error)) {
	fake.createStandardTicketMutex.Lock()
	defer fake.createStandardTicketMutex.Unlock()
	fake.CreateStandardTicketStub = stub
}

func (fake *FakeTicketManager) CreateStandardTicketArgsForCall(i int) *managers.TicketArguments {
	fake.createStandardTicketMutex.RLock()
	defer fake.createStandardTicketMutex.RUnlock()
	argsForCall := fake.createStandardTicketArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTicketManager) CreateStandardTicketReturns(result1 *int, result2 error) {
	fake.createStandardTicketMutex.Lock()
	defer fake.createStandardTicketMutex.Unlock()
	fake.CreateStandardTicketStub = nil
	fake.createStandardTicketReturns = struct {
		result1 *int
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) CreateStandardTicketReturnsOnCall(i int, result1 *int, result2 error) {
	fake.createStandardTicketMutex.Lock()
	defer fake.createStandardTicketMutex.Unlock()
	fake.CreateStandardTicketStub = nil
	if fake.createStandardTicketReturnsOnCall == nil {
		fake.createStandardTicketReturnsOnCall = make(map[int]struct {
			result1 *int
			result2 error
		})
	}
	fake.createStandardTicketReturnsOnCall[i] = struct {
		result1 *int
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) GetAllUpdates(arg1 int) ([]datatypes.Ticket_Update, error) {
	fake.getAllUpdatesMutex.Lock()
	ret, specificReturn := fake.getAllUpdatesReturnsOnCall[len(fake.getAllUpdatesArgsForCall)]
	fake.getAllUpdatesArgsForCall = append(fake.getAllUpdatesArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("GetAllUpdates", []interface{}{arg1})
	fake.getAllUpdatesMutex.Unlock()
	if fake.GetAllUpdatesStub != nil {
		return fake.GetAllUpdatesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getAllUpdatesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTicketManager) GetAllUpdatesCallCount() int {
	fake.getAllUpdatesMutex.RLock()
	defer fake.getAllUpdatesMutex.RUnlock()
	return len(fake.getAllUpdatesArgsForCall)
}

func (fake *FakeTicketManager) GetAllUpdatesCalls(stub func(int) ([]datatypes.Ticket_Update, error)) {
	fake.getAllUpdatesMutex.Lock()
	defer fake.getAllUpdatesMutex.Unlock()
	fake.GetAllUpdatesStub = stub
}

func (fake *FakeTicketManager) GetAllUpdatesArgsForCall(i int) int {
	fake.getAllUpdatesMutex.RLock()
	defer fake.getAllUpdatesMutex.RUnlock()
	argsForCall := fake.getAllUpdatesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTicketManager) GetAllUpdatesReturns(result1 []datatypes.Ticket_Update, result2 error) {
	fake.getAllUpdatesMutex.Lock()
	defer fake.getAllUpdatesMutex.Unlock()
	fake.GetAllUpdatesStub = nil
	fake.getAllUpdatesReturns = struct {
		result1 []datatypes.Ticket_Update
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) GetAllUpdatesReturnsOnCall(i int, result1 []datatypes.Ticket_Update, result2 error) {
	fake.getAllUpdatesMutex.Lock()
	defer fake.getAllUpdatesMutex.Unlock()
	fake.GetAllUpdatesStub = nil
	if fake.getAllUpdatesReturnsOnCall == nil {
		fake.getAllUpdatesReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Ticket_Update
			result2 error
		})
	}
	fake.getAllUpdatesReturnsOnCall[i] = struct {
		result1 []datatypes.Ticket_Update
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) GetSubjects() (*[]datatypes.Ticket_Subject, error) {
	fake.getSubjectsMutex.Lock()
	ret, specificReturn := fake.getSubjectsReturnsOnCall[len(fake.getSubjectsArgsForCall)]
	fake.getSubjectsArgsForCall = append(fake.getSubjectsArgsForCall, struct {
	}{})
	fake.recordInvocation("GetSubjects", []interface{}{})
	fake.getSubjectsMutex.Unlock()
	if fake.GetSubjectsStub != nil {
		return fake.GetSubjectsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getSubjectsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTicketManager) GetSubjectsCallCount() int {
	fake.getSubjectsMutex.RLock()
	defer fake.getSubjectsMutex.RUnlock()
	return len(fake.getSubjectsArgsForCall)
}

func (fake *FakeTicketManager) GetSubjectsCalls(stub func() (*[]datatypes.Ticket_Subject, error)) {
	fake.getSubjectsMutex.Lock()
	defer fake.getSubjectsMutex.Unlock()
	fake.GetSubjectsStub = stub
}

func (fake *FakeTicketManager) GetSubjectsReturns(result1 *[]datatypes.Ticket_Subject, result2 error) {
	fake.getSubjectsMutex.Lock()
	defer fake.getSubjectsMutex.Unlock()
	fake.GetSubjectsStub = nil
	fake.getSubjectsReturns = struct {
		result1 *[]datatypes.Ticket_Subject
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) GetSubjectsReturnsOnCall(i int, result1 *[]datatypes.Ticket_Subject, result2 error) {
	fake.getSubjectsMutex.Lock()
	defer fake.getSubjectsMutex.Unlock()
	fake.GetSubjectsStub = nil
	if fake.getSubjectsReturnsOnCall == nil {
		fake.getSubjectsReturnsOnCall = make(map[int]struct {
			result1 *[]datatypes.Ticket_Subject
			result2 error
		})
	}
	fake.getSubjectsReturnsOnCall[i] = struct {
		result1 *[]datatypes.Ticket_Subject
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) GetText() (string, error) {
	fake.getTextMutex.Lock()
	ret, specificReturn := fake.getTextReturnsOnCall[len(fake.getTextArgsForCall)]
	fake.getTextArgsForCall = append(fake.getTextArgsForCall, struct {
	}{})
	fake.recordInvocation("GetText", []interface{}{})
	fake.getTextMutex.Unlock()
	if fake.GetTextStub != nil {
		return fake.GetTextStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getTextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTicketManager) GetTextCallCount() int {
	fake.getTextMutex.RLock()
	defer fake.getTextMutex.RUnlock()
	return len(fake.getTextArgsForCall)
}

func (fake *FakeTicketManager) GetTextCalls(stub func() (string, error)) {
	fake.getTextMutex.Lock()
	defer fake.getTextMutex.Unlock()
	fake.GetTextStub = stub
}

func (fake *FakeTicketManager) GetTextReturns(result1 string, result2 error) {
	fake.getTextMutex.Lock()
	defer fake.getTextMutex.Unlock()
	fake.GetTextStub = nil
	fake.getTextReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) GetTextReturnsOnCall(i int, result1 string, result2 error) {
	fake.getTextMutex.Lock()
	defer fake.getTextMutex.Unlock()
	fake.GetTextStub = nil
	if fake.getTextReturnsOnCall == nil {
		fake.getTextReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getTextReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) GetTicket(arg1 int) (datatypes.Ticket, error) {
	fake.getTicketMutex.Lock()
	ret, specificReturn := fake.getTicketReturnsOnCall[len(fake.getTicketArgsForCall)]
	fake.getTicketArgsForCall = append(fake.getTicketArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("GetTicket", []interface{}{arg1})
	fake.getTicketMutex.Unlock()
	if fake.GetTicketStub != nil {
		return fake.GetTicketStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getTicketReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTicketManager) GetTicketCallCount() int {
	fake.getTicketMutex.RLock()
	defer fake.getTicketMutex.RUnlock()
	return len(fake.getTicketArgsForCall)
}

func (fake *FakeTicketManager) GetTicketCalls(stub func(int) (datatypes.Ticket, error)) {
	fake.getTicketMutex.Lock()
	defer fake.getTicketMutex.Unlock()
	fake.GetTicketStub = stub
}

func (fake *FakeTicketManager) GetTicketArgsForCall(i int) int {
	fake.getTicketMutex.RLock()
	defer fake.getTicketMutex.RUnlock()
	argsForCall := fake.getTicketArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTicketManager) GetTicketReturns(result1 datatypes.Ticket, result2 error) {
	fake.getTicketMutex.Lock()
	defer fake.getTicketMutex.Unlock()
	fake.GetTicketStub = nil
	fake.getTicketReturns = struct {
		result1 datatypes.Ticket
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) GetTicketReturnsOnCall(i int, result1 datatypes.Ticket, result2 error) {
	fake.getTicketMutex.Lock()
	defer fake.getTicketMutex.Unlock()
	fake.GetTicketStub = nil
	if fake.getTicketReturnsOnCall == nil {
		fake.getTicketReturnsOnCall = make(map[int]struct {
			result1 datatypes.Ticket
			result2 error
		})
	}
	fake.getTicketReturnsOnCall[i] = struct {
		result1 datatypes.Ticket
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) ListCloseTickets() ([]datatypes.Ticket, error) {
	fake.listCloseTicketsMutex.Lock()
	ret, specificReturn := fake.listCloseTicketsReturnsOnCall[len(fake.listCloseTicketsArgsForCall)]
	fake.listCloseTicketsArgsForCall = append(fake.listCloseTicketsArgsForCall, struct {
	}{})
	fake.recordInvocation("ListCloseTickets", []interface{}{})
	fake.listCloseTicketsMutex.Unlock()
	if fake.ListCloseTicketsStub != nil {
		return fake.ListCloseTicketsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listCloseTicketsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTicketManager) ListCloseTicketsCallCount() int {
	fake.listCloseTicketsMutex.RLock()
	defer fake.listCloseTicketsMutex.RUnlock()
	return len(fake.listCloseTicketsArgsForCall)
}

func (fake *FakeTicketManager) ListCloseTicketsCalls(stub func() ([]datatypes.Ticket, error)) {
	fake.listCloseTicketsMutex.Lock()
	defer fake.listCloseTicketsMutex.Unlock()
	fake.ListCloseTicketsStub = stub
}

func (fake *FakeTicketManager) ListCloseTicketsReturns(result1 []datatypes.Ticket, result2 error) {
	fake.listCloseTicketsMutex.Lock()
	defer fake.listCloseTicketsMutex.Unlock()
	fake.ListCloseTicketsStub = nil
	fake.listCloseTicketsReturns = struct {
		result1 []datatypes.Ticket
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) ListCloseTicketsReturnsOnCall(i int, result1 []datatypes.Ticket, result2 error) {
	fake.listCloseTicketsMutex.Lock()
	defer fake.listCloseTicketsMutex.Unlock()
	fake.ListCloseTicketsStub = nil
	if fake.listCloseTicketsReturnsOnCall == nil {
		fake.listCloseTicketsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Ticket
			result2 error
		})
	}
	fake.listCloseTicketsReturnsOnCall[i] = struct {
		result1 []datatypes.Ticket
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) ListOpenTickets() ([]datatypes.Ticket, error) {
	fake.listOpenTicketsMutex.Lock()
	ret, specificReturn := fake.listOpenTicketsReturnsOnCall[len(fake.listOpenTicketsArgsForCall)]
	fake.listOpenTicketsArgsForCall = append(fake.listOpenTicketsArgsForCall, struct {
	}{})
	fake.recordInvocation("ListOpenTickets", []interface{}{})
	fake.listOpenTicketsMutex.Unlock()
	if fake.ListOpenTicketsStub != nil {
		return fake.ListOpenTicketsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listOpenTicketsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTicketManager) ListOpenTicketsCallCount() int {
	fake.listOpenTicketsMutex.RLock()
	defer fake.listOpenTicketsMutex.RUnlock()
	return len(fake.listOpenTicketsArgsForCall)
}

func (fake *FakeTicketManager) ListOpenTicketsCalls(stub func() ([]datatypes.Ticket, error)) {
	fake.listOpenTicketsMutex.Lock()
	defer fake.listOpenTicketsMutex.Unlock()
	fake.ListOpenTicketsStub = stub
}

func (fake *FakeTicketManager) ListOpenTicketsReturns(result1 []datatypes.Ticket, result2 error) {
	fake.listOpenTicketsMutex.Lock()
	defer fake.listOpenTicketsMutex.Unlock()
	fake.ListOpenTicketsStub = nil
	fake.listOpenTicketsReturns = struct {
		result1 []datatypes.Ticket
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) ListOpenTicketsReturnsOnCall(i int, result1 []datatypes.Ticket, result2 error) {
	fake.listOpenTicketsMutex.Lock()
	defer fake.listOpenTicketsMutex.Unlock()
	fake.ListOpenTicketsStub = nil
	if fake.listOpenTicketsReturnsOnCall == nil {
		fake.listOpenTicketsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Ticket
			result2 error
		})
	}
	fake.listOpenTicketsReturnsOnCall[i] = struct {
		result1 []datatypes.Ticket
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) ListTickets() ([]datatypes.Ticket, error) {
	fake.listTicketsMutex.Lock()
	ret, specificReturn := fake.listTicketsReturnsOnCall[len(fake.listTicketsArgsForCall)]
	fake.listTicketsArgsForCall = append(fake.listTicketsArgsForCall, struct {
	}{})
	fake.recordInvocation("ListTickets", []interface{}{})
	fake.listTicketsMutex.Unlock()
	if fake.ListTicketsStub != nil {
		return fake.ListTicketsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listTicketsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTicketManager) ListTicketsCallCount() int {
	fake.listTicketsMutex.RLock()
	defer fake.listTicketsMutex.RUnlock()
	return len(fake.listTicketsArgsForCall)
}

func (fake *FakeTicketManager) ListTicketsCalls(stub func() ([]datatypes.Ticket, error)) {
	fake.listTicketsMutex.Lock()
	defer fake.listTicketsMutex.Unlock()
	fake.ListTicketsStub = stub
}

func (fake *FakeTicketManager) ListTicketsReturns(result1 []datatypes.Ticket, result2 error) {
	fake.listTicketsMutex.Lock()
	defer fake.listTicketsMutex.Unlock()
	fake.ListTicketsStub = nil
	fake.listTicketsReturns = struct {
		result1 []datatypes.Ticket
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) ListTicketsReturnsOnCall(i int, result1 []datatypes.Ticket, result2 error) {
	fake.listTicketsMutex.Lock()
	defer fake.listTicketsMutex.Unlock()
	fake.ListTicketsStub = nil
	if fake.listTicketsReturnsOnCall == nil {
		fake.listTicketsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Ticket
			result2 error
		})
	}
	fake.listTicketsReturnsOnCall[i] = struct {
		result1 []datatypes.Ticket
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) RemoveDeviceFromTicket(arg1 int, arg2 int, arg3 bool) error {
	fake.removeDeviceFromTicketMutex.Lock()
	ret, specificReturn := fake.removeDeviceFromTicketReturnsOnCall[len(fake.removeDeviceFromTicketArgsForCall)]
	fake.removeDeviceFromTicketArgsForCall = append(fake.removeDeviceFromTicketArgsForCall, struct {
		arg1 int
		arg2 int
		arg3 bool
	}{arg1, arg2, arg3})
	fake.recordInvocation("RemoveDeviceFromTicket", []interface{}{arg1, arg2, arg3})
	fake.removeDeviceFromTicketMutex.Unlock()
	if fake.RemoveDeviceFromTicketStub != nil {
		return fake.RemoveDeviceFromTicketStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removeDeviceFromTicketReturns
	return fakeReturns.result1
}

func (fake *FakeTicketManager) RemoveDeviceFromTicketCallCount() int {
	fake.removeDeviceFromTicketMutex.RLock()
	defer fake.removeDeviceFromTicketMutex.RUnlock()
	return len(fake.removeDeviceFromTicketArgsForCall)
}

func (fake *FakeTicketManager) RemoveDeviceFromTicketCalls(stub func(int, int, bool) error) {
	fake.removeDeviceFromTicketMutex.Lock()
	defer fake.removeDeviceFromTicketMutex.Unlock()
	fake.RemoveDeviceFromTicketStub = stub
}

func (fake *FakeTicketManager) RemoveDeviceFromTicketArgsForCall(i int) (int, int, bool) {
	fake.removeDeviceFromTicketMutex.RLock()
	defer fake.removeDeviceFromTicketMutex.RUnlock()
	argsForCall := fake.removeDeviceFromTicketArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeTicketManager) RemoveDeviceFromTicketReturns(result1 error) {
	fake.removeDeviceFromTicketMutex.Lock()
	defer fake.removeDeviceFromTicketMutex.Unlock()
	fake.RemoveDeviceFromTicketStub = nil
	fake.removeDeviceFromTicketReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTicketManager) RemoveDeviceFromTicketReturnsOnCall(i int, result1 error) {
	fake.removeDeviceFromTicketMutex.Lock()
	defer fake.removeDeviceFromTicketMutex.Unlock()
	fake.RemoveDeviceFromTicketStub = nil
	if fake.removeDeviceFromTicketReturnsOnCall == nil {
		fake.removeDeviceFromTicketReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeDeviceFromTicketReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTicketManager) Summary() (*managers.TicketSummary, error) {
	fake.summaryMutex.Lock()
	ret, specificReturn := fake.summaryReturnsOnCall[len(fake.summaryArgsForCall)]
	fake.summaryArgsForCall = append(fake.summaryArgsForCall, struct {
	}{})
	fake.recordInvocation("Summary", []interface{}{})
	fake.summaryMutex.Unlock()
	if fake.SummaryStub != nil {
		return fake.SummaryStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.summaryReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTicketManager) SummaryCallCount() int {
	fake.summaryMutex.RLock()
	defer fake.summaryMutex.RUnlock()
	return len(fake.summaryArgsForCall)
}

func (fake *FakeTicketManager) SummaryCalls(stub func() (*managers.TicketSummary, error)) {
	fake.summaryMutex.Lock()
	defer fake.summaryMutex.Unlock()
	fake.SummaryStub = stub
}

func (fake *FakeTicketManager) SummaryReturns(result1 *managers.TicketSummary, result2 error) {
	fake.summaryMutex.Lock()
	defer fake.summaryMutex.Unlock()
	fake.SummaryStub = nil
	fake.summaryReturns = struct {
		result1 *managers.TicketSummary
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) SummaryReturnsOnCall(i int, result1 *managers.TicketSummary, result2 error) {
	fake.summaryMutex.Lock()
	defer fake.summaryMutex.Unlock()
	fake.SummaryStub = nil
	if fake.summaryReturnsOnCall == nil {
		fake.summaryReturnsOnCall = make(map[int]struct {
			result1 *managers.TicketSummary
			result2 error
		})
	}
	fake.summaryReturnsOnCall[i] = struct {
		result1 *managers.TicketSummary
		result2 error
	}{result1, result2}
}

func (fake *FakeTicketManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addUpdateMutex.RLock()
	defer fake.addUpdateMutex.RUnlock()
	fake.attachDeviceToTicketMutex.RLock()
	defer fake.attachDeviceToTicketMutex.RUnlock()
	fake.attachFileToTicketMutex.RLock()
	defer fake.attachFileToTicketMutex.RUnlock()
	fake.createStandardTicketMutex.RLock()
	defer fake.createStandardTicketMutex.RUnlock()
	fake.getAllUpdatesMutex.RLock()
	defer fake.getAllUpdatesMutex.RUnlock()
	fake.getSubjectsMutex.RLock()
	defer fake.getSubjectsMutex.RUnlock()
	fake.getTextMutex.RLock()
	defer fake.getTextMutex.RUnlock()
	fake.getTicketMutex.RLock()
	defer fake.getTicketMutex.RUnlock()
	fake.listCloseTicketsMutex.RLock()
	defer fake.listCloseTicketsMutex.RUnlock()
	fake.listOpenTicketsMutex.RLock()
	defer fake.listOpenTicketsMutex.RUnlock()
	fake.listTicketsMutex.RLock()
	defer fake.listTicketsMutex.RUnlock()
	fake.removeDeviceFromTicketMutex.RLock()
	defer fake.removeDeviceFromTicketMutex.RUnlock()
	fake.summaryMutex.RLock()
	defer fake.summaryMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeTicketManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ managers.TicketManager = new(FakeTicketManager)
