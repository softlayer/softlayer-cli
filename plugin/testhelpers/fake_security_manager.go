// Code generated by counterfeiter. DO NOT EDIT.
package testhelpers

import (
	"sync"

	"github.com/softlayer/softlayer-go/datatypes"
	"github.ibm.com/SoftLayer/softlayer-cli/plugin/managers"
)

type FakeSecurityManager struct {
	AddCertificateStub        func(datatypes.Security_Certificate) (datatypes.Security_Certificate, error)
	addCertificateMutex       sync.RWMutex
	addCertificateArgsForCall []struct {
		arg1 datatypes.Security_Certificate
	}
	addCertificateReturns struct {
		result1 datatypes.Security_Certificate
		result2 error
	}
	addCertificateReturnsOnCall map[int]struct {
		result1 datatypes.Security_Certificate
		result2 error
	}
	AddSSHKeyStub        func(string, string, string) (datatypes.Security_Ssh_Key, error)
	addSSHKeyMutex       sync.RWMutex
	addSSHKeyArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	addSSHKeyReturns struct {
		result1 datatypes.Security_Ssh_Key
		result2 error
	}
	addSSHKeyReturnsOnCall map[int]struct {
		result1 datatypes.Security_Ssh_Key
		result2 error
	}
	DeleteSSHKeyStub        func(int) error
	deleteSSHKeyMutex       sync.RWMutex
	deleteSSHKeyArgsForCall []struct {
		arg1 int
	}
	deleteSSHKeyReturns struct {
		result1 error
	}
	deleteSSHKeyReturnsOnCall map[int]struct {
		result1 error
	}
	EditCertificateStub        func(datatypes.Security_Certificate) error
	editCertificateMutex       sync.RWMutex
	editCertificateArgsForCall []struct {
		arg1 datatypes.Security_Certificate
	}
	editCertificateReturns struct {
		result1 error
	}
	editCertificateReturnsOnCall map[int]struct {
		result1 error
	}
	EditSSHKeyStub        func(int, string, string) error
	editSSHKeyMutex       sync.RWMutex
	editSSHKeyArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 string
	}
	editSSHKeyReturns struct {
		result1 error
	}
	editSSHKeyReturnsOnCall map[int]struct {
		result1 error
	}
	GetCertificateStub        func(int) (datatypes.Security_Certificate, error)
	getCertificateMutex       sync.RWMutex
	getCertificateArgsForCall []struct {
		arg1 int
	}
	getCertificateReturns struct {
		result1 datatypes.Security_Certificate
		result2 error
	}
	getCertificateReturnsOnCall map[int]struct {
		result1 datatypes.Security_Certificate
		result2 error
	}
	GetSSHKeyStub        func(int) (datatypes.Security_Ssh_Key, error)
	getSSHKeyMutex       sync.RWMutex
	getSSHKeyArgsForCall []struct {
		arg1 int
	}
	getSSHKeyReturns struct {
		result1 datatypes.Security_Ssh_Key
		result2 error
	}
	getSSHKeyReturnsOnCall map[int]struct {
		result1 datatypes.Security_Ssh_Key
		result2 error
	}
	GetSSHKeyIDsFromLabelStub        func(string) ([]int, error)
	getSSHKeyIDsFromLabelMutex       sync.RWMutex
	getSSHKeyIDsFromLabelArgsForCall []struct {
		arg1 string
	}
	getSSHKeyIDsFromLabelReturns struct {
		result1 []int
		result2 error
	}
	getSSHKeyIDsFromLabelReturnsOnCall map[int]struct {
		result1 []int
		result2 error
	}
	ListCertificatesStub        func(string) ([]datatypes.Security_Certificate, error)
	listCertificatesMutex       sync.RWMutex
	listCertificatesArgsForCall []struct {
		arg1 string
	}
	listCertificatesReturns struct {
		result1 []datatypes.Security_Certificate
		result2 error
	}
	listCertificatesReturnsOnCall map[int]struct {
		result1 []datatypes.Security_Certificate
		result2 error
	}
	ListSSHKeysStub        func(string) ([]datatypes.Security_Ssh_Key, error)
	listSSHKeysMutex       sync.RWMutex
	listSSHKeysArgsForCall []struct {
		arg1 string
	}
	listSSHKeysReturns struct {
		result1 []datatypes.Security_Ssh_Key
		result2 error
	}
	listSSHKeysReturnsOnCall map[int]struct {
		result1 []datatypes.Security_Ssh_Key
		result2 error
	}
	RemoveCertificateStub        func(int) error
	removeCertificateMutex       sync.RWMutex
	removeCertificateArgsForCall []struct {
		arg1 int
	}
	removeCertificateReturns struct {
		result1 error
	}
	removeCertificateReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSecurityManager) AddCertificate(arg1 datatypes.Security_Certificate) (datatypes.Security_Certificate, error) {
	fake.addCertificateMutex.Lock()
	ret, specificReturn := fake.addCertificateReturnsOnCall[len(fake.addCertificateArgsForCall)]
	fake.addCertificateArgsForCall = append(fake.addCertificateArgsForCall, struct {
		arg1 datatypes.Security_Certificate
	}{arg1})
	stub := fake.AddCertificateStub
	fakeReturns := fake.addCertificateReturns
	fake.recordInvocation("AddCertificate", []interface{}{arg1})
	fake.addCertificateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSecurityManager) AddCertificateCallCount() int {
	fake.addCertificateMutex.RLock()
	defer fake.addCertificateMutex.RUnlock()
	return len(fake.addCertificateArgsForCall)
}

func (fake *FakeSecurityManager) AddCertificateCalls(stub func(datatypes.Security_Certificate) (datatypes.Security_Certificate, error)) {
	fake.addCertificateMutex.Lock()
	defer fake.addCertificateMutex.Unlock()
	fake.AddCertificateStub = stub
}

func (fake *FakeSecurityManager) AddCertificateArgsForCall(i int) datatypes.Security_Certificate {
	fake.addCertificateMutex.RLock()
	defer fake.addCertificateMutex.RUnlock()
	argsForCall := fake.addCertificateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSecurityManager) AddCertificateReturns(result1 datatypes.Security_Certificate, result2 error) {
	fake.addCertificateMutex.Lock()
	defer fake.addCertificateMutex.Unlock()
	fake.AddCertificateStub = nil
	fake.addCertificateReturns = struct {
		result1 datatypes.Security_Certificate
		result2 error
	}{result1, result2}
}

func (fake *FakeSecurityManager) AddCertificateReturnsOnCall(i int, result1 datatypes.Security_Certificate, result2 error) {
	fake.addCertificateMutex.Lock()
	defer fake.addCertificateMutex.Unlock()
	fake.AddCertificateStub = nil
	if fake.addCertificateReturnsOnCall == nil {
		fake.addCertificateReturnsOnCall = make(map[int]struct {
			result1 datatypes.Security_Certificate
			result2 error
		})
	}
	fake.addCertificateReturnsOnCall[i] = struct {
		result1 datatypes.Security_Certificate
		result2 error
	}{result1, result2}
}

func (fake *FakeSecurityManager) AddSSHKey(arg1 string, arg2 string, arg3 string) (datatypes.Security_Ssh_Key, error) {
	fake.addSSHKeyMutex.Lock()
	ret, specificReturn := fake.addSSHKeyReturnsOnCall[len(fake.addSSHKeyArgsForCall)]
	fake.addSSHKeyArgsForCall = append(fake.addSSHKeyArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.AddSSHKeyStub
	fakeReturns := fake.addSSHKeyReturns
	fake.recordInvocation("AddSSHKey", []interface{}{arg1, arg2, arg3})
	fake.addSSHKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSecurityManager) AddSSHKeyCallCount() int {
	fake.addSSHKeyMutex.RLock()
	defer fake.addSSHKeyMutex.RUnlock()
	return len(fake.addSSHKeyArgsForCall)
}

func (fake *FakeSecurityManager) AddSSHKeyCalls(stub func(string, string, string) (datatypes.Security_Ssh_Key, error)) {
	fake.addSSHKeyMutex.Lock()
	defer fake.addSSHKeyMutex.Unlock()
	fake.AddSSHKeyStub = stub
}

func (fake *FakeSecurityManager) AddSSHKeyArgsForCall(i int) (string, string, string) {
	fake.addSSHKeyMutex.RLock()
	defer fake.addSSHKeyMutex.RUnlock()
	argsForCall := fake.addSSHKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeSecurityManager) AddSSHKeyReturns(result1 datatypes.Security_Ssh_Key, result2 error) {
	fake.addSSHKeyMutex.Lock()
	defer fake.addSSHKeyMutex.Unlock()
	fake.AddSSHKeyStub = nil
	fake.addSSHKeyReturns = struct {
		result1 datatypes.Security_Ssh_Key
		result2 error
	}{result1, result2}
}

func (fake *FakeSecurityManager) AddSSHKeyReturnsOnCall(i int, result1 datatypes.Security_Ssh_Key, result2 error) {
	fake.addSSHKeyMutex.Lock()
	defer fake.addSSHKeyMutex.Unlock()
	fake.AddSSHKeyStub = nil
	if fake.addSSHKeyReturnsOnCall == nil {
		fake.addSSHKeyReturnsOnCall = make(map[int]struct {
			result1 datatypes.Security_Ssh_Key
			result2 error
		})
	}
	fake.addSSHKeyReturnsOnCall[i] = struct {
		result1 datatypes.Security_Ssh_Key
		result2 error
	}{result1, result2}
}

func (fake *FakeSecurityManager) DeleteSSHKey(arg1 int) error {
	fake.deleteSSHKeyMutex.Lock()
	ret, specificReturn := fake.deleteSSHKeyReturnsOnCall[len(fake.deleteSSHKeyArgsForCall)]
	fake.deleteSSHKeyArgsForCall = append(fake.deleteSSHKeyArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.DeleteSSHKeyStub
	fakeReturns := fake.deleteSSHKeyReturns
	fake.recordInvocation("DeleteSSHKey", []interface{}{arg1})
	fake.deleteSSHKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSecurityManager) DeleteSSHKeyCallCount() int {
	fake.deleteSSHKeyMutex.RLock()
	defer fake.deleteSSHKeyMutex.RUnlock()
	return len(fake.deleteSSHKeyArgsForCall)
}

func (fake *FakeSecurityManager) DeleteSSHKeyCalls(stub func(int) error) {
	fake.deleteSSHKeyMutex.Lock()
	defer fake.deleteSSHKeyMutex.Unlock()
	fake.DeleteSSHKeyStub = stub
}

func (fake *FakeSecurityManager) DeleteSSHKeyArgsForCall(i int) int {
	fake.deleteSSHKeyMutex.RLock()
	defer fake.deleteSSHKeyMutex.RUnlock()
	argsForCall := fake.deleteSSHKeyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSecurityManager) DeleteSSHKeyReturns(result1 error) {
	fake.deleteSSHKeyMutex.Lock()
	defer fake.deleteSSHKeyMutex.Unlock()
	fake.DeleteSSHKeyStub = nil
	fake.deleteSSHKeyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSecurityManager) DeleteSSHKeyReturnsOnCall(i int, result1 error) {
	fake.deleteSSHKeyMutex.Lock()
	defer fake.deleteSSHKeyMutex.Unlock()
	fake.DeleteSSHKeyStub = nil
	if fake.deleteSSHKeyReturnsOnCall == nil {
		fake.deleteSSHKeyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteSSHKeyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSecurityManager) EditCertificate(arg1 datatypes.Security_Certificate) error {
	fake.editCertificateMutex.Lock()
	ret, specificReturn := fake.editCertificateReturnsOnCall[len(fake.editCertificateArgsForCall)]
	fake.editCertificateArgsForCall = append(fake.editCertificateArgsForCall, struct {
		arg1 datatypes.Security_Certificate
	}{arg1})
	stub := fake.EditCertificateStub
	fakeReturns := fake.editCertificateReturns
	fake.recordInvocation("EditCertificate", []interface{}{arg1})
	fake.editCertificateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSecurityManager) EditCertificateCallCount() int {
	fake.editCertificateMutex.RLock()
	defer fake.editCertificateMutex.RUnlock()
	return len(fake.editCertificateArgsForCall)
}

func (fake *FakeSecurityManager) EditCertificateCalls(stub func(datatypes.Security_Certificate) error) {
	fake.editCertificateMutex.Lock()
	defer fake.editCertificateMutex.Unlock()
	fake.EditCertificateStub = stub
}

func (fake *FakeSecurityManager) EditCertificateArgsForCall(i int) datatypes.Security_Certificate {
	fake.editCertificateMutex.RLock()
	defer fake.editCertificateMutex.RUnlock()
	argsForCall := fake.editCertificateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSecurityManager) EditCertificateReturns(result1 error) {
	fake.editCertificateMutex.Lock()
	defer fake.editCertificateMutex.Unlock()
	fake.EditCertificateStub = nil
	fake.editCertificateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSecurityManager) EditCertificateReturnsOnCall(i int, result1 error) {
	fake.editCertificateMutex.Lock()
	defer fake.editCertificateMutex.Unlock()
	fake.EditCertificateStub = nil
	if fake.editCertificateReturnsOnCall == nil {
		fake.editCertificateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.editCertificateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSecurityManager) EditSSHKey(arg1 int, arg2 string, arg3 string) error {
	fake.editSSHKeyMutex.Lock()
	ret, specificReturn := fake.editSSHKeyReturnsOnCall[len(fake.editSSHKeyArgsForCall)]
	fake.editSSHKeyArgsForCall = append(fake.editSSHKeyArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.EditSSHKeyStub
	fakeReturns := fake.editSSHKeyReturns
	fake.recordInvocation("EditSSHKey", []interface{}{arg1, arg2, arg3})
	fake.editSSHKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSecurityManager) EditSSHKeyCallCount() int {
	fake.editSSHKeyMutex.RLock()
	defer fake.editSSHKeyMutex.RUnlock()
	return len(fake.editSSHKeyArgsForCall)
}

func (fake *FakeSecurityManager) EditSSHKeyCalls(stub func(int, string, string) error) {
	fake.editSSHKeyMutex.Lock()
	defer fake.editSSHKeyMutex.Unlock()
	fake.EditSSHKeyStub = stub
}

func (fake *FakeSecurityManager) EditSSHKeyArgsForCall(i int) (int, string, string) {
	fake.editSSHKeyMutex.RLock()
	defer fake.editSSHKeyMutex.RUnlock()
	argsForCall := fake.editSSHKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeSecurityManager) EditSSHKeyReturns(result1 error) {
	fake.editSSHKeyMutex.Lock()
	defer fake.editSSHKeyMutex.Unlock()
	fake.EditSSHKeyStub = nil
	fake.editSSHKeyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSecurityManager) EditSSHKeyReturnsOnCall(i int, result1 error) {
	fake.editSSHKeyMutex.Lock()
	defer fake.editSSHKeyMutex.Unlock()
	fake.EditSSHKeyStub = nil
	if fake.editSSHKeyReturnsOnCall == nil {
		fake.editSSHKeyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.editSSHKeyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSecurityManager) GetCertificate(arg1 int) (datatypes.Security_Certificate, error) {
	fake.getCertificateMutex.Lock()
	ret, specificReturn := fake.getCertificateReturnsOnCall[len(fake.getCertificateArgsForCall)]
	fake.getCertificateArgsForCall = append(fake.getCertificateArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.GetCertificateStub
	fakeReturns := fake.getCertificateReturns
	fake.recordInvocation("GetCertificate", []interface{}{arg1})
	fake.getCertificateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSecurityManager) GetCertificateCallCount() int {
	fake.getCertificateMutex.RLock()
	defer fake.getCertificateMutex.RUnlock()
	return len(fake.getCertificateArgsForCall)
}

func (fake *FakeSecurityManager) GetCertificateCalls(stub func(int) (datatypes.Security_Certificate, error)) {
	fake.getCertificateMutex.Lock()
	defer fake.getCertificateMutex.Unlock()
	fake.GetCertificateStub = stub
}

func (fake *FakeSecurityManager) GetCertificateArgsForCall(i int) int {
	fake.getCertificateMutex.RLock()
	defer fake.getCertificateMutex.RUnlock()
	argsForCall := fake.getCertificateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSecurityManager) GetCertificateReturns(result1 datatypes.Security_Certificate, result2 error) {
	fake.getCertificateMutex.Lock()
	defer fake.getCertificateMutex.Unlock()
	fake.GetCertificateStub = nil
	fake.getCertificateReturns = struct {
		result1 datatypes.Security_Certificate
		result2 error
	}{result1, result2}
}

func (fake *FakeSecurityManager) GetCertificateReturnsOnCall(i int, result1 datatypes.Security_Certificate, result2 error) {
	fake.getCertificateMutex.Lock()
	defer fake.getCertificateMutex.Unlock()
	fake.GetCertificateStub = nil
	if fake.getCertificateReturnsOnCall == nil {
		fake.getCertificateReturnsOnCall = make(map[int]struct {
			result1 datatypes.Security_Certificate
			result2 error
		})
	}
	fake.getCertificateReturnsOnCall[i] = struct {
		result1 datatypes.Security_Certificate
		result2 error
	}{result1, result2}
}

func (fake *FakeSecurityManager) GetSSHKey(arg1 int) (datatypes.Security_Ssh_Key, error) {
	fake.getSSHKeyMutex.Lock()
	ret, specificReturn := fake.getSSHKeyReturnsOnCall[len(fake.getSSHKeyArgsForCall)]
	fake.getSSHKeyArgsForCall = append(fake.getSSHKeyArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.GetSSHKeyStub
	fakeReturns := fake.getSSHKeyReturns
	fake.recordInvocation("GetSSHKey", []interface{}{arg1})
	fake.getSSHKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSecurityManager) GetSSHKeyCallCount() int {
	fake.getSSHKeyMutex.RLock()
	defer fake.getSSHKeyMutex.RUnlock()
	return len(fake.getSSHKeyArgsForCall)
}

func (fake *FakeSecurityManager) GetSSHKeyCalls(stub func(int) (datatypes.Security_Ssh_Key, error)) {
	fake.getSSHKeyMutex.Lock()
	defer fake.getSSHKeyMutex.Unlock()
	fake.GetSSHKeyStub = stub
}

func (fake *FakeSecurityManager) GetSSHKeyArgsForCall(i int) int {
	fake.getSSHKeyMutex.RLock()
	defer fake.getSSHKeyMutex.RUnlock()
	argsForCall := fake.getSSHKeyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSecurityManager) GetSSHKeyReturns(result1 datatypes.Security_Ssh_Key, result2 error) {
	fake.getSSHKeyMutex.Lock()
	defer fake.getSSHKeyMutex.Unlock()
	fake.GetSSHKeyStub = nil
	fake.getSSHKeyReturns = struct {
		result1 datatypes.Security_Ssh_Key
		result2 error
	}{result1, result2}
}

func (fake *FakeSecurityManager) GetSSHKeyReturnsOnCall(i int, result1 datatypes.Security_Ssh_Key, result2 error) {
	fake.getSSHKeyMutex.Lock()
	defer fake.getSSHKeyMutex.Unlock()
	fake.GetSSHKeyStub = nil
	if fake.getSSHKeyReturnsOnCall == nil {
		fake.getSSHKeyReturnsOnCall = make(map[int]struct {
			result1 datatypes.Security_Ssh_Key
			result2 error
		})
	}
	fake.getSSHKeyReturnsOnCall[i] = struct {
		result1 datatypes.Security_Ssh_Key
		result2 error
	}{result1, result2}
}

func (fake *FakeSecurityManager) GetSSHKeyIDsFromLabel(arg1 string) ([]int, error) {
	fake.getSSHKeyIDsFromLabelMutex.Lock()
	ret, specificReturn := fake.getSSHKeyIDsFromLabelReturnsOnCall[len(fake.getSSHKeyIDsFromLabelArgsForCall)]
	fake.getSSHKeyIDsFromLabelArgsForCall = append(fake.getSSHKeyIDsFromLabelArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetSSHKeyIDsFromLabelStub
	fakeReturns := fake.getSSHKeyIDsFromLabelReturns
	fake.recordInvocation("GetSSHKeyIDsFromLabel", []interface{}{arg1})
	fake.getSSHKeyIDsFromLabelMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSecurityManager) GetSSHKeyIDsFromLabelCallCount() int {
	fake.getSSHKeyIDsFromLabelMutex.RLock()
	defer fake.getSSHKeyIDsFromLabelMutex.RUnlock()
	return len(fake.getSSHKeyIDsFromLabelArgsForCall)
}

func (fake *FakeSecurityManager) GetSSHKeyIDsFromLabelCalls(stub func(string) ([]int, error)) {
	fake.getSSHKeyIDsFromLabelMutex.Lock()
	defer fake.getSSHKeyIDsFromLabelMutex.Unlock()
	fake.GetSSHKeyIDsFromLabelStub = stub
}

func (fake *FakeSecurityManager) GetSSHKeyIDsFromLabelArgsForCall(i int) string {
	fake.getSSHKeyIDsFromLabelMutex.RLock()
	defer fake.getSSHKeyIDsFromLabelMutex.RUnlock()
	argsForCall := fake.getSSHKeyIDsFromLabelArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSecurityManager) GetSSHKeyIDsFromLabelReturns(result1 []int, result2 error) {
	fake.getSSHKeyIDsFromLabelMutex.Lock()
	defer fake.getSSHKeyIDsFromLabelMutex.Unlock()
	fake.GetSSHKeyIDsFromLabelStub = nil
	fake.getSSHKeyIDsFromLabelReturns = struct {
		result1 []int
		result2 error
	}{result1, result2}
}

func (fake *FakeSecurityManager) GetSSHKeyIDsFromLabelReturnsOnCall(i int, result1 []int, result2 error) {
	fake.getSSHKeyIDsFromLabelMutex.Lock()
	defer fake.getSSHKeyIDsFromLabelMutex.Unlock()
	fake.GetSSHKeyIDsFromLabelStub = nil
	if fake.getSSHKeyIDsFromLabelReturnsOnCall == nil {
		fake.getSSHKeyIDsFromLabelReturnsOnCall = make(map[int]struct {
			result1 []int
			result2 error
		})
	}
	fake.getSSHKeyIDsFromLabelReturnsOnCall[i] = struct {
		result1 []int
		result2 error
	}{result1, result2}
}

func (fake *FakeSecurityManager) ListCertificates(arg1 string) ([]datatypes.Security_Certificate, error) {
	fake.listCertificatesMutex.Lock()
	ret, specificReturn := fake.listCertificatesReturnsOnCall[len(fake.listCertificatesArgsForCall)]
	fake.listCertificatesArgsForCall = append(fake.listCertificatesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ListCertificatesStub
	fakeReturns := fake.listCertificatesReturns
	fake.recordInvocation("ListCertificates", []interface{}{arg1})
	fake.listCertificatesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSecurityManager) ListCertificatesCallCount() int {
	fake.listCertificatesMutex.RLock()
	defer fake.listCertificatesMutex.RUnlock()
	return len(fake.listCertificatesArgsForCall)
}

func (fake *FakeSecurityManager) ListCertificatesCalls(stub func(string) ([]datatypes.Security_Certificate, error)) {
	fake.listCertificatesMutex.Lock()
	defer fake.listCertificatesMutex.Unlock()
	fake.ListCertificatesStub = stub
}

func (fake *FakeSecurityManager) ListCertificatesArgsForCall(i int) string {
	fake.listCertificatesMutex.RLock()
	defer fake.listCertificatesMutex.RUnlock()
	argsForCall := fake.listCertificatesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSecurityManager) ListCertificatesReturns(result1 []datatypes.Security_Certificate, result2 error) {
	fake.listCertificatesMutex.Lock()
	defer fake.listCertificatesMutex.Unlock()
	fake.ListCertificatesStub = nil
	fake.listCertificatesReturns = struct {
		result1 []datatypes.Security_Certificate
		result2 error
	}{result1, result2}
}

func (fake *FakeSecurityManager) ListCertificatesReturnsOnCall(i int, result1 []datatypes.Security_Certificate, result2 error) {
	fake.listCertificatesMutex.Lock()
	defer fake.listCertificatesMutex.Unlock()
	fake.ListCertificatesStub = nil
	if fake.listCertificatesReturnsOnCall == nil {
		fake.listCertificatesReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Security_Certificate
			result2 error
		})
	}
	fake.listCertificatesReturnsOnCall[i] = struct {
		result1 []datatypes.Security_Certificate
		result2 error
	}{result1, result2}
}

func (fake *FakeSecurityManager) ListSSHKeys(arg1 string) ([]datatypes.Security_Ssh_Key, error) {
	fake.listSSHKeysMutex.Lock()
	ret, specificReturn := fake.listSSHKeysReturnsOnCall[len(fake.listSSHKeysArgsForCall)]
	fake.listSSHKeysArgsForCall = append(fake.listSSHKeysArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ListSSHKeysStub
	fakeReturns := fake.listSSHKeysReturns
	fake.recordInvocation("ListSSHKeys", []interface{}{arg1})
	fake.listSSHKeysMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSecurityManager) ListSSHKeysCallCount() int {
	fake.listSSHKeysMutex.RLock()
	defer fake.listSSHKeysMutex.RUnlock()
	return len(fake.listSSHKeysArgsForCall)
}

func (fake *FakeSecurityManager) ListSSHKeysCalls(stub func(string) ([]datatypes.Security_Ssh_Key, error)) {
	fake.listSSHKeysMutex.Lock()
	defer fake.listSSHKeysMutex.Unlock()
	fake.ListSSHKeysStub = stub
}

func (fake *FakeSecurityManager) ListSSHKeysArgsForCall(i int) string {
	fake.listSSHKeysMutex.RLock()
	defer fake.listSSHKeysMutex.RUnlock()
	argsForCall := fake.listSSHKeysArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSecurityManager) ListSSHKeysReturns(result1 []datatypes.Security_Ssh_Key, result2 error) {
	fake.listSSHKeysMutex.Lock()
	defer fake.listSSHKeysMutex.Unlock()
	fake.ListSSHKeysStub = nil
	fake.listSSHKeysReturns = struct {
		result1 []datatypes.Security_Ssh_Key
		result2 error
	}{result1, result2}
}

func (fake *FakeSecurityManager) ListSSHKeysReturnsOnCall(i int, result1 []datatypes.Security_Ssh_Key, result2 error) {
	fake.listSSHKeysMutex.Lock()
	defer fake.listSSHKeysMutex.Unlock()
	fake.ListSSHKeysStub = nil
	if fake.listSSHKeysReturnsOnCall == nil {
		fake.listSSHKeysReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Security_Ssh_Key
			result2 error
		})
	}
	fake.listSSHKeysReturnsOnCall[i] = struct {
		result1 []datatypes.Security_Ssh_Key
		result2 error
	}{result1, result2}
}

func (fake *FakeSecurityManager) RemoveCertificate(arg1 int) error {
	fake.removeCertificateMutex.Lock()
	ret, specificReturn := fake.removeCertificateReturnsOnCall[len(fake.removeCertificateArgsForCall)]
	fake.removeCertificateArgsForCall = append(fake.removeCertificateArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.RemoveCertificateStub
	fakeReturns := fake.removeCertificateReturns
	fake.recordInvocation("RemoveCertificate", []interface{}{arg1})
	fake.removeCertificateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSecurityManager) RemoveCertificateCallCount() int {
	fake.removeCertificateMutex.RLock()
	defer fake.removeCertificateMutex.RUnlock()
	return len(fake.removeCertificateArgsForCall)
}

func (fake *FakeSecurityManager) RemoveCertificateCalls(stub func(int) error) {
	fake.removeCertificateMutex.Lock()
	defer fake.removeCertificateMutex.Unlock()
	fake.RemoveCertificateStub = stub
}

func (fake *FakeSecurityManager) RemoveCertificateArgsForCall(i int) int {
	fake.removeCertificateMutex.RLock()
	defer fake.removeCertificateMutex.RUnlock()
	argsForCall := fake.removeCertificateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSecurityManager) RemoveCertificateReturns(result1 error) {
	fake.removeCertificateMutex.Lock()
	defer fake.removeCertificateMutex.Unlock()
	fake.RemoveCertificateStub = nil
	fake.removeCertificateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSecurityManager) RemoveCertificateReturnsOnCall(i int, result1 error) {
	fake.removeCertificateMutex.Lock()
	defer fake.removeCertificateMutex.Unlock()
	fake.RemoveCertificateStub = nil
	if fake.removeCertificateReturnsOnCall == nil {
		fake.removeCertificateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeCertificateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSecurityManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSecurityManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ managers.SecurityManager = new(FakeSecurityManager)
