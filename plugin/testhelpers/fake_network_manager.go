// Code generated by counterfeiter. DO NOT EDIT.
package testhelpers

import (
	"sync"

	"github.com/softlayer/softlayer-go/datatypes"
	"github.ibm.com/SoftLayer/softlayer-cli/plugin/managers"
)

type FakeNetworkManager struct {
	AddGlobalIPStub        func(int, bool) (datatypes.Container_Product_Order_Receipt, error)
	addGlobalIPMutex       sync.RWMutex
	addGlobalIPArgsForCall []struct {
		arg1 int
		arg2 bool
	}
	addGlobalIPReturns struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	addGlobalIPReturnsOnCall map[int]struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	AddSecurityGroupRuleStub        func(int, string, int, string, string, int, int, string) (datatypes.Network_SecurityGroup_Rule, error)
	addSecurityGroupRuleMutex       sync.RWMutex
	addSecurityGroupRuleArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 int
		arg4 string
		arg5 string
		arg6 int
		arg7 int
		arg8 string
	}
	addSecurityGroupRuleReturns struct {
		result1 datatypes.Network_SecurityGroup_Rule
		result2 error
	}
	addSecurityGroupRuleReturnsOnCall map[int]struct {
		result1 datatypes.Network_SecurityGroup_Rule
		result2 error
	}
	AddSecurityGroupRulesStub        func(int, []datatypes.Network_SecurityGroup_Rule) ([]datatypes.Network_SecurityGroup_Rule, error)
	addSecurityGroupRulesMutex       sync.RWMutex
	addSecurityGroupRulesArgsForCall []struct {
		arg1 int
		arg2 []datatypes.Network_SecurityGroup_Rule
	}
	addSecurityGroupRulesReturns struct {
		result1 []datatypes.Network_SecurityGroup_Rule
		result2 error
	}
	addSecurityGroupRulesReturnsOnCall map[int]struct {
		result1 []datatypes.Network_SecurityGroup_Rule
		result2 error
	}
	AddSubnetStub        func(string, int, int, int, bool) (datatypes.Container_Product_Order_Receipt, error)
	addSubnetMutex       sync.RWMutex
	addSubnetArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
		arg4 int
		arg5 bool
	}
	addSubnetReturns struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	addSubnetReturnsOnCall map[int]struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	AddVlanStub        func(string, string, string, string) (datatypes.Container_Product_Order_Receipt, error)
	addVlanMutex       sync.RWMutex
	addVlanArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}
	addVlanReturns struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	addVlanReturnsOnCall map[int]struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	AssignGlobalIPStub        func(int, string) (bool, error)
	assignGlobalIPMutex       sync.RWMutex
	assignGlobalIPArgsForCall []struct {
		arg1 int
		arg2 string
	}
	assignGlobalIPReturns struct {
		result1 bool
		result2 error
	}
	assignGlobalIPReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	AttachSecurityGroupComponentStub        func(int, int) error
	attachSecurityGroupComponentMutex       sync.RWMutex
	attachSecurityGroupComponentArgsForCall []struct {
		arg1 int
		arg2 int
	}
	attachSecurityGroupComponentReturns struct {
		result1 error
	}
	attachSecurityGroupComponentReturnsOnCall map[int]struct {
		result1 error
	}
	AttachSecurityGroupComponentsStub        func(int, []int) error
	attachSecurityGroupComponentsMutex       sync.RWMutex
	attachSecurityGroupComponentsArgsForCall []struct {
		arg1 int
		arg2 []int
	}
	attachSecurityGroupComponentsReturns struct {
		result1 error
	}
	attachSecurityGroupComponentsReturnsOnCall map[int]struct {
		result1 error
	}
	CancelGlobalIPStub        func(int) error
	cancelGlobalIPMutex       sync.RWMutex
	cancelGlobalIPArgsForCall []struct {
		arg1 int
	}
	cancelGlobalIPReturns struct {
		result1 error
	}
	cancelGlobalIPReturnsOnCall map[int]struct {
		result1 error
	}
	CancelSubnetStub        func(int) error
	cancelSubnetMutex       sync.RWMutex
	cancelSubnetArgsForCall []struct {
		arg1 int
	}
	cancelSubnetReturns struct {
		result1 error
	}
	cancelSubnetReturnsOnCall map[int]struct {
		result1 error
	}
	CancelVLANStub        func(int) error
	cancelVLANMutex       sync.RWMutex
	cancelVLANArgsForCall []struct {
		arg1 int
	}
	cancelVLANReturns struct {
		result1 error
	}
	cancelVLANReturnsOnCall map[int]struct {
		result1 error
	}
	ClearRouteStub        func(int) (bool, error)
	clearRouteMutex       sync.RWMutex
	clearRouteArgsForCall []struct {
		arg1 int
	}
	clearRouteReturns struct {
		result1 bool
		result2 error
	}
	clearRouteReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CreateSecurityGroupStub        func(string, string) (datatypes.Network_SecurityGroup, error)
	createSecurityGroupMutex       sync.RWMutex
	createSecurityGroupArgsForCall []struct {
		arg1 string
		arg2 string
	}
	createSecurityGroupReturns struct {
		result1 datatypes.Network_SecurityGroup
		result2 error
	}
	createSecurityGroupReturnsOnCall map[int]struct {
		result1 datatypes.Network_SecurityGroup
		result2 error
	}
	DeleteSecurityGroupStub        func(int) error
	deleteSecurityGroupMutex       sync.RWMutex
	deleteSecurityGroupArgsForCall []struct {
		arg1 int
	}
	deleteSecurityGroupReturns struct {
		result1 error
	}
	deleteSecurityGroupReturnsOnCall map[int]struct {
		result1 error
	}
	DetachSecurityGroupComponentStub        func(int, int) error
	detachSecurityGroupComponentMutex       sync.RWMutex
	detachSecurityGroupComponentArgsForCall []struct {
		arg1 int
		arg2 int
	}
	detachSecurityGroupComponentReturns struct {
		result1 error
	}
	detachSecurityGroupComponentReturnsOnCall map[int]struct {
		result1 error
	}
	DetachSecurityGroupComponentsStub        func(int, []int) error
	detachSecurityGroupComponentsMutex       sync.RWMutex
	detachSecurityGroupComponentsArgsForCall []struct {
		arg1 int
		arg2 []int
	}
	detachSecurityGroupComponentsReturns struct {
		result1 error
	}
	detachSecurityGroupComponentsReturnsOnCall map[int]struct {
		result1 error
	}
	EditSecurityGroupStub        func(int, string, string) error
	editSecurityGroupMutex       sync.RWMutex
	editSecurityGroupArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 string
	}
	editSecurityGroupReturns struct {
		result1 error
	}
	editSecurityGroupReturnsOnCall map[int]struct {
		result1 error
	}
	EditSecurityGroupRuleStub        func(int, int, string, int, string, string, int, int, string) error
	editSecurityGroupRuleMutex       sync.RWMutex
	editSecurityGroupRuleArgsForCall []struct {
		arg1 int
		arg2 int
		arg3 string
		arg4 int
		arg5 string
		arg6 string
		arg7 int
		arg8 int
		arg9 string
	}
	editSecurityGroupRuleReturns struct {
		result1 error
	}
	editSecurityGroupRuleReturnsOnCall map[int]struct {
		result1 error
	}
	EditSecurityGroupRulesStub        func(int, []datatypes.Network_SecurityGroup_Rule) error
	editSecurityGroupRulesMutex       sync.RWMutex
	editSecurityGroupRulesArgsForCall []struct {
		arg1 int
		arg2 []datatypes.Network_SecurityGroup_Rule
	}
	editSecurityGroupRulesReturns struct {
		result1 error
	}
	editSecurityGroupRulesReturnsOnCall map[int]struct {
		result1 error
	}
	EditSubnetIpAddressStub        func(int, datatypes.Network_Subnet_IpAddress) (bool, error)
	editSubnetIpAddressMutex       sync.RWMutex
	editSubnetIpAddressArgsForCall []struct {
		arg1 int
		arg2 datatypes.Network_Subnet_IpAddress
	}
	editSubnetIpAddressReturns struct {
		result1 bool
		result2 error
	}
	editSubnetIpAddressReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	EditVlanStub        func(int, string) error
	editVlanMutex       sync.RWMutex
	editVlanArgsForCall []struct {
		arg1 int
		arg2 string
	}
	editVlanReturns struct {
		result1 error
	}
	editVlanReturnsOnCall map[int]struct {
		result1 error
	}
	GetCancelFailureReasonsStub        func(int) []string
	getCancelFailureReasonsMutex       sync.RWMutex
	getCancelFailureReasonsArgsForCall []struct {
		arg1 int
	}
	getCancelFailureReasonsReturns struct {
		result1 []string
	}
	getCancelFailureReasonsReturnsOnCall map[int]struct {
		result1 []string
	}
	GetIpByAddressStub        func(string) (datatypes.Network_Subnet_IpAddress, error)
	getIpByAddressMutex       sync.RWMutex
	getIpByAddressArgsForCall []struct {
		arg1 string
	}
	getIpByAddressReturns struct {
		result1 datatypes.Network_Subnet_IpAddress
		result2 error
	}
	getIpByAddressReturnsOnCall map[int]struct {
		result1 datatypes.Network_Subnet_IpAddress
		result2 error
	}
	GetPodsStub        func(string, bool) ([]datatypes.Network_Pod, error)
	getPodsMutex       sync.RWMutex
	getPodsArgsForCall []struct {
		arg1 string
		arg2 bool
	}
	getPodsReturns struct {
		result1 []datatypes.Network_Pod
		result2 error
	}
	getPodsReturnsOnCall map[int]struct {
		result1 []datatypes.Network_Pod
		result2 error
	}
	GetRoutersStub        func(string) ([]datatypes.Hardware, error)
	getRoutersMutex       sync.RWMutex
	getRoutersArgsForCall []struct {
		arg1 string
	}
	getRoutersReturns struct {
		result1 []datatypes.Hardware
		result2 error
	}
	getRoutersReturnsOnCall map[int]struct {
		result1 []datatypes.Hardware
		result2 error
	}
	GetSecurityGroupStub        func(int, string) (datatypes.Network_SecurityGroup, error)
	getSecurityGroupMutex       sync.RWMutex
	getSecurityGroupArgsForCall []struct {
		arg1 int
		arg2 string
	}
	getSecurityGroupReturns struct {
		result1 datatypes.Network_SecurityGroup
		result2 error
	}
	getSecurityGroupReturnsOnCall map[int]struct {
		result1 datatypes.Network_SecurityGroup
		result2 error
	}
	GetSubnetStub        func(int, string) (datatypes.Network_Subnet, error)
	getSubnetMutex       sync.RWMutex
	getSubnetArgsForCall []struct {
		arg1 int
		arg2 string
	}
	getSubnetReturns struct {
		result1 datatypes.Network_Subnet
		result2 error
	}
	getSubnetReturnsOnCall map[int]struct {
		result1 datatypes.Network_Subnet
		result2 error
	}
	GetVlanStub        func(int, string) (datatypes.Network_Vlan, error)
	getVlanMutex       sync.RWMutex
	getVlanArgsForCall []struct {
		arg1 int
		arg2 string
	}
	getVlanReturns struct {
		result1 datatypes.Network_Vlan
		result2 error
	}
	getVlanReturnsOnCall map[int]struct {
		result1 datatypes.Network_Vlan
		result2 error
	}
	IPLookupStub        func(string) (datatypes.Network_Subnet_IpAddress, error)
	iPLookupMutex       sync.RWMutex
	iPLookupArgsForCall []struct {
		arg1 string
	}
	iPLookupReturns struct {
		result1 datatypes.Network_Subnet_IpAddress
		result2 error
	}
	iPLookupReturnsOnCall map[int]struct {
		result1 datatypes.Network_Subnet_IpAddress
		result2 error
	}
	ListDatacentersStub        func() (map[int]string, error)
	listDatacentersMutex       sync.RWMutex
	listDatacentersArgsForCall []struct {
	}
	listDatacentersReturns struct {
		result1 map[int]string
		result2 error
	}
	listDatacentersReturnsOnCall map[int]struct {
		result1 map[int]string
		result2 error
	}
	ListGlobalIPsStub        func(int, int) ([]datatypes.Network_Subnet_IpAddress_Global, error)
	listGlobalIPsMutex       sync.RWMutex
	listGlobalIPsArgsForCall []struct {
		arg1 int
		arg2 int
	}
	listGlobalIPsReturns struct {
		result1 []datatypes.Network_Subnet_IpAddress_Global
		result2 error
	}
	listGlobalIPsReturnsOnCall map[int]struct {
		result1 []datatypes.Network_Subnet_IpAddress_Global
		result2 error
	}
	ListRoutersStub        func(int, string) ([]string, error)
	listRoutersMutex       sync.RWMutex
	listRoutersArgsForCall []struct {
		arg1 int
		arg2 string
	}
	listRoutersReturns struct {
		result1 []string
		result2 error
	}
	listRoutersReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	ListSecurityGroupRulesStub        func(int) ([]datatypes.Network_SecurityGroup_Rule, error)
	listSecurityGroupRulesMutex       sync.RWMutex
	listSecurityGroupRulesArgsForCall []struct {
		arg1 int
	}
	listSecurityGroupRulesReturns struct {
		result1 []datatypes.Network_SecurityGroup_Rule
		result2 error
	}
	listSecurityGroupRulesReturnsOnCall map[int]struct {
		result1 []datatypes.Network_SecurityGroup_Rule
		result2 error
	}
	ListSecurityGroupsStub        func() ([]datatypes.Network_SecurityGroup, error)
	listSecurityGroupsMutex       sync.RWMutex
	listSecurityGroupsArgsForCall []struct {
	}
	listSecurityGroupsReturns struct {
		result1 []datatypes.Network_SecurityGroup
		result2 error
	}
	listSecurityGroupsReturnsOnCall map[int]struct {
		result1 []datatypes.Network_SecurityGroup
		result2 error
	}
	ListSubnetsStub        func(string, string, int, string, string, int, string) ([]datatypes.Network_Subnet, error)
	listSubnetsMutex       sync.RWMutex
	listSubnetsArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 int
		arg4 string
		arg5 string
		arg6 int
		arg7 string
	}
	listSubnetsReturns struct {
		result1 []datatypes.Network_Subnet
		result2 error
	}
	listSubnetsReturnsOnCall map[int]struct {
		result1 []datatypes.Network_Subnet
		result2 error
	}
	ListVlansStub        func(string, int, string, int, string) ([]datatypes.Network_Vlan, error)
	listVlansMutex       sync.RWMutex
	listVlansArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 string
		arg4 int
		arg5 string
	}
	listVlansReturns struct {
		result1 []datatypes.Network_Vlan
		result2 error
	}
	listVlansReturnsOnCall map[int]struct {
		result1 []datatypes.Network_Vlan
		result2 error
	}
	RemoveSecurityGroupRuleStub        func(int, int) error
	removeSecurityGroupRuleMutex       sync.RWMutex
	removeSecurityGroupRuleArgsForCall []struct {
		arg1 int
		arg2 int
	}
	removeSecurityGroupRuleReturns struct {
		result1 error
	}
	removeSecurityGroupRuleReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveSecurityGroupRulesStub        func(int, []int) error
	removeSecurityGroupRulesMutex       sync.RWMutex
	removeSecurityGroupRulesArgsForCall []struct {
		arg1 int
		arg2 []int
	}
	removeSecurityGroupRulesReturns struct {
		result1 error
	}
	removeSecurityGroupRulesReturnsOnCall map[int]struct {
		result1 error
	}
	RouteStub        func(int, string, string) (bool, error)
	routeMutex       sync.RWMutex
	routeArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 string
	}
	routeReturns struct {
		result1 bool
		result2 error
	}
	routeReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	SetSubnetNoteStub        func(int, string) (bool, error)
	setSubnetNoteMutex       sync.RWMutex
	setSubnetNoteArgsForCall []struct {
		arg1 int
		arg2 string
	}
	setSubnetNoteReturns struct {
		result1 bool
		result2 error
	}
	setSubnetNoteReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	SetSubnetTagsStub        func(int, string) (bool, error)
	setSubnetTagsMutex       sync.RWMutex
	setSubnetTagsArgsForCall []struct {
		arg1 int
		arg2 string
	}
	setSubnetTagsReturns struct {
		result1 bool
		result2 error
	}
	setSubnetTagsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	UnassignGlobalIPStub        func(int) (bool, error)
	unassignGlobalIPMutex       sync.RWMutex
	unassignGlobalIPArgsForCall []struct {
		arg1 int
	}
	unassignGlobalIPReturns struct {
		result1 bool
		result2 error
	}
	unassignGlobalIPReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeNetworkManager) AddGlobalIP(arg1 int, arg2 bool) (datatypes.Container_Product_Order_Receipt, error) {
	fake.addGlobalIPMutex.Lock()
	ret, specificReturn := fake.addGlobalIPReturnsOnCall[len(fake.addGlobalIPArgsForCall)]
	fake.addGlobalIPArgsForCall = append(fake.addGlobalIPArgsForCall, struct {
		arg1 int
		arg2 bool
	}{arg1, arg2})
	stub := fake.AddGlobalIPStub
	fakeReturns := fake.addGlobalIPReturns
	fake.recordInvocation("AddGlobalIP", []interface{}{arg1, arg2})
	fake.addGlobalIPMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) AddGlobalIPCallCount() int {
	fake.addGlobalIPMutex.RLock()
	defer fake.addGlobalIPMutex.RUnlock()
	return len(fake.addGlobalIPArgsForCall)
}

func (fake *FakeNetworkManager) AddGlobalIPCalls(stub func(int, bool) (datatypes.Container_Product_Order_Receipt, error)) {
	fake.addGlobalIPMutex.Lock()
	defer fake.addGlobalIPMutex.Unlock()
	fake.AddGlobalIPStub = stub
}

func (fake *FakeNetworkManager) AddGlobalIPArgsForCall(i int) (int, bool) {
	fake.addGlobalIPMutex.RLock()
	defer fake.addGlobalIPMutex.RUnlock()
	argsForCall := fake.addGlobalIPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) AddGlobalIPReturns(result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.addGlobalIPMutex.Lock()
	defer fake.addGlobalIPMutex.Unlock()
	fake.AddGlobalIPStub = nil
	fake.addGlobalIPReturns = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) AddGlobalIPReturnsOnCall(i int, result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.addGlobalIPMutex.Lock()
	defer fake.addGlobalIPMutex.Unlock()
	fake.AddGlobalIPStub = nil
	if fake.addGlobalIPReturnsOnCall == nil {
		fake.addGlobalIPReturnsOnCall = make(map[int]struct {
			result1 datatypes.Container_Product_Order_Receipt
			result2 error
		})
	}
	fake.addGlobalIPReturnsOnCall[i] = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) AddSecurityGroupRule(arg1 int, arg2 string, arg3 int, arg4 string, arg5 string, arg6 int, arg7 int, arg8 string) (datatypes.Network_SecurityGroup_Rule, error) {
	fake.addSecurityGroupRuleMutex.Lock()
	ret, specificReturn := fake.addSecurityGroupRuleReturnsOnCall[len(fake.addSecurityGroupRuleArgsForCall)]
	fake.addSecurityGroupRuleArgsForCall = append(fake.addSecurityGroupRuleArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 int
		arg4 string
		arg5 string
		arg6 int
		arg7 int
		arg8 string
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8})
	stub := fake.AddSecurityGroupRuleStub
	fakeReturns := fake.addSecurityGroupRuleReturns
	fake.recordInvocation("AddSecurityGroupRule", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8})
	fake.addSecurityGroupRuleMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) AddSecurityGroupRuleCallCount() int {
	fake.addSecurityGroupRuleMutex.RLock()
	defer fake.addSecurityGroupRuleMutex.RUnlock()
	return len(fake.addSecurityGroupRuleArgsForCall)
}

func (fake *FakeNetworkManager) AddSecurityGroupRuleCalls(stub func(int, string, int, string, string, int, int, string) (datatypes.Network_SecurityGroup_Rule, error)) {
	fake.addSecurityGroupRuleMutex.Lock()
	defer fake.addSecurityGroupRuleMutex.Unlock()
	fake.AddSecurityGroupRuleStub = stub
}

func (fake *FakeNetworkManager) AddSecurityGroupRuleArgsForCall(i int) (int, string, int, string, string, int, int, string) {
	fake.addSecurityGroupRuleMutex.RLock()
	defer fake.addSecurityGroupRuleMutex.RUnlock()
	argsForCall := fake.addSecurityGroupRuleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7, argsForCall.arg8
}

func (fake *FakeNetworkManager) AddSecurityGroupRuleReturns(result1 datatypes.Network_SecurityGroup_Rule, result2 error) {
	fake.addSecurityGroupRuleMutex.Lock()
	defer fake.addSecurityGroupRuleMutex.Unlock()
	fake.AddSecurityGroupRuleStub = nil
	fake.addSecurityGroupRuleReturns = struct {
		result1 datatypes.Network_SecurityGroup_Rule
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) AddSecurityGroupRuleReturnsOnCall(i int, result1 datatypes.Network_SecurityGroup_Rule, result2 error) {
	fake.addSecurityGroupRuleMutex.Lock()
	defer fake.addSecurityGroupRuleMutex.Unlock()
	fake.AddSecurityGroupRuleStub = nil
	if fake.addSecurityGroupRuleReturnsOnCall == nil {
		fake.addSecurityGroupRuleReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_SecurityGroup_Rule
			result2 error
		})
	}
	fake.addSecurityGroupRuleReturnsOnCall[i] = struct {
		result1 datatypes.Network_SecurityGroup_Rule
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) AddSecurityGroupRules(arg1 int, arg2 []datatypes.Network_SecurityGroup_Rule) ([]datatypes.Network_SecurityGroup_Rule, error) {
	var arg2Copy []datatypes.Network_SecurityGroup_Rule
	if arg2 != nil {
		arg2Copy = make([]datatypes.Network_SecurityGroup_Rule, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.addSecurityGroupRulesMutex.Lock()
	ret, specificReturn := fake.addSecurityGroupRulesReturnsOnCall[len(fake.addSecurityGroupRulesArgsForCall)]
	fake.addSecurityGroupRulesArgsForCall = append(fake.addSecurityGroupRulesArgsForCall, struct {
		arg1 int
		arg2 []datatypes.Network_SecurityGroup_Rule
	}{arg1, arg2Copy})
	stub := fake.AddSecurityGroupRulesStub
	fakeReturns := fake.addSecurityGroupRulesReturns
	fake.recordInvocation("AddSecurityGroupRules", []interface{}{arg1, arg2Copy})
	fake.addSecurityGroupRulesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) AddSecurityGroupRulesCallCount() int {
	fake.addSecurityGroupRulesMutex.RLock()
	defer fake.addSecurityGroupRulesMutex.RUnlock()
	return len(fake.addSecurityGroupRulesArgsForCall)
}

func (fake *FakeNetworkManager) AddSecurityGroupRulesCalls(stub func(int, []datatypes.Network_SecurityGroup_Rule) ([]datatypes.Network_SecurityGroup_Rule, error)) {
	fake.addSecurityGroupRulesMutex.Lock()
	defer fake.addSecurityGroupRulesMutex.Unlock()
	fake.AddSecurityGroupRulesStub = stub
}

func (fake *FakeNetworkManager) AddSecurityGroupRulesArgsForCall(i int) (int, []datatypes.Network_SecurityGroup_Rule) {
	fake.addSecurityGroupRulesMutex.RLock()
	defer fake.addSecurityGroupRulesMutex.RUnlock()
	argsForCall := fake.addSecurityGroupRulesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) AddSecurityGroupRulesReturns(result1 []datatypes.Network_SecurityGroup_Rule, result2 error) {
	fake.addSecurityGroupRulesMutex.Lock()
	defer fake.addSecurityGroupRulesMutex.Unlock()
	fake.AddSecurityGroupRulesStub = nil
	fake.addSecurityGroupRulesReturns = struct {
		result1 []datatypes.Network_SecurityGroup_Rule
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) AddSecurityGroupRulesReturnsOnCall(i int, result1 []datatypes.Network_SecurityGroup_Rule, result2 error) {
	fake.addSecurityGroupRulesMutex.Lock()
	defer fake.addSecurityGroupRulesMutex.Unlock()
	fake.AddSecurityGroupRulesStub = nil
	if fake.addSecurityGroupRulesReturnsOnCall == nil {
		fake.addSecurityGroupRulesReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Network_SecurityGroup_Rule
			result2 error
		})
	}
	fake.addSecurityGroupRulesReturnsOnCall[i] = struct {
		result1 []datatypes.Network_SecurityGroup_Rule
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) AddSubnet(arg1 string, arg2 int, arg3 int, arg4 int, arg5 bool) (datatypes.Container_Product_Order_Receipt, error) {
	fake.addSubnetMutex.Lock()
	ret, specificReturn := fake.addSubnetReturnsOnCall[len(fake.addSubnetArgsForCall)]
	fake.addSubnetArgsForCall = append(fake.addSubnetArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
		arg4 int
		arg5 bool
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.AddSubnetStub
	fakeReturns := fake.addSubnetReturns
	fake.recordInvocation("AddSubnet", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.addSubnetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) AddSubnetCallCount() int {
	fake.addSubnetMutex.RLock()
	defer fake.addSubnetMutex.RUnlock()
	return len(fake.addSubnetArgsForCall)
}

func (fake *FakeNetworkManager) AddSubnetCalls(stub func(string, int, int, int, bool) (datatypes.Container_Product_Order_Receipt, error)) {
	fake.addSubnetMutex.Lock()
	defer fake.addSubnetMutex.Unlock()
	fake.AddSubnetStub = stub
}

func (fake *FakeNetworkManager) AddSubnetArgsForCall(i int) (string, int, int, int, bool) {
	fake.addSubnetMutex.RLock()
	defer fake.addSubnetMutex.RUnlock()
	argsForCall := fake.addSubnetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeNetworkManager) AddSubnetReturns(result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.addSubnetMutex.Lock()
	defer fake.addSubnetMutex.Unlock()
	fake.AddSubnetStub = nil
	fake.addSubnetReturns = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) AddSubnetReturnsOnCall(i int, result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.addSubnetMutex.Lock()
	defer fake.addSubnetMutex.Unlock()
	fake.AddSubnetStub = nil
	if fake.addSubnetReturnsOnCall == nil {
		fake.addSubnetReturnsOnCall = make(map[int]struct {
			result1 datatypes.Container_Product_Order_Receipt
			result2 error
		})
	}
	fake.addSubnetReturnsOnCall[i] = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) AddVlan(arg1 string, arg2 string, arg3 string, arg4 string) (datatypes.Container_Product_Order_Receipt, error) {
	fake.addVlanMutex.Lock()
	ret, specificReturn := fake.addVlanReturnsOnCall[len(fake.addVlanArgsForCall)]
	fake.addVlanArgsForCall = append(fake.addVlanArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.AddVlanStub
	fakeReturns := fake.addVlanReturns
	fake.recordInvocation("AddVlan", []interface{}{arg1, arg2, arg3, arg4})
	fake.addVlanMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) AddVlanCallCount() int {
	fake.addVlanMutex.RLock()
	defer fake.addVlanMutex.RUnlock()
	return len(fake.addVlanArgsForCall)
}

func (fake *FakeNetworkManager) AddVlanCalls(stub func(string, string, string, string) (datatypes.Container_Product_Order_Receipt, error)) {
	fake.addVlanMutex.Lock()
	defer fake.addVlanMutex.Unlock()
	fake.AddVlanStub = stub
}

func (fake *FakeNetworkManager) AddVlanArgsForCall(i int) (string, string, string, string) {
	fake.addVlanMutex.RLock()
	defer fake.addVlanMutex.RUnlock()
	argsForCall := fake.addVlanArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeNetworkManager) AddVlanReturns(result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.addVlanMutex.Lock()
	defer fake.addVlanMutex.Unlock()
	fake.AddVlanStub = nil
	fake.addVlanReturns = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) AddVlanReturnsOnCall(i int, result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.addVlanMutex.Lock()
	defer fake.addVlanMutex.Unlock()
	fake.AddVlanStub = nil
	if fake.addVlanReturnsOnCall == nil {
		fake.addVlanReturnsOnCall = make(map[int]struct {
			result1 datatypes.Container_Product_Order_Receipt
			result2 error
		})
	}
	fake.addVlanReturnsOnCall[i] = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) AssignGlobalIP(arg1 int, arg2 string) (bool, error) {
	fake.assignGlobalIPMutex.Lock()
	ret, specificReturn := fake.assignGlobalIPReturnsOnCall[len(fake.assignGlobalIPArgsForCall)]
	fake.assignGlobalIPArgsForCall = append(fake.assignGlobalIPArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.AssignGlobalIPStub
	fakeReturns := fake.assignGlobalIPReturns
	fake.recordInvocation("AssignGlobalIP", []interface{}{arg1, arg2})
	fake.assignGlobalIPMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) AssignGlobalIPCallCount() int {
	fake.assignGlobalIPMutex.RLock()
	defer fake.assignGlobalIPMutex.RUnlock()
	return len(fake.assignGlobalIPArgsForCall)
}

func (fake *FakeNetworkManager) AssignGlobalIPCalls(stub func(int, string) (bool, error)) {
	fake.assignGlobalIPMutex.Lock()
	defer fake.assignGlobalIPMutex.Unlock()
	fake.AssignGlobalIPStub = stub
}

func (fake *FakeNetworkManager) AssignGlobalIPArgsForCall(i int) (int, string) {
	fake.assignGlobalIPMutex.RLock()
	defer fake.assignGlobalIPMutex.RUnlock()
	argsForCall := fake.assignGlobalIPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) AssignGlobalIPReturns(result1 bool, result2 error) {
	fake.assignGlobalIPMutex.Lock()
	defer fake.assignGlobalIPMutex.Unlock()
	fake.AssignGlobalIPStub = nil
	fake.assignGlobalIPReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) AssignGlobalIPReturnsOnCall(i int, result1 bool, result2 error) {
	fake.assignGlobalIPMutex.Lock()
	defer fake.assignGlobalIPMutex.Unlock()
	fake.AssignGlobalIPStub = nil
	if fake.assignGlobalIPReturnsOnCall == nil {
		fake.assignGlobalIPReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.assignGlobalIPReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) AttachSecurityGroupComponent(arg1 int, arg2 int) error {
	fake.attachSecurityGroupComponentMutex.Lock()
	ret, specificReturn := fake.attachSecurityGroupComponentReturnsOnCall[len(fake.attachSecurityGroupComponentArgsForCall)]
	fake.attachSecurityGroupComponentArgsForCall = append(fake.attachSecurityGroupComponentArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.AttachSecurityGroupComponentStub
	fakeReturns := fake.attachSecurityGroupComponentReturns
	fake.recordInvocation("AttachSecurityGroupComponent", []interface{}{arg1, arg2})
	fake.attachSecurityGroupComponentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNetworkManager) AttachSecurityGroupComponentCallCount() int {
	fake.attachSecurityGroupComponentMutex.RLock()
	defer fake.attachSecurityGroupComponentMutex.RUnlock()
	return len(fake.attachSecurityGroupComponentArgsForCall)
}

func (fake *FakeNetworkManager) AttachSecurityGroupComponentCalls(stub func(int, int) error) {
	fake.attachSecurityGroupComponentMutex.Lock()
	defer fake.attachSecurityGroupComponentMutex.Unlock()
	fake.AttachSecurityGroupComponentStub = stub
}

func (fake *FakeNetworkManager) AttachSecurityGroupComponentArgsForCall(i int) (int, int) {
	fake.attachSecurityGroupComponentMutex.RLock()
	defer fake.attachSecurityGroupComponentMutex.RUnlock()
	argsForCall := fake.attachSecurityGroupComponentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) AttachSecurityGroupComponentReturns(result1 error) {
	fake.attachSecurityGroupComponentMutex.Lock()
	defer fake.attachSecurityGroupComponentMutex.Unlock()
	fake.AttachSecurityGroupComponentStub = nil
	fake.attachSecurityGroupComponentReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) AttachSecurityGroupComponentReturnsOnCall(i int, result1 error) {
	fake.attachSecurityGroupComponentMutex.Lock()
	defer fake.attachSecurityGroupComponentMutex.Unlock()
	fake.AttachSecurityGroupComponentStub = nil
	if fake.attachSecurityGroupComponentReturnsOnCall == nil {
		fake.attachSecurityGroupComponentReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.attachSecurityGroupComponentReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) AttachSecurityGroupComponents(arg1 int, arg2 []int) error {
	var arg2Copy []int
	if arg2 != nil {
		arg2Copy = make([]int, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.attachSecurityGroupComponentsMutex.Lock()
	ret, specificReturn := fake.attachSecurityGroupComponentsReturnsOnCall[len(fake.attachSecurityGroupComponentsArgsForCall)]
	fake.attachSecurityGroupComponentsArgsForCall = append(fake.attachSecurityGroupComponentsArgsForCall, struct {
		arg1 int
		arg2 []int
	}{arg1, arg2Copy})
	stub := fake.AttachSecurityGroupComponentsStub
	fakeReturns := fake.attachSecurityGroupComponentsReturns
	fake.recordInvocation("AttachSecurityGroupComponents", []interface{}{arg1, arg2Copy})
	fake.attachSecurityGroupComponentsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNetworkManager) AttachSecurityGroupComponentsCallCount() int {
	fake.attachSecurityGroupComponentsMutex.RLock()
	defer fake.attachSecurityGroupComponentsMutex.RUnlock()
	return len(fake.attachSecurityGroupComponentsArgsForCall)
}

func (fake *FakeNetworkManager) AttachSecurityGroupComponentsCalls(stub func(int, []int) error) {
	fake.attachSecurityGroupComponentsMutex.Lock()
	defer fake.attachSecurityGroupComponentsMutex.Unlock()
	fake.AttachSecurityGroupComponentsStub = stub
}

func (fake *FakeNetworkManager) AttachSecurityGroupComponentsArgsForCall(i int) (int, []int) {
	fake.attachSecurityGroupComponentsMutex.RLock()
	defer fake.attachSecurityGroupComponentsMutex.RUnlock()
	argsForCall := fake.attachSecurityGroupComponentsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) AttachSecurityGroupComponentsReturns(result1 error) {
	fake.attachSecurityGroupComponentsMutex.Lock()
	defer fake.attachSecurityGroupComponentsMutex.Unlock()
	fake.AttachSecurityGroupComponentsStub = nil
	fake.attachSecurityGroupComponentsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) AttachSecurityGroupComponentsReturnsOnCall(i int, result1 error) {
	fake.attachSecurityGroupComponentsMutex.Lock()
	defer fake.attachSecurityGroupComponentsMutex.Unlock()
	fake.AttachSecurityGroupComponentsStub = nil
	if fake.attachSecurityGroupComponentsReturnsOnCall == nil {
		fake.attachSecurityGroupComponentsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.attachSecurityGroupComponentsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) CancelGlobalIP(arg1 int) error {
	fake.cancelGlobalIPMutex.Lock()
	ret, specificReturn := fake.cancelGlobalIPReturnsOnCall[len(fake.cancelGlobalIPArgsForCall)]
	fake.cancelGlobalIPArgsForCall = append(fake.cancelGlobalIPArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.CancelGlobalIPStub
	fakeReturns := fake.cancelGlobalIPReturns
	fake.recordInvocation("CancelGlobalIP", []interface{}{arg1})
	fake.cancelGlobalIPMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNetworkManager) CancelGlobalIPCallCount() int {
	fake.cancelGlobalIPMutex.RLock()
	defer fake.cancelGlobalIPMutex.RUnlock()
	return len(fake.cancelGlobalIPArgsForCall)
}

func (fake *FakeNetworkManager) CancelGlobalIPCalls(stub func(int) error) {
	fake.cancelGlobalIPMutex.Lock()
	defer fake.cancelGlobalIPMutex.Unlock()
	fake.CancelGlobalIPStub = stub
}

func (fake *FakeNetworkManager) CancelGlobalIPArgsForCall(i int) int {
	fake.cancelGlobalIPMutex.RLock()
	defer fake.cancelGlobalIPMutex.RUnlock()
	argsForCall := fake.cancelGlobalIPArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNetworkManager) CancelGlobalIPReturns(result1 error) {
	fake.cancelGlobalIPMutex.Lock()
	defer fake.cancelGlobalIPMutex.Unlock()
	fake.CancelGlobalIPStub = nil
	fake.cancelGlobalIPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) CancelGlobalIPReturnsOnCall(i int, result1 error) {
	fake.cancelGlobalIPMutex.Lock()
	defer fake.cancelGlobalIPMutex.Unlock()
	fake.CancelGlobalIPStub = nil
	if fake.cancelGlobalIPReturnsOnCall == nil {
		fake.cancelGlobalIPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelGlobalIPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) CancelSubnet(arg1 int) error {
	fake.cancelSubnetMutex.Lock()
	ret, specificReturn := fake.cancelSubnetReturnsOnCall[len(fake.cancelSubnetArgsForCall)]
	fake.cancelSubnetArgsForCall = append(fake.cancelSubnetArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.CancelSubnetStub
	fakeReturns := fake.cancelSubnetReturns
	fake.recordInvocation("CancelSubnet", []interface{}{arg1})
	fake.cancelSubnetMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNetworkManager) CancelSubnetCallCount() int {
	fake.cancelSubnetMutex.RLock()
	defer fake.cancelSubnetMutex.RUnlock()
	return len(fake.cancelSubnetArgsForCall)
}

func (fake *FakeNetworkManager) CancelSubnetCalls(stub func(int) error) {
	fake.cancelSubnetMutex.Lock()
	defer fake.cancelSubnetMutex.Unlock()
	fake.CancelSubnetStub = stub
}

func (fake *FakeNetworkManager) CancelSubnetArgsForCall(i int) int {
	fake.cancelSubnetMutex.RLock()
	defer fake.cancelSubnetMutex.RUnlock()
	argsForCall := fake.cancelSubnetArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNetworkManager) CancelSubnetReturns(result1 error) {
	fake.cancelSubnetMutex.Lock()
	defer fake.cancelSubnetMutex.Unlock()
	fake.CancelSubnetStub = nil
	fake.cancelSubnetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) CancelSubnetReturnsOnCall(i int, result1 error) {
	fake.cancelSubnetMutex.Lock()
	defer fake.cancelSubnetMutex.Unlock()
	fake.CancelSubnetStub = nil
	if fake.cancelSubnetReturnsOnCall == nil {
		fake.cancelSubnetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelSubnetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) CancelVLAN(arg1 int) error {
	fake.cancelVLANMutex.Lock()
	ret, specificReturn := fake.cancelVLANReturnsOnCall[len(fake.cancelVLANArgsForCall)]
	fake.cancelVLANArgsForCall = append(fake.cancelVLANArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.CancelVLANStub
	fakeReturns := fake.cancelVLANReturns
	fake.recordInvocation("CancelVLAN", []interface{}{arg1})
	fake.cancelVLANMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNetworkManager) CancelVLANCallCount() int {
	fake.cancelVLANMutex.RLock()
	defer fake.cancelVLANMutex.RUnlock()
	return len(fake.cancelVLANArgsForCall)
}

func (fake *FakeNetworkManager) CancelVLANCalls(stub func(int) error) {
	fake.cancelVLANMutex.Lock()
	defer fake.cancelVLANMutex.Unlock()
	fake.CancelVLANStub = stub
}

func (fake *FakeNetworkManager) CancelVLANArgsForCall(i int) int {
	fake.cancelVLANMutex.RLock()
	defer fake.cancelVLANMutex.RUnlock()
	argsForCall := fake.cancelVLANArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNetworkManager) CancelVLANReturns(result1 error) {
	fake.cancelVLANMutex.Lock()
	defer fake.cancelVLANMutex.Unlock()
	fake.CancelVLANStub = nil
	fake.cancelVLANReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) CancelVLANReturnsOnCall(i int, result1 error) {
	fake.cancelVLANMutex.Lock()
	defer fake.cancelVLANMutex.Unlock()
	fake.CancelVLANStub = nil
	if fake.cancelVLANReturnsOnCall == nil {
		fake.cancelVLANReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelVLANReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) ClearRoute(arg1 int) (bool, error) {
	fake.clearRouteMutex.Lock()
	ret, specificReturn := fake.clearRouteReturnsOnCall[len(fake.clearRouteArgsForCall)]
	fake.clearRouteArgsForCall = append(fake.clearRouteArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.ClearRouteStub
	fakeReturns := fake.clearRouteReturns
	fake.recordInvocation("ClearRoute", []interface{}{arg1})
	fake.clearRouteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) ClearRouteCallCount() int {
	fake.clearRouteMutex.RLock()
	defer fake.clearRouteMutex.RUnlock()
	return len(fake.clearRouteArgsForCall)
}

func (fake *FakeNetworkManager) ClearRouteCalls(stub func(int) (bool, error)) {
	fake.clearRouteMutex.Lock()
	defer fake.clearRouteMutex.Unlock()
	fake.ClearRouteStub = stub
}

func (fake *FakeNetworkManager) ClearRouteArgsForCall(i int) int {
	fake.clearRouteMutex.RLock()
	defer fake.clearRouteMutex.RUnlock()
	argsForCall := fake.clearRouteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNetworkManager) ClearRouteReturns(result1 bool, result2 error) {
	fake.clearRouteMutex.Lock()
	defer fake.clearRouteMutex.Unlock()
	fake.ClearRouteStub = nil
	fake.clearRouteReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) ClearRouteReturnsOnCall(i int, result1 bool, result2 error) {
	fake.clearRouteMutex.Lock()
	defer fake.clearRouteMutex.Unlock()
	fake.ClearRouteStub = nil
	if fake.clearRouteReturnsOnCall == nil {
		fake.clearRouteReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.clearRouteReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) CreateSecurityGroup(arg1 string, arg2 string) (datatypes.Network_SecurityGroup, error) {
	fake.createSecurityGroupMutex.Lock()
	ret, specificReturn := fake.createSecurityGroupReturnsOnCall[len(fake.createSecurityGroupArgsForCall)]
	fake.createSecurityGroupArgsForCall = append(fake.createSecurityGroupArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.CreateSecurityGroupStub
	fakeReturns := fake.createSecurityGroupReturns
	fake.recordInvocation("CreateSecurityGroup", []interface{}{arg1, arg2})
	fake.createSecurityGroupMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) CreateSecurityGroupCallCount() int {
	fake.createSecurityGroupMutex.RLock()
	defer fake.createSecurityGroupMutex.RUnlock()
	return len(fake.createSecurityGroupArgsForCall)
}

func (fake *FakeNetworkManager) CreateSecurityGroupCalls(stub func(string, string) (datatypes.Network_SecurityGroup, error)) {
	fake.createSecurityGroupMutex.Lock()
	defer fake.createSecurityGroupMutex.Unlock()
	fake.CreateSecurityGroupStub = stub
}

func (fake *FakeNetworkManager) CreateSecurityGroupArgsForCall(i int) (string, string) {
	fake.createSecurityGroupMutex.RLock()
	defer fake.createSecurityGroupMutex.RUnlock()
	argsForCall := fake.createSecurityGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) CreateSecurityGroupReturns(result1 datatypes.Network_SecurityGroup, result2 error) {
	fake.createSecurityGroupMutex.Lock()
	defer fake.createSecurityGroupMutex.Unlock()
	fake.CreateSecurityGroupStub = nil
	fake.createSecurityGroupReturns = struct {
		result1 datatypes.Network_SecurityGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) CreateSecurityGroupReturnsOnCall(i int, result1 datatypes.Network_SecurityGroup, result2 error) {
	fake.createSecurityGroupMutex.Lock()
	defer fake.createSecurityGroupMutex.Unlock()
	fake.CreateSecurityGroupStub = nil
	if fake.createSecurityGroupReturnsOnCall == nil {
		fake.createSecurityGroupReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_SecurityGroup
			result2 error
		})
	}
	fake.createSecurityGroupReturnsOnCall[i] = struct {
		result1 datatypes.Network_SecurityGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) DeleteSecurityGroup(arg1 int) error {
	fake.deleteSecurityGroupMutex.Lock()
	ret, specificReturn := fake.deleteSecurityGroupReturnsOnCall[len(fake.deleteSecurityGroupArgsForCall)]
	fake.deleteSecurityGroupArgsForCall = append(fake.deleteSecurityGroupArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.DeleteSecurityGroupStub
	fakeReturns := fake.deleteSecurityGroupReturns
	fake.recordInvocation("DeleteSecurityGroup", []interface{}{arg1})
	fake.deleteSecurityGroupMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNetworkManager) DeleteSecurityGroupCallCount() int {
	fake.deleteSecurityGroupMutex.RLock()
	defer fake.deleteSecurityGroupMutex.RUnlock()
	return len(fake.deleteSecurityGroupArgsForCall)
}

func (fake *FakeNetworkManager) DeleteSecurityGroupCalls(stub func(int) error) {
	fake.deleteSecurityGroupMutex.Lock()
	defer fake.deleteSecurityGroupMutex.Unlock()
	fake.DeleteSecurityGroupStub = stub
}

func (fake *FakeNetworkManager) DeleteSecurityGroupArgsForCall(i int) int {
	fake.deleteSecurityGroupMutex.RLock()
	defer fake.deleteSecurityGroupMutex.RUnlock()
	argsForCall := fake.deleteSecurityGroupArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNetworkManager) DeleteSecurityGroupReturns(result1 error) {
	fake.deleteSecurityGroupMutex.Lock()
	defer fake.deleteSecurityGroupMutex.Unlock()
	fake.DeleteSecurityGroupStub = nil
	fake.deleteSecurityGroupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) DeleteSecurityGroupReturnsOnCall(i int, result1 error) {
	fake.deleteSecurityGroupMutex.Lock()
	defer fake.deleteSecurityGroupMutex.Unlock()
	fake.DeleteSecurityGroupStub = nil
	if fake.deleteSecurityGroupReturnsOnCall == nil {
		fake.deleteSecurityGroupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteSecurityGroupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) DetachSecurityGroupComponent(arg1 int, arg2 int) error {
	fake.detachSecurityGroupComponentMutex.Lock()
	ret, specificReturn := fake.detachSecurityGroupComponentReturnsOnCall[len(fake.detachSecurityGroupComponentArgsForCall)]
	fake.detachSecurityGroupComponentArgsForCall = append(fake.detachSecurityGroupComponentArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.DetachSecurityGroupComponentStub
	fakeReturns := fake.detachSecurityGroupComponentReturns
	fake.recordInvocation("DetachSecurityGroupComponent", []interface{}{arg1, arg2})
	fake.detachSecurityGroupComponentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNetworkManager) DetachSecurityGroupComponentCallCount() int {
	fake.detachSecurityGroupComponentMutex.RLock()
	defer fake.detachSecurityGroupComponentMutex.RUnlock()
	return len(fake.detachSecurityGroupComponentArgsForCall)
}

func (fake *FakeNetworkManager) DetachSecurityGroupComponentCalls(stub func(int, int) error) {
	fake.detachSecurityGroupComponentMutex.Lock()
	defer fake.detachSecurityGroupComponentMutex.Unlock()
	fake.DetachSecurityGroupComponentStub = stub
}

func (fake *FakeNetworkManager) DetachSecurityGroupComponentArgsForCall(i int) (int, int) {
	fake.detachSecurityGroupComponentMutex.RLock()
	defer fake.detachSecurityGroupComponentMutex.RUnlock()
	argsForCall := fake.detachSecurityGroupComponentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) DetachSecurityGroupComponentReturns(result1 error) {
	fake.detachSecurityGroupComponentMutex.Lock()
	defer fake.detachSecurityGroupComponentMutex.Unlock()
	fake.DetachSecurityGroupComponentStub = nil
	fake.detachSecurityGroupComponentReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) DetachSecurityGroupComponentReturnsOnCall(i int, result1 error) {
	fake.detachSecurityGroupComponentMutex.Lock()
	defer fake.detachSecurityGroupComponentMutex.Unlock()
	fake.DetachSecurityGroupComponentStub = nil
	if fake.detachSecurityGroupComponentReturnsOnCall == nil {
		fake.detachSecurityGroupComponentReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.detachSecurityGroupComponentReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) DetachSecurityGroupComponents(arg1 int, arg2 []int) error {
	var arg2Copy []int
	if arg2 != nil {
		arg2Copy = make([]int, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.detachSecurityGroupComponentsMutex.Lock()
	ret, specificReturn := fake.detachSecurityGroupComponentsReturnsOnCall[len(fake.detachSecurityGroupComponentsArgsForCall)]
	fake.detachSecurityGroupComponentsArgsForCall = append(fake.detachSecurityGroupComponentsArgsForCall, struct {
		arg1 int
		arg2 []int
	}{arg1, arg2Copy})
	stub := fake.DetachSecurityGroupComponentsStub
	fakeReturns := fake.detachSecurityGroupComponentsReturns
	fake.recordInvocation("DetachSecurityGroupComponents", []interface{}{arg1, arg2Copy})
	fake.detachSecurityGroupComponentsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNetworkManager) DetachSecurityGroupComponentsCallCount() int {
	fake.detachSecurityGroupComponentsMutex.RLock()
	defer fake.detachSecurityGroupComponentsMutex.RUnlock()
	return len(fake.detachSecurityGroupComponentsArgsForCall)
}

func (fake *FakeNetworkManager) DetachSecurityGroupComponentsCalls(stub func(int, []int) error) {
	fake.detachSecurityGroupComponentsMutex.Lock()
	defer fake.detachSecurityGroupComponentsMutex.Unlock()
	fake.DetachSecurityGroupComponentsStub = stub
}

func (fake *FakeNetworkManager) DetachSecurityGroupComponentsArgsForCall(i int) (int, []int) {
	fake.detachSecurityGroupComponentsMutex.RLock()
	defer fake.detachSecurityGroupComponentsMutex.RUnlock()
	argsForCall := fake.detachSecurityGroupComponentsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) DetachSecurityGroupComponentsReturns(result1 error) {
	fake.detachSecurityGroupComponentsMutex.Lock()
	defer fake.detachSecurityGroupComponentsMutex.Unlock()
	fake.DetachSecurityGroupComponentsStub = nil
	fake.detachSecurityGroupComponentsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) DetachSecurityGroupComponentsReturnsOnCall(i int, result1 error) {
	fake.detachSecurityGroupComponentsMutex.Lock()
	defer fake.detachSecurityGroupComponentsMutex.Unlock()
	fake.DetachSecurityGroupComponentsStub = nil
	if fake.detachSecurityGroupComponentsReturnsOnCall == nil {
		fake.detachSecurityGroupComponentsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.detachSecurityGroupComponentsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) EditSecurityGroup(arg1 int, arg2 string, arg3 string) error {
	fake.editSecurityGroupMutex.Lock()
	ret, specificReturn := fake.editSecurityGroupReturnsOnCall[len(fake.editSecurityGroupArgsForCall)]
	fake.editSecurityGroupArgsForCall = append(fake.editSecurityGroupArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.EditSecurityGroupStub
	fakeReturns := fake.editSecurityGroupReturns
	fake.recordInvocation("EditSecurityGroup", []interface{}{arg1, arg2, arg3})
	fake.editSecurityGroupMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNetworkManager) EditSecurityGroupCallCount() int {
	fake.editSecurityGroupMutex.RLock()
	defer fake.editSecurityGroupMutex.RUnlock()
	return len(fake.editSecurityGroupArgsForCall)
}

func (fake *FakeNetworkManager) EditSecurityGroupCalls(stub func(int, string, string) error) {
	fake.editSecurityGroupMutex.Lock()
	defer fake.editSecurityGroupMutex.Unlock()
	fake.EditSecurityGroupStub = stub
}

func (fake *FakeNetworkManager) EditSecurityGroupArgsForCall(i int) (int, string, string) {
	fake.editSecurityGroupMutex.RLock()
	defer fake.editSecurityGroupMutex.RUnlock()
	argsForCall := fake.editSecurityGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeNetworkManager) EditSecurityGroupReturns(result1 error) {
	fake.editSecurityGroupMutex.Lock()
	defer fake.editSecurityGroupMutex.Unlock()
	fake.EditSecurityGroupStub = nil
	fake.editSecurityGroupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) EditSecurityGroupReturnsOnCall(i int, result1 error) {
	fake.editSecurityGroupMutex.Lock()
	defer fake.editSecurityGroupMutex.Unlock()
	fake.EditSecurityGroupStub = nil
	if fake.editSecurityGroupReturnsOnCall == nil {
		fake.editSecurityGroupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.editSecurityGroupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) EditSecurityGroupRule(arg1 int, arg2 int, arg3 string, arg4 int, arg5 string, arg6 string, arg7 int, arg8 int, arg9 string) error {
	fake.editSecurityGroupRuleMutex.Lock()
	ret, specificReturn := fake.editSecurityGroupRuleReturnsOnCall[len(fake.editSecurityGroupRuleArgsForCall)]
	fake.editSecurityGroupRuleArgsForCall = append(fake.editSecurityGroupRuleArgsForCall, struct {
		arg1 int
		arg2 int
		arg3 string
		arg4 int
		arg5 string
		arg6 string
		arg7 int
		arg8 int
		arg9 string
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9})
	stub := fake.EditSecurityGroupRuleStub
	fakeReturns := fake.editSecurityGroupRuleReturns
	fake.recordInvocation("EditSecurityGroupRule", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9})
	fake.editSecurityGroupRuleMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNetworkManager) EditSecurityGroupRuleCallCount() int {
	fake.editSecurityGroupRuleMutex.RLock()
	defer fake.editSecurityGroupRuleMutex.RUnlock()
	return len(fake.editSecurityGroupRuleArgsForCall)
}

func (fake *FakeNetworkManager) EditSecurityGroupRuleCalls(stub func(int, int, string, int, string, string, int, int, string) error) {
	fake.editSecurityGroupRuleMutex.Lock()
	defer fake.editSecurityGroupRuleMutex.Unlock()
	fake.EditSecurityGroupRuleStub = stub
}

func (fake *FakeNetworkManager) EditSecurityGroupRuleArgsForCall(i int) (int, int, string, int, string, string, int, int, string) {
	fake.editSecurityGroupRuleMutex.RLock()
	defer fake.editSecurityGroupRuleMutex.RUnlock()
	argsForCall := fake.editSecurityGroupRuleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7, argsForCall.arg8, argsForCall.arg9
}

func (fake *FakeNetworkManager) EditSecurityGroupRuleReturns(result1 error) {
	fake.editSecurityGroupRuleMutex.Lock()
	defer fake.editSecurityGroupRuleMutex.Unlock()
	fake.EditSecurityGroupRuleStub = nil
	fake.editSecurityGroupRuleReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) EditSecurityGroupRuleReturnsOnCall(i int, result1 error) {
	fake.editSecurityGroupRuleMutex.Lock()
	defer fake.editSecurityGroupRuleMutex.Unlock()
	fake.EditSecurityGroupRuleStub = nil
	if fake.editSecurityGroupRuleReturnsOnCall == nil {
		fake.editSecurityGroupRuleReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.editSecurityGroupRuleReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) EditSecurityGroupRules(arg1 int, arg2 []datatypes.Network_SecurityGroup_Rule) error {
	var arg2Copy []datatypes.Network_SecurityGroup_Rule
	if arg2 != nil {
		arg2Copy = make([]datatypes.Network_SecurityGroup_Rule, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.editSecurityGroupRulesMutex.Lock()
	ret, specificReturn := fake.editSecurityGroupRulesReturnsOnCall[len(fake.editSecurityGroupRulesArgsForCall)]
	fake.editSecurityGroupRulesArgsForCall = append(fake.editSecurityGroupRulesArgsForCall, struct {
		arg1 int
		arg2 []datatypes.Network_SecurityGroup_Rule
	}{arg1, arg2Copy})
	stub := fake.EditSecurityGroupRulesStub
	fakeReturns := fake.editSecurityGroupRulesReturns
	fake.recordInvocation("EditSecurityGroupRules", []interface{}{arg1, arg2Copy})
	fake.editSecurityGroupRulesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNetworkManager) EditSecurityGroupRulesCallCount() int {
	fake.editSecurityGroupRulesMutex.RLock()
	defer fake.editSecurityGroupRulesMutex.RUnlock()
	return len(fake.editSecurityGroupRulesArgsForCall)
}

func (fake *FakeNetworkManager) EditSecurityGroupRulesCalls(stub func(int, []datatypes.Network_SecurityGroup_Rule) error) {
	fake.editSecurityGroupRulesMutex.Lock()
	defer fake.editSecurityGroupRulesMutex.Unlock()
	fake.EditSecurityGroupRulesStub = stub
}

func (fake *FakeNetworkManager) EditSecurityGroupRulesArgsForCall(i int) (int, []datatypes.Network_SecurityGroup_Rule) {
	fake.editSecurityGroupRulesMutex.RLock()
	defer fake.editSecurityGroupRulesMutex.RUnlock()
	argsForCall := fake.editSecurityGroupRulesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) EditSecurityGroupRulesReturns(result1 error) {
	fake.editSecurityGroupRulesMutex.Lock()
	defer fake.editSecurityGroupRulesMutex.Unlock()
	fake.EditSecurityGroupRulesStub = nil
	fake.editSecurityGroupRulesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) EditSecurityGroupRulesReturnsOnCall(i int, result1 error) {
	fake.editSecurityGroupRulesMutex.Lock()
	defer fake.editSecurityGroupRulesMutex.Unlock()
	fake.EditSecurityGroupRulesStub = nil
	if fake.editSecurityGroupRulesReturnsOnCall == nil {
		fake.editSecurityGroupRulesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.editSecurityGroupRulesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) EditSubnetIpAddress(arg1 int, arg2 datatypes.Network_Subnet_IpAddress) (bool, error) {
	fake.editSubnetIpAddressMutex.Lock()
	ret, specificReturn := fake.editSubnetIpAddressReturnsOnCall[len(fake.editSubnetIpAddressArgsForCall)]
	fake.editSubnetIpAddressArgsForCall = append(fake.editSubnetIpAddressArgsForCall, struct {
		arg1 int
		arg2 datatypes.Network_Subnet_IpAddress
	}{arg1, arg2})
	stub := fake.EditSubnetIpAddressStub
	fakeReturns := fake.editSubnetIpAddressReturns
	fake.recordInvocation("EditSubnetIpAddress", []interface{}{arg1, arg2})
	fake.editSubnetIpAddressMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) EditSubnetIpAddressCallCount() int {
	fake.editSubnetIpAddressMutex.RLock()
	defer fake.editSubnetIpAddressMutex.RUnlock()
	return len(fake.editSubnetIpAddressArgsForCall)
}

func (fake *FakeNetworkManager) EditSubnetIpAddressCalls(stub func(int, datatypes.Network_Subnet_IpAddress) (bool, error)) {
	fake.editSubnetIpAddressMutex.Lock()
	defer fake.editSubnetIpAddressMutex.Unlock()
	fake.EditSubnetIpAddressStub = stub
}

func (fake *FakeNetworkManager) EditSubnetIpAddressArgsForCall(i int) (int, datatypes.Network_Subnet_IpAddress) {
	fake.editSubnetIpAddressMutex.RLock()
	defer fake.editSubnetIpAddressMutex.RUnlock()
	argsForCall := fake.editSubnetIpAddressArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) EditSubnetIpAddressReturns(result1 bool, result2 error) {
	fake.editSubnetIpAddressMutex.Lock()
	defer fake.editSubnetIpAddressMutex.Unlock()
	fake.EditSubnetIpAddressStub = nil
	fake.editSubnetIpAddressReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) EditSubnetIpAddressReturnsOnCall(i int, result1 bool, result2 error) {
	fake.editSubnetIpAddressMutex.Lock()
	defer fake.editSubnetIpAddressMutex.Unlock()
	fake.EditSubnetIpAddressStub = nil
	if fake.editSubnetIpAddressReturnsOnCall == nil {
		fake.editSubnetIpAddressReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.editSubnetIpAddressReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) EditVlan(arg1 int, arg2 string) error {
	fake.editVlanMutex.Lock()
	ret, specificReturn := fake.editVlanReturnsOnCall[len(fake.editVlanArgsForCall)]
	fake.editVlanArgsForCall = append(fake.editVlanArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.EditVlanStub
	fakeReturns := fake.editVlanReturns
	fake.recordInvocation("EditVlan", []interface{}{arg1, arg2})
	fake.editVlanMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNetworkManager) EditVlanCallCount() int {
	fake.editVlanMutex.RLock()
	defer fake.editVlanMutex.RUnlock()
	return len(fake.editVlanArgsForCall)
}

func (fake *FakeNetworkManager) EditVlanCalls(stub func(int, string) error) {
	fake.editVlanMutex.Lock()
	defer fake.editVlanMutex.Unlock()
	fake.EditVlanStub = stub
}

func (fake *FakeNetworkManager) EditVlanArgsForCall(i int) (int, string) {
	fake.editVlanMutex.RLock()
	defer fake.editVlanMutex.RUnlock()
	argsForCall := fake.editVlanArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) EditVlanReturns(result1 error) {
	fake.editVlanMutex.Lock()
	defer fake.editVlanMutex.Unlock()
	fake.EditVlanStub = nil
	fake.editVlanReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) EditVlanReturnsOnCall(i int, result1 error) {
	fake.editVlanMutex.Lock()
	defer fake.editVlanMutex.Unlock()
	fake.EditVlanStub = nil
	if fake.editVlanReturnsOnCall == nil {
		fake.editVlanReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.editVlanReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) GetCancelFailureReasons(arg1 int) []string {
	fake.getCancelFailureReasonsMutex.Lock()
	ret, specificReturn := fake.getCancelFailureReasonsReturnsOnCall[len(fake.getCancelFailureReasonsArgsForCall)]
	fake.getCancelFailureReasonsArgsForCall = append(fake.getCancelFailureReasonsArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.GetCancelFailureReasonsStub
	fakeReturns := fake.getCancelFailureReasonsReturns
	fake.recordInvocation("GetCancelFailureReasons", []interface{}{arg1})
	fake.getCancelFailureReasonsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNetworkManager) GetCancelFailureReasonsCallCount() int {
	fake.getCancelFailureReasonsMutex.RLock()
	defer fake.getCancelFailureReasonsMutex.RUnlock()
	return len(fake.getCancelFailureReasonsArgsForCall)
}

func (fake *FakeNetworkManager) GetCancelFailureReasonsCalls(stub func(int) []string) {
	fake.getCancelFailureReasonsMutex.Lock()
	defer fake.getCancelFailureReasonsMutex.Unlock()
	fake.GetCancelFailureReasonsStub = stub
}

func (fake *FakeNetworkManager) GetCancelFailureReasonsArgsForCall(i int) int {
	fake.getCancelFailureReasonsMutex.RLock()
	defer fake.getCancelFailureReasonsMutex.RUnlock()
	argsForCall := fake.getCancelFailureReasonsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNetworkManager) GetCancelFailureReasonsReturns(result1 []string) {
	fake.getCancelFailureReasonsMutex.Lock()
	defer fake.getCancelFailureReasonsMutex.Unlock()
	fake.GetCancelFailureReasonsStub = nil
	fake.getCancelFailureReasonsReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeNetworkManager) GetCancelFailureReasonsReturnsOnCall(i int, result1 []string) {
	fake.getCancelFailureReasonsMutex.Lock()
	defer fake.getCancelFailureReasonsMutex.Unlock()
	fake.GetCancelFailureReasonsStub = nil
	if fake.getCancelFailureReasonsReturnsOnCall == nil {
		fake.getCancelFailureReasonsReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.getCancelFailureReasonsReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeNetworkManager) GetIpByAddress(arg1 string) (datatypes.Network_Subnet_IpAddress, error) {
	fake.getIpByAddressMutex.Lock()
	ret, specificReturn := fake.getIpByAddressReturnsOnCall[len(fake.getIpByAddressArgsForCall)]
	fake.getIpByAddressArgsForCall = append(fake.getIpByAddressArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetIpByAddressStub
	fakeReturns := fake.getIpByAddressReturns
	fake.recordInvocation("GetIpByAddress", []interface{}{arg1})
	fake.getIpByAddressMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) GetIpByAddressCallCount() int {
	fake.getIpByAddressMutex.RLock()
	defer fake.getIpByAddressMutex.RUnlock()
	return len(fake.getIpByAddressArgsForCall)
}

func (fake *FakeNetworkManager) GetIpByAddressCalls(stub func(string) (datatypes.Network_Subnet_IpAddress, error)) {
	fake.getIpByAddressMutex.Lock()
	defer fake.getIpByAddressMutex.Unlock()
	fake.GetIpByAddressStub = stub
}

func (fake *FakeNetworkManager) GetIpByAddressArgsForCall(i int) string {
	fake.getIpByAddressMutex.RLock()
	defer fake.getIpByAddressMutex.RUnlock()
	argsForCall := fake.getIpByAddressArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNetworkManager) GetIpByAddressReturns(result1 datatypes.Network_Subnet_IpAddress, result2 error) {
	fake.getIpByAddressMutex.Lock()
	defer fake.getIpByAddressMutex.Unlock()
	fake.GetIpByAddressStub = nil
	fake.getIpByAddressReturns = struct {
		result1 datatypes.Network_Subnet_IpAddress
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) GetIpByAddressReturnsOnCall(i int, result1 datatypes.Network_Subnet_IpAddress, result2 error) {
	fake.getIpByAddressMutex.Lock()
	defer fake.getIpByAddressMutex.Unlock()
	fake.GetIpByAddressStub = nil
	if fake.getIpByAddressReturnsOnCall == nil {
		fake.getIpByAddressReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_Subnet_IpAddress
			result2 error
		})
	}
	fake.getIpByAddressReturnsOnCall[i] = struct {
		result1 datatypes.Network_Subnet_IpAddress
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) GetPods(arg1 string, arg2 bool) ([]datatypes.Network_Pod, error) {
	fake.getPodsMutex.Lock()
	ret, specificReturn := fake.getPodsReturnsOnCall[len(fake.getPodsArgsForCall)]
	fake.getPodsArgsForCall = append(fake.getPodsArgsForCall, struct {
		arg1 string
		arg2 bool
	}{arg1, arg2})
	stub := fake.GetPodsStub
	fakeReturns := fake.getPodsReturns
	fake.recordInvocation("GetPods", []interface{}{arg1, arg2})
	fake.getPodsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) GetPodsCallCount() int {
	fake.getPodsMutex.RLock()
	defer fake.getPodsMutex.RUnlock()
	return len(fake.getPodsArgsForCall)
}

func (fake *FakeNetworkManager) GetPodsCalls(stub func(string, bool) ([]datatypes.Network_Pod, error)) {
	fake.getPodsMutex.Lock()
	defer fake.getPodsMutex.Unlock()
	fake.GetPodsStub = stub
}

func (fake *FakeNetworkManager) GetPodsArgsForCall(i int) (string, bool) {
	fake.getPodsMutex.RLock()
	defer fake.getPodsMutex.RUnlock()
	argsForCall := fake.getPodsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) GetPodsReturns(result1 []datatypes.Network_Pod, result2 error) {
	fake.getPodsMutex.Lock()
	defer fake.getPodsMutex.Unlock()
	fake.GetPodsStub = nil
	fake.getPodsReturns = struct {
		result1 []datatypes.Network_Pod
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) GetPodsReturnsOnCall(i int, result1 []datatypes.Network_Pod, result2 error) {
	fake.getPodsMutex.Lock()
	defer fake.getPodsMutex.Unlock()
	fake.GetPodsStub = nil
	if fake.getPodsReturnsOnCall == nil {
		fake.getPodsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Network_Pod
			result2 error
		})
	}
	fake.getPodsReturnsOnCall[i] = struct {
		result1 []datatypes.Network_Pod
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) GetRouters(arg1 string) ([]datatypes.Hardware, error) {
	fake.getRoutersMutex.Lock()
	ret, specificReturn := fake.getRoutersReturnsOnCall[len(fake.getRoutersArgsForCall)]
	fake.getRoutersArgsForCall = append(fake.getRoutersArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetRoutersStub
	fakeReturns := fake.getRoutersReturns
	fake.recordInvocation("GetRouters", []interface{}{arg1})
	fake.getRoutersMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) GetRoutersCallCount() int {
	fake.getRoutersMutex.RLock()
	defer fake.getRoutersMutex.RUnlock()
	return len(fake.getRoutersArgsForCall)
}

func (fake *FakeNetworkManager) GetRoutersCalls(stub func(string) ([]datatypes.Hardware, error)) {
	fake.getRoutersMutex.Lock()
	defer fake.getRoutersMutex.Unlock()
	fake.GetRoutersStub = stub
}

func (fake *FakeNetworkManager) GetRoutersArgsForCall(i int) string {
	fake.getRoutersMutex.RLock()
	defer fake.getRoutersMutex.RUnlock()
	argsForCall := fake.getRoutersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNetworkManager) GetRoutersReturns(result1 []datatypes.Hardware, result2 error) {
	fake.getRoutersMutex.Lock()
	defer fake.getRoutersMutex.Unlock()
	fake.GetRoutersStub = nil
	fake.getRoutersReturns = struct {
		result1 []datatypes.Hardware
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) GetRoutersReturnsOnCall(i int, result1 []datatypes.Hardware, result2 error) {
	fake.getRoutersMutex.Lock()
	defer fake.getRoutersMutex.Unlock()
	fake.GetRoutersStub = nil
	if fake.getRoutersReturnsOnCall == nil {
		fake.getRoutersReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Hardware
			result2 error
		})
	}
	fake.getRoutersReturnsOnCall[i] = struct {
		result1 []datatypes.Hardware
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) GetSecurityGroup(arg1 int, arg2 string) (datatypes.Network_SecurityGroup, error) {
	fake.getSecurityGroupMutex.Lock()
	ret, specificReturn := fake.getSecurityGroupReturnsOnCall[len(fake.getSecurityGroupArgsForCall)]
	fake.getSecurityGroupArgsForCall = append(fake.getSecurityGroupArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.GetSecurityGroupStub
	fakeReturns := fake.getSecurityGroupReturns
	fake.recordInvocation("GetSecurityGroup", []interface{}{arg1, arg2})
	fake.getSecurityGroupMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) GetSecurityGroupCallCount() int {
	fake.getSecurityGroupMutex.RLock()
	defer fake.getSecurityGroupMutex.RUnlock()
	return len(fake.getSecurityGroupArgsForCall)
}

func (fake *FakeNetworkManager) GetSecurityGroupCalls(stub func(int, string) (datatypes.Network_SecurityGroup, error)) {
	fake.getSecurityGroupMutex.Lock()
	defer fake.getSecurityGroupMutex.Unlock()
	fake.GetSecurityGroupStub = stub
}

func (fake *FakeNetworkManager) GetSecurityGroupArgsForCall(i int) (int, string) {
	fake.getSecurityGroupMutex.RLock()
	defer fake.getSecurityGroupMutex.RUnlock()
	argsForCall := fake.getSecurityGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) GetSecurityGroupReturns(result1 datatypes.Network_SecurityGroup, result2 error) {
	fake.getSecurityGroupMutex.Lock()
	defer fake.getSecurityGroupMutex.Unlock()
	fake.GetSecurityGroupStub = nil
	fake.getSecurityGroupReturns = struct {
		result1 datatypes.Network_SecurityGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) GetSecurityGroupReturnsOnCall(i int, result1 datatypes.Network_SecurityGroup, result2 error) {
	fake.getSecurityGroupMutex.Lock()
	defer fake.getSecurityGroupMutex.Unlock()
	fake.GetSecurityGroupStub = nil
	if fake.getSecurityGroupReturnsOnCall == nil {
		fake.getSecurityGroupReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_SecurityGroup
			result2 error
		})
	}
	fake.getSecurityGroupReturnsOnCall[i] = struct {
		result1 datatypes.Network_SecurityGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) GetSubnet(arg1 int, arg2 string) (datatypes.Network_Subnet, error) {
	fake.getSubnetMutex.Lock()
	ret, specificReturn := fake.getSubnetReturnsOnCall[len(fake.getSubnetArgsForCall)]
	fake.getSubnetArgsForCall = append(fake.getSubnetArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.GetSubnetStub
	fakeReturns := fake.getSubnetReturns
	fake.recordInvocation("GetSubnet", []interface{}{arg1, arg2})
	fake.getSubnetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) GetSubnetCallCount() int {
	fake.getSubnetMutex.RLock()
	defer fake.getSubnetMutex.RUnlock()
	return len(fake.getSubnetArgsForCall)
}

func (fake *FakeNetworkManager) GetSubnetCalls(stub func(int, string) (datatypes.Network_Subnet, error)) {
	fake.getSubnetMutex.Lock()
	defer fake.getSubnetMutex.Unlock()
	fake.GetSubnetStub = stub
}

func (fake *FakeNetworkManager) GetSubnetArgsForCall(i int) (int, string) {
	fake.getSubnetMutex.RLock()
	defer fake.getSubnetMutex.RUnlock()
	argsForCall := fake.getSubnetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) GetSubnetReturns(result1 datatypes.Network_Subnet, result2 error) {
	fake.getSubnetMutex.Lock()
	defer fake.getSubnetMutex.Unlock()
	fake.GetSubnetStub = nil
	fake.getSubnetReturns = struct {
		result1 datatypes.Network_Subnet
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) GetSubnetReturnsOnCall(i int, result1 datatypes.Network_Subnet, result2 error) {
	fake.getSubnetMutex.Lock()
	defer fake.getSubnetMutex.Unlock()
	fake.GetSubnetStub = nil
	if fake.getSubnetReturnsOnCall == nil {
		fake.getSubnetReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_Subnet
			result2 error
		})
	}
	fake.getSubnetReturnsOnCall[i] = struct {
		result1 datatypes.Network_Subnet
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) GetVlan(arg1 int, arg2 string) (datatypes.Network_Vlan, error) {
	fake.getVlanMutex.Lock()
	ret, specificReturn := fake.getVlanReturnsOnCall[len(fake.getVlanArgsForCall)]
	fake.getVlanArgsForCall = append(fake.getVlanArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.GetVlanStub
	fakeReturns := fake.getVlanReturns
	fake.recordInvocation("GetVlan", []interface{}{arg1, arg2})
	fake.getVlanMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) GetVlanCallCount() int {
	fake.getVlanMutex.RLock()
	defer fake.getVlanMutex.RUnlock()
	return len(fake.getVlanArgsForCall)
}

func (fake *FakeNetworkManager) GetVlanCalls(stub func(int, string) (datatypes.Network_Vlan, error)) {
	fake.getVlanMutex.Lock()
	defer fake.getVlanMutex.Unlock()
	fake.GetVlanStub = stub
}

func (fake *FakeNetworkManager) GetVlanArgsForCall(i int) (int, string) {
	fake.getVlanMutex.RLock()
	defer fake.getVlanMutex.RUnlock()
	argsForCall := fake.getVlanArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) GetVlanReturns(result1 datatypes.Network_Vlan, result2 error) {
	fake.getVlanMutex.Lock()
	defer fake.getVlanMutex.Unlock()
	fake.GetVlanStub = nil
	fake.getVlanReturns = struct {
		result1 datatypes.Network_Vlan
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) GetVlanReturnsOnCall(i int, result1 datatypes.Network_Vlan, result2 error) {
	fake.getVlanMutex.Lock()
	defer fake.getVlanMutex.Unlock()
	fake.GetVlanStub = nil
	if fake.getVlanReturnsOnCall == nil {
		fake.getVlanReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_Vlan
			result2 error
		})
	}
	fake.getVlanReturnsOnCall[i] = struct {
		result1 datatypes.Network_Vlan
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) IPLookup(arg1 string) (datatypes.Network_Subnet_IpAddress, error) {
	fake.iPLookupMutex.Lock()
	ret, specificReturn := fake.iPLookupReturnsOnCall[len(fake.iPLookupArgsForCall)]
	fake.iPLookupArgsForCall = append(fake.iPLookupArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.IPLookupStub
	fakeReturns := fake.iPLookupReturns
	fake.recordInvocation("IPLookup", []interface{}{arg1})
	fake.iPLookupMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) IPLookupCallCount() int {
	fake.iPLookupMutex.RLock()
	defer fake.iPLookupMutex.RUnlock()
	return len(fake.iPLookupArgsForCall)
}

func (fake *FakeNetworkManager) IPLookupCalls(stub func(string) (datatypes.Network_Subnet_IpAddress, error)) {
	fake.iPLookupMutex.Lock()
	defer fake.iPLookupMutex.Unlock()
	fake.IPLookupStub = stub
}

func (fake *FakeNetworkManager) IPLookupArgsForCall(i int) string {
	fake.iPLookupMutex.RLock()
	defer fake.iPLookupMutex.RUnlock()
	argsForCall := fake.iPLookupArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNetworkManager) IPLookupReturns(result1 datatypes.Network_Subnet_IpAddress, result2 error) {
	fake.iPLookupMutex.Lock()
	defer fake.iPLookupMutex.Unlock()
	fake.IPLookupStub = nil
	fake.iPLookupReturns = struct {
		result1 datatypes.Network_Subnet_IpAddress
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) IPLookupReturnsOnCall(i int, result1 datatypes.Network_Subnet_IpAddress, result2 error) {
	fake.iPLookupMutex.Lock()
	defer fake.iPLookupMutex.Unlock()
	fake.IPLookupStub = nil
	if fake.iPLookupReturnsOnCall == nil {
		fake.iPLookupReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_Subnet_IpAddress
			result2 error
		})
	}
	fake.iPLookupReturnsOnCall[i] = struct {
		result1 datatypes.Network_Subnet_IpAddress
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) ListDatacenters() (map[int]string, error) {
	fake.listDatacentersMutex.Lock()
	ret, specificReturn := fake.listDatacentersReturnsOnCall[len(fake.listDatacentersArgsForCall)]
	fake.listDatacentersArgsForCall = append(fake.listDatacentersArgsForCall, struct {
	}{})
	stub := fake.ListDatacentersStub
	fakeReturns := fake.listDatacentersReturns
	fake.recordInvocation("ListDatacenters", []interface{}{})
	fake.listDatacentersMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) ListDatacentersCallCount() int {
	fake.listDatacentersMutex.RLock()
	defer fake.listDatacentersMutex.RUnlock()
	return len(fake.listDatacentersArgsForCall)
}

func (fake *FakeNetworkManager) ListDatacentersCalls(stub func() (map[int]string, error)) {
	fake.listDatacentersMutex.Lock()
	defer fake.listDatacentersMutex.Unlock()
	fake.ListDatacentersStub = stub
}

func (fake *FakeNetworkManager) ListDatacentersReturns(result1 map[int]string, result2 error) {
	fake.listDatacentersMutex.Lock()
	defer fake.listDatacentersMutex.Unlock()
	fake.ListDatacentersStub = nil
	fake.listDatacentersReturns = struct {
		result1 map[int]string
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) ListDatacentersReturnsOnCall(i int, result1 map[int]string, result2 error) {
	fake.listDatacentersMutex.Lock()
	defer fake.listDatacentersMutex.Unlock()
	fake.ListDatacentersStub = nil
	if fake.listDatacentersReturnsOnCall == nil {
		fake.listDatacentersReturnsOnCall = make(map[int]struct {
			result1 map[int]string
			result2 error
		})
	}
	fake.listDatacentersReturnsOnCall[i] = struct {
		result1 map[int]string
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) ListGlobalIPs(arg1 int, arg2 int) ([]datatypes.Network_Subnet_IpAddress_Global, error) {
	fake.listGlobalIPsMutex.Lock()
	ret, specificReturn := fake.listGlobalIPsReturnsOnCall[len(fake.listGlobalIPsArgsForCall)]
	fake.listGlobalIPsArgsForCall = append(fake.listGlobalIPsArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.ListGlobalIPsStub
	fakeReturns := fake.listGlobalIPsReturns
	fake.recordInvocation("ListGlobalIPs", []interface{}{arg1, arg2})
	fake.listGlobalIPsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) ListGlobalIPsCallCount() int {
	fake.listGlobalIPsMutex.RLock()
	defer fake.listGlobalIPsMutex.RUnlock()
	return len(fake.listGlobalIPsArgsForCall)
}

func (fake *FakeNetworkManager) ListGlobalIPsCalls(stub func(int, int) ([]datatypes.Network_Subnet_IpAddress_Global, error)) {
	fake.listGlobalIPsMutex.Lock()
	defer fake.listGlobalIPsMutex.Unlock()
	fake.ListGlobalIPsStub = stub
}

func (fake *FakeNetworkManager) ListGlobalIPsArgsForCall(i int) (int, int) {
	fake.listGlobalIPsMutex.RLock()
	defer fake.listGlobalIPsMutex.RUnlock()
	argsForCall := fake.listGlobalIPsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) ListGlobalIPsReturns(result1 []datatypes.Network_Subnet_IpAddress_Global, result2 error) {
	fake.listGlobalIPsMutex.Lock()
	defer fake.listGlobalIPsMutex.Unlock()
	fake.ListGlobalIPsStub = nil
	fake.listGlobalIPsReturns = struct {
		result1 []datatypes.Network_Subnet_IpAddress_Global
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) ListGlobalIPsReturnsOnCall(i int, result1 []datatypes.Network_Subnet_IpAddress_Global, result2 error) {
	fake.listGlobalIPsMutex.Lock()
	defer fake.listGlobalIPsMutex.Unlock()
	fake.ListGlobalIPsStub = nil
	if fake.listGlobalIPsReturnsOnCall == nil {
		fake.listGlobalIPsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Network_Subnet_IpAddress_Global
			result2 error
		})
	}
	fake.listGlobalIPsReturnsOnCall[i] = struct {
		result1 []datatypes.Network_Subnet_IpAddress_Global
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) ListRouters(arg1 int, arg2 string) ([]string, error) {
	fake.listRoutersMutex.Lock()
	ret, specificReturn := fake.listRoutersReturnsOnCall[len(fake.listRoutersArgsForCall)]
	fake.listRoutersArgsForCall = append(fake.listRoutersArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.ListRoutersStub
	fakeReturns := fake.listRoutersReturns
	fake.recordInvocation("ListRouters", []interface{}{arg1, arg2})
	fake.listRoutersMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) ListRoutersCallCount() int {
	fake.listRoutersMutex.RLock()
	defer fake.listRoutersMutex.RUnlock()
	return len(fake.listRoutersArgsForCall)
}

func (fake *FakeNetworkManager) ListRoutersCalls(stub func(int, string) ([]string, error)) {
	fake.listRoutersMutex.Lock()
	defer fake.listRoutersMutex.Unlock()
	fake.ListRoutersStub = stub
}

func (fake *FakeNetworkManager) ListRoutersArgsForCall(i int) (int, string) {
	fake.listRoutersMutex.RLock()
	defer fake.listRoutersMutex.RUnlock()
	argsForCall := fake.listRoutersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) ListRoutersReturns(result1 []string, result2 error) {
	fake.listRoutersMutex.Lock()
	defer fake.listRoutersMutex.Unlock()
	fake.ListRoutersStub = nil
	fake.listRoutersReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) ListRoutersReturnsOnCall(i int, result1 []string, result2 error) {
	fake.listRoutersMutex.Lock()
	defer fake.listRoutersMutex.Unlock()
	fake.ListRoutersStub = nil
	if fake.listRoutersReturnsOnCall == nil {
		fake.listRoutersReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.listRoutersReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) ListSecurityGroupRules(arg1 int) ([]datatypes.Network_SecurityGroup_Rule, error) {
	fake.listSecurityGroupRulesMutex.Lock()
	ret, specificReturn := fake.listSecurityGroupRulesReturnsOnCall[len(fake.listSecurityGroupRulesArgsForCall)]
	fake.listSecurityGroupRulesArgsForCall = append(fake.listSecurityGroupRulesArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.ListSecurityGroupRulesStub
	fakeReturns := fake.listSecurityGroupRulesReturns
	fake.recordInvocation("ListSecurityGroupRules", []interface{}{arg1})
	fake.listSecurityGroupRulesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) ListSecurityGroupRulesCallCount() int {
	fake.listSecurityGroupRulesMutex.RLock()
	defer fake.listSecurityGroupRulesMutex.RUnlock()
	return len(fake.listSecurityGroupRulesArgsForCall)
}

func (fake *FakeNetworkManager) ListSecurityGroupRulesCalls(stub func(int) ([]datatypes.Network_SecurityGroup_Rule, error)) {
	fake.listSecurityGroupRulesMutex.Lock()
	defer fake.listSecurityGroupRulesMutex.Unlock()
	fake.ListSecurityGroupRulesStub = stub
}

func (fake *FakeNetworkManager) ListSecurityGroupRulesArgsForCall(i int) int {
	fake.listSecurityGroupRulesMutex.RLock()
	defer fake.listSecurityGroupRulesMutex.RUnlock()
	argsForCall := fake.listSecurityGroupRulesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNetworkManager) ListSecurityGroupRulesReturns(result1 []datatypes.Network_SecurityGroup_Rule, result2 error) {
	fake.listSecurityGroupRulesMutex.Lock()
	defer fake.listSecurityGroupRulesMutex.Unlock()
	fake.ListSecurityGroupRulesStub = nil
	fake.listSecurityGroupRulesReturns = struct {
		result1 []datatypes.Network_SecurityGroup_Rule
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) ListSecurityGroupRulesReturnsOnCall(i int, result1 []datatypes.Network_SecurityGroup_Rule, result2 error) {
	fake.listSecurityGroupRulesMutex.Lock()
	defer fake.listSecurityGroupRulesMutex.Unlock()
	fake.ListSecurityGroupRulesStub = nil
	if fake.listSecurityGroupRulesReturnsOnCall == nil {
		fake.listSecurityGroupRulesReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Network_SecurityGroup_Rule
			result2 error
		})
	}
	fake.listSecurityGroupRulesReturnsOnCall[i] = struct {
		result1 []datatypes.Network_SecurityGroup_Rule
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) ListSecurityGroups() ([]datatypes.Network_SecurityGroup, error) {
	fake.listSecurityGroupsMutex.Lock()
	ret, specificReturn := fake.listSecurityGroupsReturnsOnCall[len(fake.listSecurityGroupsArgsForCall)]
	fake.listSecurityGroupsArgsForCall = append(fake.listSecurityGroupsArgsForCall, struct {
	}{})
	stub := fake.ListSecurityGroupsStub
	fakeReturns := fake.listSecurityGroupsReturns
	fake.recordInvocation("ListSecurityGroups", []interface{}{})
	fake.listSecurityGroupsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) ListSecurityGroupsCallCount() int {
	fake.listSecurityGroupsMutex.RLock()
	defer fake.listSecurityGroupsMutex.RUnlock()
	return len(fake.listSecurityGroupsArgsForCall)
}

func (fake *FakeNetworkManager) ListSecurityGroupsCalls(stub func() ([]datatypes.Network_SecurityGroup, error)) {
	fake.listSecurityGroupsMutex.Lock()
	defer fake.listSecurityGroupsMutex.Unlock()
	fake.ListSecurityGroupsStub = stub
}

func (fake *FakeNetworkManager) ListSecurityGroupsReturns(result1 []datatypes.Network_SecurityGroup, result2 error) {
	fake.listSecurityGroupsMutex.Lock()
	defer fake.listSecurityGroupsMutex.Unlock()
	fake.ListSecurityGroupsStub = nil
	fake.listSecurityGroupsReturns = struct {
		result1 []datatypes.Network_SecurityGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) ListSecurityGroupsReturnsOnCall(i int, result1 []datatypes.Network_SecurityGroup, result2 error) {
	fake.listSecurityGroupsMutex.Lock()
	defer fake.listSecurityGroupsMutex.Unlock()
	fake.ListSecurityGroupsStub = nil
	if fake.listSecurityGroupsReturnsOnCall == nil {
		fake.listSecurityGroupsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Network_SecurityGroup
			result2 error
		})
	}
	fake.listSecurityGroupsReturnsOnCall[i] = struct {
		result1 []datatypes.Network_SecurityGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) ListSubnets(arg1 string, arg2 string, arg3 int, arg4 string, arg5 string, arg6 int, arg7 string) ([]datatypes.Network_Subnet, error) {
	fake.listSubnetsMutex.Lock()
	ret, specificReturn := fake.listSubnetsReturnsOnCall[len(fake.listSubnetsArgsForCall)]
	fake.listSubnetsArgsForCall = append(fake.listSubnetsArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 int
		arg4 string
		arg5 string
		arg6 int
		arg7 string
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	stub := fake.ListSubnetsStub
	fakeReturns := fake.listSubnetsReturns
	fake.recordInvocation("ListSubnets", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.listSubnetsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) ListSubnetsCallCount() int {
	fake.listSubnetsMutex.RLock()
	defer fake.listSubnetsMutex.RUnlock()
	return len(fake.listSubnetsArgsForCall)
}

func (fake *FakeNetworkManager) ListSubnetsCalls(stub func(string, string, int, string, string, int, string) ([]datatypes.Network_Subnet, error)) {
	fake.listSubnetsMutex.Lock()
	defer fake.listSubnetsMutex.Unlock()
	fake.ListSubnetsStub = stub
}

func (fake *FakeNetworkManager) ListSubnetsArgsForCall(i int) (string, string, int, string, string, int, string) {
	fake.listSubnetsMutex.RLock()
	defer fake.listSubnetsMutex.RUnlock()
	argsForCall := fake.listSubnetsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeNetworkManager) ListSubnetsReturns(result1 []datatypes.Network_Subnet, result2 error) {
	fake.listSubnetsMutex.Lock()
	defer fake.listSubnetsMutex.Unlock()
	fake.ListSubnetsStub = nil
	fake.listSubnetsReturns = struct {
		result1 []datatypes.Network_Subnet
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) ListSubnetsReturnsOnCall(i int, result1 []datatypes.Network_Subnet, result2 error) {
	fake.listSubnetsMutex.Lock()
	defer fake.listSubnetsMutex.Unlock()
	fake.ListSubnetsStub = nil
	if fake.listSubnetsReturnsOnCall == nil {
		fake.listSubnetsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Network_Subnet
			result2 error
		})
	}
	fake.listSubnetsReturnsOnCall[i] = struct {
		result1 []datatypes.Network_Subnet
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) ListVlans(arg1 string, arg2 int, arg3 string, arg4 int, arg5 string) ([]datatypes.Network_Vlan, error) {
	fake.listVlansMutex.Lock()
	ret, specificReturn := fake.listVlansReturnsOnCall[len(fake.listVlansArgsForCall)]
	fake.listVlansArgsForCall = append(fake.listVlansArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 string
		arg4 int
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.ListVlansStub
	fakeReturns := fake.listVlansReturns
	fake.recordInvocation("ListVlans", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.listVlansMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) ListVlansCallCount() int {
	fake.listVlansMutex.RLock()
	defer fake.listVlansMutex.RUnlock()
	return len(fake.listVlansArgsForCall)
}

func (fake *FakeNetworkManager) ListVlansCalls(stub func(string, int, string, int, string) ([]datatypes.Network_Vlan, error)) {
	fake.listVlansMutex.Lock()
	defer fake.listVlansMutex.Unlock()
	fake.ListVlansStub = stub
}

func (fake *FakeNetworkManager) ListVlansArgsForCall(i int) (string, int, string, int, string) {
	fake.listVlansMutex.RLock()
	defer fake.listVlansMutex.RUnlock()
	argsForCall := fake.listVlansArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeNetworkManager) ListVlansReturns(result1 []datatypes.Network_Vlan, result2 error) {
	fake.listVlansMutex.Lock()
	defer fake.listVlansMutex.Unlock()
	fake.ListVlansStub = nil
	fake.listVlansReturns = struct {
		result1 []datatypes.Network_Vlan
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) ListVlansReturnsOnCall(i int, result1 []datatypes.Network_Vlan, result2 error) {
	fake.listVlansMutex.Lock()
	defer fake.listVlansMutex.Unlock()
	fake.ListVlansStub = nil
	if fake.listVlansReturnsOnCall == nil {
		fake.listVlansReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Network_Vlan
			result2 error
		})
	}
	fake.listVlansReturnsOnCall[i] = struct {
		result1 []datatypes.Network_Vlan
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) RemoveSecurityGroupRule(arg1 int, arg2 int) error {
	fake.removeSecurityGroupRuleMutex.Lock()
	ret, specificReturn := fake.removeSecurityGroupRuleReturnsOnCall[len(fake.removeSecurityGroupRuleArgsForCall)]
	fake.removeSecurityGroupRuleArgsForCall = append(fake.removeSecurityGroupRuleArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.RemoveSecurityGroupRuleStub
	fakeReturns := fake.removeSecurityGroupRuleReturns
	fake.recordInvocation("RemoveSecurityGroupRule", []interface{}{arg1, arg2})
	fake.removeSecurityGroupRuleMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNetworkManager) RemoveSecurityGroupRuleCallCount() int {
	fake.removeSecurityGroupRuleMutex.RLock()
	defer fake.removeSecurityGroupRuleMutex.RUnlock()
	return len(fake.removeSecurityGroupRuleArgsForCall)
}

func (fake *FakeNetworkManager) RemoveSecurityGroupRuleCalls(stub func(int, int) error) {
	fake.removeSecurityGroupRuleMutex.Lock()
	defer fake.removeSecurityGroupRuleMutex.Unlock()
	fake.RemoveSecurityGroupRuleStub = stub
}

func (fake *FakeNetworkManager) RemoveSecurityGroupRuleArgsForCall(i int) (int, int) {
	fake.removeSecurityGroupRuleMutex.RLock()
	defer fake.removeSecurityGroupRuleMutex.RUnlock()
	argsForCall := fake.removeSecurityGroupRuleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) RemoveSecurityGroupRuleReturns(result1 error) {
	fake.removeSecurityGroupRuleMutex.Lock()
	defer fake.removeSecurityGroupRuleMutex.Unlock()
	fake.RemoveSecurityGroupRuleStub = nil
	fake.removeSecurityGroupRuleReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) RemoveSecurityGroupRuleReturnsOnCall(i int, result1 error) {
	fake.removeSecurityGroupRuleMutex.Lock()
	defer fake.removeSecurityGroupRuleMutex.Unlock()
	fake.RemoveSecurityGroupRuleStub = nil
	if fake.removeSecurityGroupRuleReturnsOnCall == nil {
		fake.removeSecurityGroupRuleReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeSecurityGroupRuleReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) RemoveSecurityGroupRules(arg1 int, arg2 []int) error {
	var arg2Copy []int
	if arg2 != nil {
		arg2Copy = make([]int, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.removeSecurityGroupRulesMutex.Lock()
	ret, specificReturn := fake.removeSecurityGroupRulesReturnsOnCall[len(fake.removeSecurityGroupRulesArgsForCall)]
	fake.removeSecurityGroupRulesArgsForCall = append(fake.removeSecurityGroupRulesArgsForCall, struct {
		arg1 int
		arg2 []int
	}{arg1, arg2Copy})
	stub := fake.RemoveSecurityGroupRulesStub
	fakeReturns := fake.removeSecurityGroupRulesReturns
	fake.recordInvocation("RemoveSecurityGroupRules", []interface{}{arg1, arg2Copy})
	fake.removeSecurityGroupRulesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNetworkManager) RemoveSecurityGroupRulesCallCount() int {
	fake.removeSecurityGroupRulesMutex.RLock()
	defer fake.removeSecurityGroupRulesMutex.RUnlock()
	return len(fake.removeSecurityGroupRulesArgsForCall)
}

func (fake *FakeNetworkManager) RemoveSecurityGroupRulesCalls(stub func(int, []int) error) {
	fake.removeSecurityGroupRulesMutex.Lock()
	defer fake.removeSecurityGroupRulesMutex.Unlock()
	fake.RemoveSecurityGroupRulesStub = stub
}

func (fake *FakeNetworkManager) RemoveSecurityGroupRulesArgsForCall(i int) (int, []int) {
	fake.removeSecurityGroupRulesMutex.RLock()
	defer fake.removeSecurityGroupRulesMutex.RUnlock()
	argsForCall := fake.removeSecurityGroupRulesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) RemoveSecurityGroupRulesReturns(result1 error) {
	fake.removeSecurityGroupRulesMutex.Lock()
	defer fake.removeSecurityGroupRulesMutex.Unlock()
	fake.RemoveSecurityGroupRulesStub = nil
	fake.removeSecurityGroupRulesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) RemoveSecurityGroupRulesReturnsOnCall(i int, result1 error) {
	fake.removeSecurityGroupRulesMutex.Lock()
	defer fake.removeSecurityGroupRulesMutex.Unlock()
	fake.RemoveSecurityGroupRulesStub = nil
	if fake.removeSecurityGroupRulesReturnsOnCall == nil {
		fake.removeSecurityGroupRulesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeSecurityGroupRulesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) Route(arg1 int, arg2 string, arg3 string) (bool, error) {
	fake.routeMutex.Lock()
	ret, specificReturn := fake.routeReturnsOnCall[len(fake.routeArgsForCall)]
	fake.routeArgsForCall = append(fake.routeArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.RouteStub
	fakeReturns := fake.routeReturns
	fake.recordInvocation("Route", []interface{}{arg1, arg2, arg3})
	fake.routeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) RouteCallCount() int {
	fake.routeMutex.RLock()
	defer fake.routeMutex.RUnlock()
	return len(fake.routeArgsForCall)
}

func (fake *FakeNetworkManager) RouteCalls(stub func(int, string, string) (bool, error)) {
	fake.routeMutex.Lock()
	defer fake.routeMutex.Unlock()
	fake.RouteStub = stub
}

func (fake *FakeNetworkManager) RouteArgsForCall(i int) (int, string, string) {
	fake.routeMutex.RLock()
	defer fake.routeMutex.RUnlock()
	argsForCall := fake.routeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeNetworkManager) RouteReturns(result1 bool, result2 error) {
	fake.routeMutex.Lock()
	defer fake.routeMutex.Unlock()
	fake.RouteStub = nil
	fake.routeReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) RouteReturnsOnCall(i int, result1 bool, result2 error) {
	fake.routeMutex.Lock()
	defer fake.routeMutex.Unlock()
	fake.RouteStub = nil
	if fake.routeReturnsOnCall == nil {
		fake.routeReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.routeReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) SetSubnetNote(arg1 int, arg2 string) (bool, error) {
	fake.setSubnetNoteMutex.Lock()
	ret, specificReturn := fake.setSubnetNoteReturnsOnCall[len(fake.setSubnetNoteArgsForCall)]
	fake.setSubnetNoteArgsForCall = append(fake.setSubnetNoteArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.SetSubnetNoteStub
	fakeReturns := fake.setSubnetNoteReturns
	fake.recordInvocation("SetSubnetNote", []interface{}{arg1, arg2})
	fake.setSubnetNoteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) SetSubnetNoteCallCount() int {
	fake.setSubnetNoteMutex.RLock()
	defer fake.setSubnetNoteMutex.RUnlock()
	return len(fake.setSubnetNoteArgsForCall)
}

func (fake *FakeNetworkManager) SetSubnetNoteCalls(stub func(int, string) (bool, error)) {
	fake.setSubnetNoteMutex.Lock()
	defer fake.setSubnetNoteMutex.Unlock()
	fake.SetSubnetNoteStub = stub
}

func (fake *FakeNetworkManager) SetSubnetNoteArgsForCall(i int) (int, string) {
	fake.setSubnetNoteMutex.RLock()
	defer fake.setSubnetNoteMutex.RUnlock()
	argsForCall := fake.setSubnetNoteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) SetSubnetNoteReturns(result1 bool, result2 error) {
	fake.setSubnetNoteMutex.Lock()
	defer fake.setSubnetNoteMutex.Unlock()
	fake.SetSubnetNoteStub = nil
	fake.setSubnetNoteReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) SetSubnetNoteReturnsOnCall(i int, result1 bool, result2 error) {
	fake.setSubnetNoteMutex.Lock()
	defer fake.setSubnetNoteMutex.Unlock()
	fake.SetSubnetNoteStub = nil
	if fake.setSubnetNoteReturnsOnCall == nil {
		fake.setSubnetNoteReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.setSubnetNoteReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) SetSubnetTags(arg1 int, arg2 string) (bool, error) {
	fake.setSubnetTagsMutex.Lock()
	ret, specificReturn := fake.setSubnetTagsReturnsOnCall[len(fake.setSubnetTagsArgsForCall)]
	fake.setSubnetTagsArgsForCall = append(fake.setSubnetTagsArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.SetSubnetTagsStub
	fakeReturns := fake.setSubnetTagsReturns
	fake.recordInvocation("SetSubnetTags", []interface{}{arg1, arg2})
	fake.setSubnetTagsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) SetSubnetTagsCallCount() int {
	fake.setSubnetTagsMutex.RLock()
	defer fake.setSubnetTagsMutex.RUnlock()
	return len(fake.setSubnetTagsArgsForCall)
}

func (fake *FakeNetworkManager) SetSubnetTagsCalls(stub func(int, string) (bool, error)) {
	fake.setSubnetTagsMutex.Lock()
	defer fake.setSubnetTagsMutex.Unlock()
	fake.SetSubnetTagsStub = stub
}

func (fake *FakeNetworkManager) SetSubnetTagsArgsForCall(i int) (int, string) {
	fake.setSubnetTagsMutex.RLock()
	defer fake.setSubnetTagsMutex.RUnlock()
	argsForCall := fake.setSubnetTagsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) SetSubnetTagsReturns(result1 bool, result2 error) {
	fake.setSubnetTagsMutex.Lock()
	defer fake.setSubnetTagsMutex.Unlock()
	fake.SetSubnetTagsStub = nil
	fake.setSubnetTagsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) SetSubnetTagsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.setSubnetTagsMutex.Lock()
	defer fake.setSubnetTagsMutex.Unlock()
	fake.SetSubnetTagsStub = nil
	if fake.setSubnetTagsReturnsOnCall == nil {
		fake.setSubnetTagsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.setSubnetTagsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) UnassignGlobalIP(arg1 int) (bool, error) {
	fake.unassignGlobalIPMutex.Lock()
	ret, specificReturn := fake.unassignGlobalIPReturnsOnCall[len(fake.unassignGlobalIPArgsForCall)]
	fake.unassignGlobalIPArgsForCall = append(fake.unassignGlobalIPArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.UnassignGlobalIPStub
	fakeReturns := fake.unassignGlobalIPReturns
	fake.recordInvocation("UnassignGlobalIP", []interface{}{arg1})
	fake.unassignGlobalIPMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) UnassignGlobalIPCallCount() int {
	fake.unassignGlobalIPMutex.RLock()
	defer fake.unassignGlobalIPMutex.RUnlock()
	return len(fake.unassignGlobalIPArgsForCall)
}

func (fake *FakeNetworkManager) UnassignGlobalIPCalls(stub func(int) (bool, error)) {
	fake.unassignGlobalIPMutex.Lock()
	defer fake.unassignGlobalIPMutex.Unlock()
	fake.UnassignGlobalIPStub = stub
}

func (fake *FakeNetworkManager) UnassignGlobalIPArgsForCall(i int) int {
	fake.unassignGlobalIPMutex.RLock()
	defer fake.unassignGlobalIPMutex.RUnlock()
	argsForCall := fake.unassignGlobalIPArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNetworkManager) UnassignGlobalIPReturns(result1 bool, result2 error) {
	fake.unassignGlobalIPMutex.Lock()
	defer fake.unassignGlobalIPMutex.Unlock()
	fake.UnassignGlobalIPStub = nil
	fake.unassignGlobalIPReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) UnassignGlobalIPReturnsOnCall(i int, result1 bool, result2 error) {
	fake.unassignGlobalIPMutex.Lock()
	defer fake.unassignGlobalIPMutex.Unlock()
	fake.UnassignGlobalIPStub = nil
	if fake.unassignGlobalIPReturnsOnCall == nil {
		fake.unassignGlobalIPReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.unassignGlobalIPReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addGlobalIPMutex.RLock()
	defer fake.addGlobalIPMutex.RUnlock()
	fake.addSecurityGroupRuleMutex.RLock()
	defer fake.addSecurityGroupRuleMutex.RUnlock()
	fake.addSecurityGroupRulesMutex.RLock()
	defer fake.addSecurityGroupRulesMutex.RUnlock()
	fake.addSubnetMutex.RLock()
	defer fake.addSubnetMutex.RUnlock()
	fake.addVlanMutex.RLock()
	defer fake.addVlanMutex.RUnlock()
	fake.assignGlobalIPMutex.RLock()
	defer fake.assignGlobalIPMutex.RUnlock()
	fake.attachSecurityGroupComponentMutex.RLock()
	defer fake.attachSecurityGroupComponentMutex.RUnlock()
	fake.attachSecurityGroupComponentsMutex.RLock()
	defer fake.attachSecurityGroupComponentsMutex.RUnlock()
	fake.cancelGlobalIPMutex.RLock()
	defer fake.cancelGlobalIPMutex.RUnlock()
	fake.cancelSubnetMutex.RLock()
	defer fake.cancelSubnetMutex.RUnlock()
	fake.cancelVLANMutex.RLock()
	defer fake.cancelVLANMutex.RUnlock()
	fake.clearRouteMutex.RLock()
	defer fake.clearRouteMutex.RUnlock()
	fake.createSecurityGroupMutex.RLock()
	defer fake.createSecurityGroupMutex.RUnlock()
	fake.deleteSecurityGroupMutex.RLock()
	defer fake.deleteSecurityGroupMutex.RUnlock()
	fake.detachSecurityGroupComponentMutex.RLock()
	defer fake.detachSecurityGroupComponentMutex.RUnlock()
	fake.detachSecurityGroupComponentsMutex.RLock()
	defer fake.detachSecurityGroupComponentsMutex.RUnlock()
	fake.editSecurityGroupMutex.RLock()
	defer fake.editSecurityGroupMutex.RUnlock()
	fake.editSecurityGroupRuleMutex.RLock()
	defer fake.editSecurityGroupRuleMutex.RUnlock()
	fake.editSecurityGroupRulesMutex.RLock()
	defer fake.editSecurityGroupRulesMutex.RUnlock()
	fake.editSubnetIpAddressMutex.RLock()
	defer fake.editSubnetIpAddressMutex.RUnlock()
	fake.editVlanMutex.RLock()
	defer fake.editVlanMutex.RUnlock()
	fake.getCancelFailureReasonsMutex.RLock()
	defer fake.getCancelFailureReasonsMutex.RUnlock()
	fake.getIpByAddressMutex.RLock()
	defer fake.getIpByAddressMutex.RUnlock()
	fake.getPodsMutex.RLock()
	defer fake.getPodsMutex.RUnlock()
	fake.getRoutersMutex.RLock()
	defer fake.getRoutersMutex.RUnlock()
	fake.getSecurityGroupMutex.RLock()
	defer fake.getSecurityGroupMutex.RUnlock()
	fake.getSubnetMutex.RLock()
	defer fake.getSubnetMutex.RUnlock()
	fake.getVlanMutex.RLock()
	defer fake.getVlanMutex.RUnlock()
	fake.iPLookupMutex.RLock()
	defer fake.iPLookupMutex.RUnlock()
	fake.listDatacentersMutex.RLock()
	defer fake.listDatacentersMutex.RUnlock()
	fake.listGlobalIPsMutex.RLock()
	defer fake.listGlobalIPsMutex.RUnlock()
	fake.listRoutersMutex.RLock()
	defer fake.listRoutersMutex.RUnlock()
	fake.listSecurityGroupRulesMutex.RLock()
	defer fake.listSecurityGroupRulesMutex.RUnlock()
	fake.listSecurityGroupsMutex.RLock()
	defer fake.listSecurityGroupsMutex.RUnlock()
	fake.listSubnetsMutex.RLock()
	defer fake.listSubnetsMutex.RUnlock()
	fake.listVlansMutex.RLock()
	defer fake.listVlansMutex.RUnlock()
	fake.removeSecurityGroupRuleMutex.RLock()
	defer fake.removeSecurityGroupRuleMutex.RUnlock()
	fake.removeSecurityGroupRulesMutex.RLock()
	defer fake.removeSecurityGroupRulesMutex.RUnlock()
	fake.routeMutex.RLock()
	defer fake.routeMutex.RUnlock()
	fake.setSubnetNoteMutex.RLock()
	defer fake.setSubnetNoteMutex.RUnlock()
	fake.setSubnetTagsMutex.RLock()
	defer fake.setSubnetTagsMutex.RUnlock()
	fake.unassignGlobalIPMutex.RLock()
	defer fake.unassignGlobalIPMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeNetworkManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ managers.NetworkManager = new(FakeNetworkManager)
