// Code generated by counterfeiter. DO NOT EDIT.
package testhelpers

import (
	"sync"

	"github.com/softlayer/softlayer-go/datatypes"
	"github.ibm.com/SoftLayer/softlayer-cli/plugin/managers"
)

type FakeNetworkManager struct {
	AddGlobalIPStub        func(int, bool) (datatypes.Container_Product_Order_Receipt, error)
	addGlobalIPMutex       sync.RWMutex
	addGlobalIPArgsForCall []struct {
		arg1 int
		arg2 bool
	}
	addGlobalIPReturns struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	addGlobalIPReturnsOnCall map[int]struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	AddSecurityGroupRuleStub        func(int, string, int, string, string, int, int, string) (datatypes.Network_SecurityGroup_Rule, error)
	addSecurityGroupRuleMutex       sync.RWMutex
	addSecurityGroupRuleArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 int
		arg4 string
		arg5 string
		arg6 int
		arg7 int
		arg8 string
	}
	addSecurityGroupRuleReturns struct {
		result1 datatypes.Network_SecurityGroup_Rule
		result2 error
	}
	addSecurityGroupRuleReturnsOnCall map[int]struct {
		result1 datatypes.Network_SecurityGroup_Rule
		result2 error
	}
	AddSecurityGroupRulesStub        func(int, []datatypes.Network_SecurityGroup_Rule) ([]datatypes.Network_SecurityGroup_Rule, error)
	addSecurityGroupRulesMutex       sync.RWMutex
	addSecurityGroupRulesArgsForCall []struct {
		arg1 int
		arg2 []datatypes.Network_SecurityGroup_Rule
	}
	addSecurityGroupRulesReturns struct {
		result1 []datatypes.Network_SecurityGroup_Rule
		result2 error
	}
	addSecurityGroupRulesReturnsOnCall map[int]struct {
		result1 []datatypes.Network_SecurityGroup_Rule
		result2 error
	}
	AddSubnetStub        func(string, int, int, int, bool) (datatypes.Container_Product_Order_Receipt, error)
	addSubnetMutex       sync.RWMutex
	addSubnetArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
		arg4 int
		arg5 bool
	}
	addSubnetReturns struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	addSubnetReturnsOnCall map[int]struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	AddVlanStub        func(string, string, string, string) (datatypes.Container_Product_Order_Receipt, error)
	addVlanMutex       sync.RWMutex
	addVlanArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}
	addVlanReturns struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	addVlanReturnsOnCall map[int]struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	AssignGlobalIPStub        func(int, string) (datatypes.Provisioning_Version1_Transaction, error)
	assignGlobalIPMutex       sync.RWMutex
	assignGlobalIPArgsForCall []struct {
		arg1 int
		arg2 string
	}
	assignGlobalIPReturns struct {
		result1 datatypes.Provisioning_Version1_Transaction
		result2 error
	}
	assignGlobalIPReturnsOnCall map[int]struct {
		result1 datatypes.Provisioning_Version1_Transaction
		result2 error
	}
	AttachSecurityGroupComponentStub        func(int, int) error
	attachSecurityGroupComponentMutex       sync.RWMutex
	attachSecurityGroupComponentArgsForCall []struct {
		arg1 int
		arg2 int
	}
	attachSecurityGroupComponentReturns struct {
		result1 error
	}
	attachSecurityGroupComponentReturnsOnCall map[int]struct {
		result1 error
	}
	AttachSecurityGroupComponentsStub        func(int, []int) error
	attachSecurityGroupComponentsMutex       sync.RWMutex
	attachSecurityGroupComponentsArgsForCall []struct {
		arg1 int
		arg2 []int
	}
	attachSecurityGroupComponentsReturns struct {
		result1 error
	}
	attachSecurityGroupComponentsReturnsOnCall map[int]struct {
		result1 error
	}
	CancelGlobalIPStub        func(int) error
	cancelGlobalIPMutex       sync.RWMutex
	cancelGlobalIPArgsForCall []struct {
		arg1 int
	}
	cancelGlobalIPReturns struct {
		result1 error
	}
	cancelGlobalIPReturnsOnCall map[int]struct {
		result1 error
	}
	CancelSubnetStub        func(int) error
	cancelSubnetMutex       sync.RWMutex
	cancelSubnetArgsForCall []struct {
		arg1 int
	}
	cancelSubnetReturns struct {
		result1 error
	}
	cancelSubnetReturnsOnCall map[int]struct {
		result1 error
	}
	CancelVLANStub        func(int) error
	cancelVLANMutex       sync.RWMutex
	cancelVLANArgsForCall []struct {
		arg1 int
	}
	cancelVLANReturns struct {
		result1 error
	}
	cancelVLANReturnsOnCall map[int]struct {
		result1 error
	}
	CreateSecurityGroupStub        func(string, string) (datatypes.Network_SecurityGroup, error)
	createSecurityGroupMutex       sync.RWMutex
	createSecurityGroupArgsForCall []struct {
		arg1 string
		arg2 string
	}
	createSecurityGroupReturns struct {
		result1 datatypes.Network_SecurityGroup
		result2 error
	}
	createSecurityGroupReturnsOnCall map[int]struct {
		result1 datatypes.Network_SecurityGroup
		result2 error
	}
	DeleteSecurityGroupStub        func(int) error
	deleteSecurityGroupMutex       sync.RWMutex
	deleteSecurityGroupArgsForCall []struct {
		arg1 int
	}
	deleteSecurityGroupReturns struct {
		result1 error
	}
	deleteSecurityGroupReturnsOnCall map[int]struct {
		result1 error
	}
	DetachSecurityGroupComponentStub        func(int, int) error
	detachSecurityGroupComponentMutex       sync.RWMutex
	detachSecurityGroupComponentArgsForCall []struct {
		arg1 int
		arg2 int
	}
	detachSecurityGroupComponentReturns struct {
		result1 error
	}
	detachSecurityGroupComponentReturnsOnCall map[int]struct {
		result1 error
	}
	DetachSecurityGroupComponentsStub        func(int, []int) error
	detachSecurityGroupComponentsMutex       sync.RWMutex
	detachSecurityGroupComponentsArgsForCall []struct {
		arg1 int
		arg2 []int
	}
	detachSecurityGroupComponentsReturns struct {
		result1 error
	}
	detachSecurityGroupComponentsReturnsOnCall map[int]struct {
		result1 error
	}
	EditSecurityGroupStub        func(int, string, string) error
	editSecurityGroupMutex       sync.RWMutex
	editSecurityGroupArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 string
	}
	editSecurityGroupReturns struct {
		result1 error
	}
	editSecurityGroupReturnsOnCall map[int]struct {
		result1 error
	}
	EditSecurityGroupRuleStub        func(int, int, string, int, string, string, int, int, string) error
	editSecurityGroupRuleMutex       sync.RWMutex
	editSecurityGroupRuleArgsForCall []struct {
		arg1 int
		arg2 int
		arg3 string
		arg4 int
		arg5 string
		arg6 string
		arg7 int
		arg8 int
		arg9 string
	}
	editSecurityGroupRuleReturns struct {
		result1 error
	}
	editSecurityGroupRuleReturnsOnCall map[int]struct {
		result1 error
	}
	EditSecurityGroupRulesStub        func(int, []datatypes.Network_SecurityGroup_Rule) error
	editSecurityGroupRulesMutex       sync.RWMutex
	editSecurityGroupRulesArgsForCall []struct {
		arg1 int
		arg2 []datatypes.Network_SecurityGroup_Rule
	}
	editSecurityGroupRulesReturns struct {
		result1 error
	}
	editSecurityGroupRulesReturnsOnCall map[int]struct {
		result1 error
	}
	EditVlanStub        func(int, string) error
	editVlanMutex       sync.RWMutex
	editVlanArgsForCall []struct {
		arg1 int
		arg2 string
	}
	editVlanReturns struct {
		result1 error
	}
	editVlanReturnsOnCall map[int]struct {
		result1 error
	}
	GetSecurityGroupStub        func(int, string) (datatypes.Network_SecurityGroup, error)
	getSecurityGroupMutex       sync.RWMutex
	getSecurityGroupArgsForCall []struct {
		arg1 int
		arg2 string
	}
	getSecurityGroupReturns struct {
		result1 datatypes.Network_SecurityGroup
		result2 error
	}
	getSecurityGroupReturnsOnCall map[int]struct {
		result1 datatypes.Network_SecurityGroup
		result2 error
	}
	GetSubnetStub        func(int, string) (datatypes.Network_Subnet, error)
	getSubnetMutex       sync.RWMutex
	getSubnetArgsForCall []struct {
		arg1 int
		arg2 string
	}
	getSubnetReturns struct {
		result1 datatypes.Network_Subnet
		result2 error
	}
	getSubnetReturnsOnCall map[int]struct {
		result1 datatypes.Network_Subnet
		result2 error
	}
	GetVlanStub        func(int, string) (datatypes.Network_Vlan, error)
	getVlanMutex       sync.RWMutex
	getVlanArgsForCall []struct {
		arg1 int
		arg2 string
	}
	getVlanReturns struct {
		result1 datatypes.Network_Vlan
		result2 error
	}
	getVlanReturnsOnCall map[int]struct {
		result1 datatypes.Network_Vlan
		result2 error
	}
	IPLookupStub        func(string) (datatypes.Network_Subnet_IpAddress, error)
	iPLookupMutex       sync.RWMutex
	iPLookupArgsForCall []struct {
		arg1 string
	}
	iPLookupReturns struct {
		result1 datatypes.Network_Subnet_IpAddress
		result2 error
	}
	iPLookupReturnsOnCall map[int]struct {
		result1 datatypes.Network_Subnet_IpAddress
		result2 error
	}
	ListDatacentersStub        func() (map[int]string, error)
	listDatacentersMutex       sync.RWMutex
	listDatacentersArgsForCall []struct {
	}
	listDatacentersReturns struct {
		result1 map[int]string
		result2 error
	}
	listDatacentersReturnsOnCall map[int]struct {
		result1 map[int]string
		result2 error
	}
	ListGlobalIPsStub        func(int, int) ([]datatypes.Network_Subnet_IpAddress_Global, error)
	listGlobalIPsMutex       sync.RWMutex
	listGlobalIPsArgsForCall []struct {
		arg1 int
		arg2 int
	}
	listGlobalIPsReturns struct {
		result1 []datatypes.Network_Subnet_IpAddress_Global
		result2 error
	}
	listGlobalIPsReturnsOnCall map[int]struct {
		result1 []datatypes.Network_Subnet_IpAddress_Global
		result2 error
	}
	ListRoutersStub        func(int, string) ([]string, error)
	listRoutersMutex       sync.RWMutex
	listRoutersArgsForCall []struct {
		arg1 int
		arg2 string
	}
	listRoutersReturns struct {
		result1 []string
		result2 error
	}
	listRoutersReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	ListSecurityGroupRulesStub        func(int) ([]datatypes.Network_SecurityGroup_Rule, error)
	listSecurityGroupRulesMutex       sync.RWMutex
	listSecurityGroupRulesArgsForCall []struct {
		arg1 int
	}
	listSecurityGroupRulesReturns struct {
		result1 []datatypes.Network_SecurityGroup_Rule
		result2 error
	}
	listSecurityGroupRulesReturnsOnCall map[int]struct {
		result1 []datatypes.Network_SecurityGroup_Rule
		result2 error
	}
	ListSecurityGroupsStub        func() ([]datatypes.Network_SecurityGroup, error)
	listSecurityGroupsMutex       sync.RWMutex
	listSecurityGroupsArgsForCall []struct {
	}
	listSecurityGroupsReturns struct {
		result1 []datatypes.Network_SecurityGroup
		result2 error
	}
	listSecurityGroupsReturnsOnCall map[int]struct {
		result1 []datatypes.Network_SecurityGroup
		result2 error
	}
	ListSubnetsStub        func(string, string, int, string, string, int, string) ([]datatypes.Network_Subnet, error)
	listSubnetsMutex       sync.RWMutex
	listSubnetsArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 int
		arg4 string
		arg5 string
		arg6 int
		arg7 string
	}
	listSubnetsReturns struct {
		result1 []datatypes.Network_Subnet
		result2 error
	}
	listSubnetsReturnsOnCall map[int]struct {
		result1 []datatypes.Network_Subnet
		result2 error
	}
	ListVlansStub        func(string, int, string, int, string) ([]datatypes.Network_Vlan, error)
	listVlansMutex       sync.RWMutex
	listVlansArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 string
		arg4 int
		arg5 string
	}
	listVlansReturns struct {
		result1 []datatypes.Network_Vlan
		result2 error
	}
	listVlansReturnsOnCall map[int]struct {
		result1 []datatypes.Network_Vlan
		result2 error
	}
	RemoveSecurityGroupRuleStub        func(int, int) error
	removeSecurityGroupRuleMutex       sync.RWMutex
	removeSecurityGroupRuleArgsForCall []struct {
		arg1 int
		arg2 int
	}
	removeSecurityGroupRuleReturns struct {
		result1 error
	}
	removeSecurityGroupRuleReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveSecurityGroupRulesStub        func(int, []int) error
	removeSecurityGroupRulesMutex       sync.RWMutex
	removeSecurityGroupRulesArgsForCall []struct {
		arg1 int
		arg2 []int
	}
	removeSecurityGroupRulesReturns struct {
		result1 error
	}
	removeSecurityGroupRulesReturnsOnCall map[int]struct {
		result1 error
	}
	UnassignGlobalIPStub        func(int) (datatypes.Provisioning_Version1_Transaction, error)
	unassignGlobalIPMutex       sync.RWMutex
	unassignGlobalIPArgsForCall []struct {
		arg1 int
	}
	unassignGlobalIPReturns struct {
		result1 datatypes.Provisioning_Version1_Transaction
		result2 error
	}
	unassignGlobalIPReturnsOnCall map[int]struct {
		result1 datatypes.Provisioning_Version1_Transaction
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeNetworkManager) AddGlobalIP(arg1 int, arg2 bool) (datatypes.Container_Product_Order_Receipt, error) {
	fake.addGlobalIPMutex.Lock()
	ret, specificReturn := fake.addGlobalIPReturnsOnCall[len(fake.addGlobalIPArgsForCall)]
	fake.addGlobalIPArgsForCall = append(fake.addGlobalIPArgsForCall, struct {
		arg1 int
		arg2 bool
	}{arg1, arg2})
	fake.recordInvocation("AddGlobalIP", []interface{}{arg1, arg2})
	fake.addGlobalIPMutex.Unlock()
	if fake.AddGlobalIPStub != nil {
		return fake.AddGlobalIPStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.addGlobalIPReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) AddGlobalIPCallCount() int {
	fake.addGlobalIPMutex.RLock()
	defer fake.addGlobalIPMutex.RUnlock()
	return len(fake.addGlobalIPArgsForCall)
}

func (fake *FakeNetworkManager) AddGlobalIPCalls(stub func(int, bool) (datatypes.Container_Product_Order_Receipt, error)) {
	fake.addGlobalIPMutex.Lock()
	defer fake.addGlobalIPMutex.Unlock()
	fake.AddGlobalIPStub = stub
}

func (fake *FakeNetworkManager) AddGlobalIPArgsForCall(i int) (int, bool) {
	fake.addGlobalIPMutex.RLock()
	defer fake.addGlobalIPMutex.RUnlock()
	argsForCall := fake.addGlobalIPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) AddGlobalIPReturns(result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.addGlobalIPMutex.Lock()
	defer fake.addGlobalIPMutex.Unlock()
	fake.AddGlobalIPStub = nil
	fake.addGlobalIPReturns = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) AddGlobalIPReturnsOnCall(i int, result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.addGlobalIPMutex.Lock()
	defer fake.addGlobalIPMutex.Unlock()
	fake.AddGlobalIPStub = nil
	if fake.addGlobalIPReturnsOnCall == nil {
		fake.addGlobalIPReturnsOnCall = make(map[int]struct {
			result1 datatypes.Container_Product_Order_Receipt
			result2 error
		})
	}
	fake.addGlobalIPReturnsOnCall[i] = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) AddSecurityGroupRule(arg1 int, arg2 string, arg3 int, arg4 string, arg5 string, arg6 int, arg7 int, arg8 string) (datatypes.Network_SecurityGroup_Rule, error) {
	fake.addSecurityGroupRuleMutex.Lock()
	ret, specificReturn := fake.addSecurityGroupRuleReturnsOnCall[len(fake.addSecurityGroupRuleArgsForCall)]
	fake.addSecurityGroupRuleArgsForCall = append(fake.addSecurityGroupRuleArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 int
		arg4 string
		arg5 string
		arg6 int
		arg7 int
		arg8 string
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8})
	fake.recordInvocation("AddSecurityGroupRule", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8})
	fake.addSecurityGroupRuleMutex.Unlock()
	if fake.AddSecurityGroupRuleStub != nil {
		return fake.AddSecurityGroupRuleStub(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.addSecurityGroupRuleReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) AddSecurityGroupRuleCallCount() int {
	fake.addSecurityGroupRuleMutex.RLock()
	defer fake.addSecurityGroupRuleMutex.RUnlock()
	return len(fake.addSecurityGroupRuleArgsForCall)
}

func (fake *FakeNetworkManager) AddSecurityGroupRuleCalls(stub func(int, string, int, string, string, int, int, string) (datatypes.Network_SecurityGroup_Rule, error)) {
	fake.addSecurityGroupRuleMutex.Lock()
	defer fake.addSecurityGroupRuleMutex.Unlock()
	fake.AddSecurityGroupRuleStub = stub
}

func (fake *FakeNetworkManager) AddSecurityGroupRuleArgsForCall(i int) (int, string, int, string, string, int, int, string) {
	fake.addSecurityGroupRuleMutex.RLock()
	defer fake.addSecurityGroupRuleMutex.RUnlock()
	argsForCall := fake.addSecurityGroupRuleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7, argsForCall.arg8
}

func (fake *FakeNetworkManager) AddSecurityGroupRuleReturns(result1 datatypes.Network_SecurityGroup_Rule, result2 error) {
	fake.addSecurityGroupRuleMutex.Lock()
	defer fake.addSecurityGroupRuleMutex.Unlock()
	fake.AddSecurityGroupRuleStub = nil
	fake.addSecurityGroupRuleReturns = struct {
		result1 datatypes.Network_SecurityGroup_Rule
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) AddSecurityGroupRuleReturnsOnCall(i int, result1 datatypes.Network_SecurityGroup_Rule, result2 error) {
	fake.addSecurityGroupRuleMutex.Lock()
	defer fake.addSecurityGroupRuleMutex.Unlock()
	fake.AddSecurityGroupRuleStub = nil
	if fake.addSecurityGroupRuleReturnsOnCall == nil {
		fake.addSecurityGroupRuleReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_SecurityGroup_Rule
			result2 error
		})
	}
	fake.addSecurityGroupRuleReturnsOnCall[i] = struct {
		result1 datatypes.Network_SecurityGroup_Rule
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) AddSecurityGroupRules(arg1 int, arg2 []datatypes.Network_SecurityGroup_Rule) ([]datatypes.Network_SecurityGroup_Rule, error) {
	var arg2Copy []datatypes.Network_SecurityGroup_Rule
	if arg2 != nil {
		arg2Copy = make([]datatypes.Network_SecurityGroup_Rule, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.addSecurityGroupRulesMutex.Lock()
	ret, specificReturn := fake.addSecurityGroupRulesReturnsOnCall[len(fake.addSecurityGroupRulesArgsForCall)]
	fake.addSecurityGroupRulesArgsForCall = append(fake.addSecurityGroupRulesArgsForCall, struct {
		arg1 int
		arg2 []datatypes.Network_SecurityGroup_Rule
	}{arg1, arg2Copy})
	fake.recordInvocation("AddSecurityGroupRules", []interface{}{arg1, arg2Copy})
	fake.addSecurityGroupRulesMutex.Unlock()
	if fake.AddSecurityGroupRulesStub != nil {
		return fake.AddSecurityGroupRulesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.addSecurityGroupRulesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) AddSecurityGroupRulesCallCount() int {
	fake.addSecurityGroupRulesMutex.RLock()
	defer fake.addSecurityGroupRulesMutex.RUnlock()
	return len(fake.addSecurityGroupRulesArgsForCall)
}

func (fake *FakeNetworkManager) AddSecurityGroupRulesCalls(stub func(int, []datatypes.Network_SecurityGroup_Rule) ([]datatypes.Network_SecurityGroup_Rule, error)) {
	fake.addSecurityGroupRulesMutex.Lock()
	defer fake.addSecurityGroupRulesMutex.Unlock()
	fake.AddSecurityGroupRulesStub = stub
}

func (fake *FakeNetworkManager) AddSecurityGroupRulesArgsForCall(i int) (int, []datatypes.Network_SecurityGroup_Rule) {
	fake.addSecurityGroupRulesMutex.RLock()
	defer fake.addSecurityGroupRulesMutex.RUnlock()
	argsForCall := fake.addSecurityGroupRulesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) AddSecurityGroupRulesReturns(result1 []datatypes.Network_SecurityGroup_Rule, result2 error) {
	fake.addSecurityGroupRulesMutex.Lock()
	defer fake.addSecurityGroupRulesMutex.Unlock()
	fake.AddSecurityGroupRulesStub = nil
	fake.addSecurityGroupRulesReturns = struct {
		result1 []datatypes.Network_SecurityGroup_Rule
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) AddSecurityGroupRulesReturnsOnCall(i int, result1 []datatypes.Network_SecurityGroup_Rule, result2 error) {
	fake.addSecurityGroupRulesMutex.Lock()
	defer fake.addSecurityGroupRulesMutex.Unlock()
	fake.AddSecurityGroupRulesStub = nil
	if fake.addSecurityGroupRulesReturnsOnCall == nil {
		fake.addSecurityGroupRulesReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Network_SecurityGroup_Rule
			result2 error
		})
	}
	fake.addSecurityGroupRulesReturnsOnCall[i] = struct {
		result1 []datatypes.Network_SecurityGroup_Rule
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) AddSubnet(arg1 string, arg2 int, arg3 int, arg4 int, arg5 bool) (datatypes.Container_Product_Order_Receipt, error) {
	fake.addSubnetMutex.Lock()
	ret, specificReturn := fake.addSubnetReturnsOnCall[len(fake.addSubnetArgsForCall)]
	fake.addSubnetArgsForCall = append(fake.addSubnetArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
		arg4 int
		arg5 bool
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("AddSubnet", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.addSubnetMutex.Unlock()
	if fake.AddSubnetStub != nil {
		return fake.AddSubnetStub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.addSubnetReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) AddSubnetCallCount() int {
	fake.addSubnetMutex.RLock()
	defer fake.addSubnetMutex.RUnlock()
	return len(fake.addSubnetArgsForCall)
}

func (fake *FakeNetworkManager) AddSubnetCalls(stub func(string, int, int, int, bool) (datatypes.Container_Product_Order_Receipt, error)) {
	fake.addSubnetMutex.Lock()
	defer fake.addSubnetMutex.Unlock()
	fake.AddSubnetStub = stub
}

func (fake *FakeNetworkManager) AddSubnetArgsForCall(i int) (string, int, int, int, bool) {
	fake.addSubnetMutex.RLock()
	defer fake.addSubnetMutex.RUnlock()
	argsForCall := fake.addSubnetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeNetworkManager) AddSubnetReturns(result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.addSubnetMutex.Lock()
	defer fake.addSubnetMutex.Unlock()
	fake.AddSubnetStub = nil
	fake.addSubnetReturns = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) AddSubnetReturnsOnCall(i int, result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.addSubnetMutex.Lock()
	defer fake.addSubnetMutex.Unlock()
	fake.AddSubnetStub = nil
	if fake.addSubnetReturnsOnCall == nil {
		fake.addSubnetReturnsOnCall = make(map[int]struct {
			result1 datatypes.Container_Product_Order_Receipt
			result2 error
		})
	}
	fake.addSubnetReturnsOnCall[i] = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) AddVlan(arg1 string, arg2 string, arg3 string, arg4 string) (datatypes.Container_Product_Order_Receipt, error) {
	fake.addVlanMutex.Lock()
	ret, specificReturn := fake.addVlanReturnsOnCall[len(fake.addVlanArgsForCall)]
	fake.addVlanArgsForCall = append(fake.addVlanArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("AddVlan", []interface{}{arg1, arg2, arg3, arg4})
	fake.addVlanMutex.Unlock()
	if fake.AddVlanStub != nil {
		return fake.AddVlanStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.addVlanReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) AddVlanCallCount() int {
	fake.addVlanMutex.RLock()
	defer fake.addVlanMutex.RUnlock()
	return len(fake.addVlanArgsForCall)
}

func (fake *FakeNetworkManager) AddVlanCalls(stub func(string, string, string, string) (datatypes.Container_Product_Order_Receipt, error)) {
	fake.addVlanMutex.Lock()
	defer fake.addVlanMutex.Unlock()
	fake.AddVlanStub = stub
}

func (fake *FakeNetworkManager) AddVlanArgsForCall(i int) (string, string, string, string) {
	fake.addVlanMutex.RLock()
	defer fake.addVlanMutex.RUnlock()
	argsForCall := fake.addVlanArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeNetworkManager) AddVlanReturns(result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.addVlanMutex.Lock()
	defer fake.addVlanMutex.Unlock()
	fake.AddVlanStub = nil
	fake.addVlanReturns = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) AddVlanReturnsOnCall(i int, result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.addVlanMutex.Lock()
	defer fake.addVlanMutex.Unlock()
	fake.AddVlanStub = nil
	if fake.addVlanReturnsOnCall == nil {
		fake.addVlanReturnsOnCall = make(map[int]struct {
			result1 datatypes.Container_Product_Order_Receipt
			result2 error
		})
	}
	fake.addVlanReturnsOnCall[i] = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) AssignGlobalIP(arg1 int, arg2 string) (datatypes.Provisioning_Version1_Transaction, error) {
	fake.assignGlobalIPMutex.Lock()
	ret, specificReturn := fake.assignGlobalIPReturnsOnCall[len(fake.assignGlobalIPArgsForCall)]
	fake.assignGlobalIPArgsForCall = append(fake.assignGlobalIPArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("AssignGlobalIP", []interface{}{arg1, arg2})
	fake.assignGlobalIPMutex.Unlock()
	if fake.AssignGlobalIPStub != nil {
		return fake.AssignGlobalIPStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.assignGlobalIPReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) AssignGlobalIPCallCount() int {
	fake.assignGlobalIPMutex.RLock()
	defer fake.assignGlobalIPMutex.RUnlock()
	return len(fake.assignGlobalIPArgsForCall)
}

func (fake *FakeNetworkManager) AssignGlobalIPCalls(stub func(int, string) (datatypes.Provisioning_Version1_Transaction, error)) {
	fake.assignGlobalIPMutex.Lock()
	defer fake.assignGlobalIPMutex.Unlock()
	fake.AssignGlobalIPStub = stub
}

func (fake *FakeNetworkManager) AssignGlobalIPArgsForCall(i int) (int, string) {
	fake.assignGlobalIPMutex.RLock()
	defer fake.assignGlobalIPMutex.RUnlock()
	argsForCall := fake.assignGlobalIPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) AssignGlobalIPReturns(result1 datatypes.Provisioning_Version1_Transaction, result2 error) {
	fake.assignGlobalIPMutex.Lock()
	defer fake.assignGlobalIPMutex.Unlock()
	fake.AssignGlobalIPStub = nil
	fake.assignGlobalIPReturns = struct {
		result1 datatypes.Provisioning_Version1_Transaction
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) AssignGlobalIPReturnsOnCall(i int, result1 datatypes.Provisioning_Version1_Transaction, result2 error) {
	fake.assignGlobalIPMutex.Lock()
	defer fake.assignGlobalIPMutex.Unlock()
	fake.AssignGlobalIPStub = nil
	if fake.assignGlobalIPReturnsOnCall == nil {
		fake.assignGlobalIPReturnsOnCall = make(map[int]struct {
			result1 datatypes.Provisioning_Version1_Transaction
			result2 error
		})
	}
	fake.assignGlobalIPReturnsOnCall[i] = struct {
		result1 datatypes.Provisioning_Version1_Transaction
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) AttachSecurityGroupComponent(arg1 int, arg2 int) error {
	fake.attachSecurityGroupComponentMutex.Lock()
	ret, specificReturn := fake.attachSecurityGroupComponentReturnsOnCall[len(fake.attachSecurityGroupComponentArgsForCall)]
	fake.attachSecurityGroupComponentArgsForCall = append(fake.attachSecurityGroupComponentArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("AttachSecurityGroupComponent", []interface{}{arg1, arg2})
	fake.attachSecurityGroupComponentMutex.Unlock()
	if fake.AttachSecurityGroupComponentStub != nil {
		return fake.AttachSecurityGroupComponentStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.attachSecurityGroupComponentReturns
	return fakeReturns.result1
}

func (fake *FakeNetworkManager) AttachSecurityGroupComponentCallCount() int {
	fake.attachSecurityGroupComponentMutex.RLock()
	defer fake.attachSecurityGroupComponentMutex.RUnlock()
	return len(fake.attachSecurityGroupComponentArgsForCall)
}

func (fake *FakeNetworkManager) AttachSecurityGroupComponentCalls(stub func(int, int) error) {
	fake.attachSecurityGroupComponentMutex.Lock()
	defer fake.attachSecurityGroupComponentMutex.Unlock()
	fake.AttachSecurityGroupComponentStub = stub
}

func (fake *FakeNetworkManager) AttachSecurityGroupComponentArgsForCall(i int) (int, int) {
	fake.attachSecurityGroupComponentMutex.RLock()
	defer fake.attachSecurityGroupComponentMutex.RUnlock()
	argsForCall := fake.attachSecurityGroupComponentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) AttachSecurityGroupComponentReturns(result1 error) {
	fake.attachSecurityGroupComponentMutex.Lock()
	defer fake.attachSecurityGroupComponentMutex.Unlock()
	fake.AttachSecurityGroupComponentStub = nil
	fake.attachSecurityGroupComponentReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) AttachSecurityGroupComponentReturnsOnCall(i int, result1 error) {
	fake.attachSecurityGroupComponentMutex.Lock()
	defer fake.attachSecurityGroupComponentMutex.Unlock()
	fake.AttachSecurityGroupComponentStub = nil
	if fake.attachSecurityGroupComponentReturnsOnCall == nil {
		fake.attachSecurityGroupComponentReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.attachSecurityGroupComponentReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) AttachSecurityGroupComponents(arg1 int, arg2 []int) error {
	var arg2Copy []int
	if arg2 != nil {
		arg2Copy = make([]int, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.attachSecurityGroupComponentsMutex.Lock()
	ret, specificReturn := fake.attachSecurityGroupComponentsReturnsOnCall[len(fake.attachSecurityGroupComponentsArgsForCall)]
	fake.attachSecurityGroupComponentsArgsForCall = append(fake.attachSecurityGroupComponentsArgsForCall, struct {
		arg1 int
		arg2 []int
	}{arg1, arg2Copy})
	fake.recordInvocation("AttachSecurityGroupComponents", []interface{}{arg1, arg2Copy})
	fake.attachSecurityGroupComponentsMutex.Unlock()
	if fake.AttachSecurityGroupComponentsStub != nil {
		return fake.AttachSecurityGroupComponentsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.attachSecurityGroupComponentsReturns
	return fakeReturns.result1
}

func (fake *FakeNetworkManager) AttachSecurityGroupComponentsCallCount() int {
	fake.attachSecurityGroupComponentsMutex.RLock()
	defer fake.attachSecurityGroupComponentsMutex.RUnlock()
	return len(fake.attachSecurityGroupComponentsArgsForCall)
}

func (fake *FakeNetworkManager) AttachSecurityGroupComponentsCalls(stub func(int, []int) error) {
	fake.attachSecurityGroupComponentsMutex.Lock()
	defer fake.attachSecurityGroupComponentsMutex.Unlock()
	fake.AttachSecurityGroupComponentsStub = stub
}

func (fake *FakeNetworkManager) AttachSecurityGroupComponentsArgsForCall(i int) (int, []int) {
	fake.attachSecurityGroupComponentsMutex.RLock()
	defer fake.attachSecurityGroupComponentsMutex.RUnlock()
	argsForCall := fake.attachSecurityGroupComponentsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) AttachSecurityGroupComponentsReturns(result1 error) {
	fake.attachSecurityGroupComponentsMutex.Lock()
	defer fake.attachSecurityGroupComponentsMutex.Unlock()
	fake.AttachSecurityGroupComponentsStub = nil
	fake.attachSecurityGroupComponentsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) AttachSecurityGroupComponentsReturnsOnCall(i int, result1 error) {
	fake.attachSecurityGroupComponentsMutex.Lock()
	defer fake.attachSecurityGroupComponentsMutex.Unlock()
	fake.AttachSecurityGroupComponentsStub = nil
	if fake.attachSecurityGroupComponentsReturnsOnCall == nil {
		fake.attachSecurityGroupComponentsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.attachSecurityGroupComponentsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) CancelGlobalIP(arg1 int) error {
	fake.cancelGlobalIPMutex.Lock()
	ret, specificReturn := fake.cancelGlobalIPReturnsOnCall[len(fake.cancelGlobalIPArgsForCall)]
	fake.cancelGlobalIPArgsForCall = append(fake.cancelGlobalIPArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("CancelGlobalIP", []interface{}{arg1})
	fake.cancelGlobalIPMutex.Unlock()
	if fake.CancelGlobalIPStub != nil {
		return fake.CancelGlobalIPStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.cancelGlobalIPReturns
	return fakeReturns.result1
}

func (fake *FakeNetworkManager) CancelGlobalIPCallCount() int {
	fake.cancelGlobalIPMutex.RLock()
	defer fake.cancelGlobalIPMutex.RUnlock()
	return len(fake.cancelGlobalIPArgsForCall)
}

func (fake *FakeNetworkManager) CancelGlobalIPCalls(stub func(int) error) {
	fake.cancelGlobalIPMutex.Lock()
	defer fake.cancelGlobalIPMutex.Unlock()
	fake.CancelGlobalIPStub = stub
}

func (fake *FakeNetworkManager) CancelGlobalIPArgsForCall(i int) int {
	fake.cancelGlobalIPMutex.RLock()
	defer fake.cancelGlobalIPMutex.RUnlock()
	argsForCall := fake.cancelGlobalIPArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNetworkManager) CancelGlobalIPReturns(result1 error) {
	fake.cancelGlobalIPMutex.Lock()
	defer fake.cancelGlobalIPMutex.Unlock()
	fake.CancelGlobalIPStub = nil
	fake.cancelGlobalIPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) CancelGlobalIPReturnsOnCall(i int, result1 error) {
	fake.cancelGlobalIPMutex.Lock()
	defer fake.cancelGlobalIPMutex.Unlock()
	fake.CancelGlobalIPStub = nil
	if fake.cancelGlobalIPReturnsOnCall == nil {
		fake.cancelGlobalIPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelGlobalIPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) CancelSubnet(arg1 int) error {
	fake.cancelSubnetMutex.Lock()
	ret, specificReturn := fake.cancelSubnetReturnsOnCall[len(fake.cancelSubnetArgsForCall)]
	fake.cancelSubnetArgsForCall = append(fake.cancelSubnetArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("CancelSubnet", []interface{}{arg1})
	fake.cancelSubnetMutex.Unlock()
	if fake.CancelSubnetStub != nil {
		return fake.CancelSubnetStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.cancelSubnetReturns
	return fakeReturns.result1
}

func (fake *FakeNetworkManager) CancelSubnetCallCount() int {
	fake.cancelSubnetMutex.RLock()
	defer fake.cancelSubnetMutex.RUnlock()
	return len(fake.cancelSubnetArgsForCall)
}

func (fake *FakeNetworkManager) CancelSubnetCalls(stub func(int) error) {
	fake.cancelSubnetMutex.Lock()
	defer fake.cancelSubnetMutex.Unlock()
	fake.CancelSubnetStub = stub
}

func (fake *FakeNetworkManager) CancelSubnetArgsForCall(i int) int {
	fake.cancelSubnetMutex.RLock()
	defer fake.cancelSubnetMutex.RUnlock()
	argsForCall := fake.cancelSubnetArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNetworkManager) CancelSubnetReturns(result1 error) {
	fake.cancelSubnetMutex.Lock()
	defer fake.cancelSubnetMutex.Unlock()
	fake.CancelSubnetStub = nil
	fake.cancelSubnetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) CancelSubnetReturnsOnCall(i int, result1 error) {
	fake.cancelSubnetMutex.Lock()
	defer fake.cancelSubnetMutex.Unlock()
	fake.CancelSubnetStub = nil
	if fake.cancelSubnetReturnsOnCall == nil {
		fake.cancelSubnetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelSubnetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) CancelVLAN(arg1 int) error {
	fake.cancelVLANMutex.Lock()
	ret, specificReturn := fake.cancelVLANReturnsOnCall[len(fake.cancelVLANArgsForCall)]
	fake.cancelVLANArgsForCall = append(fake.cancelVLANArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("CancelVLAN", []interface{}{arg1})
	fake.cancelVLANMutex.Unlock()
	if fake.CancelVLANStub != nil {
		return fake.CancelVLANStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.cancelVLANReturns
	return fakeReturns.result1
}

func (fake *FakeNetworkManager) CancelVLANCallCount() int {
	fake.cancelVLANMutex.RLock()
	defer fake.cancelVLANMutex.RUnlock()
	return len(fake.cancelVLANArgsForCall)
}

func (fake *FakeNetworkManager) CancelVLANCalls(stub func(int) error) {
	fake.cancelVLANMutex.Lock()
	defer fake.cancelVLANMutex.Unlock()
	fake.CancelVLANStub = stub
}

func (fake *FakeNetworkManager) CancelVLANArgsForCall(i int) int {
	fake.cancelVLANMutex.RLock()
	defer fake.cancelVLANMutex.RUnlock()
	argsForCall := fake.cancelVLANArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNetworkManager) CancelVLANReturns(result1 error) {
	fake.cancelVLANMutex.Lock()
	defer fake.cancelVLANMutex.Unlock()
	fake.CancelVLANStub = nil
	fake.cancelVLANReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) CancelVLANReturnsOnCall(i int, result1 error) {
	fake.cancelVLANMutex.Lock()
	defer fake.cancelVLANMutex.Unlock()
	fake.CancelVLANStub = nil
	if fake.cancelVLANReturnsOnCall == nil {
		fake.cancelVLANReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelVLANReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) CreateSecurityGroup(arg1 string, arg2 string) (datatypes.Network_SecurityGroup, error) {
	fake.createSecurityGroupMutex.Lock()
	ret, specificReturn := fake.createSecurityGroupReturnsOnCall[len(fake.createSecurityGroupArgsForCall)]
	fake.createSecurityGroupArgsForCall = append(fake.createSecurityGroupArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("CreateSecurityGroup", []interface{}{arg1, arg2})
	fake.createSecurityGroupMutex.Unlock()
	if fake.CreateSecurityGroupStub != nil {
		return fake.CreateSecurityGroupStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createSecurityGroupReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) CreateSecurityGroupCallCount() int {
	fake.createSecurityGroupMutex.RLock()
	defer fake.createSecurityGroupMutex.RUnlock()
	return len(fake.createSecurityGroupArgsForCall)
}

func (fake *FakeNetworkManager) CreateSecurityGroupCalls(stub func(string, string) (datatypes.Network_SecurityGroup, error)) {
	fake.createSecurityGroupMutex.Lock()
	defer fake.createSecurityGroupMutex.Unlock()
	fake.CreateSecurityGroupStub = stub
}

func (fake *FakeNetworkManager) CreateSecurityGroupArgsForCall(i int) (string, string) {
	fake.createSecurityGroupMutex.RLock()
	defer fake.createSecurityGroupMutex.RUnlock()
	argsForCall := fake.createSecurityGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) CreateSecurityGroupReturns(result1 datatypes.Network_SecurityGroup, result2 error) {
	fake.createSecurityGroupMutex.Lock()
	defer fake.createSecurityGroupMutex.Unlock()
	fake.CreateSecurityGroupStub = nil
	fake.createSecurityGroupReturns = struct {
		result1 datatypes.Network_SecurityGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) CreateSecurityGroupReturnsOnCall(i int, result1 datatypes.Network_SecurityGroup, result2 error) {
	fake.createSecurityGroupMutex.Lock()
	defer fake.createSecurityGroupMutex.Unlock()
	fake.CreateSecurityGroupStub = nil
	if fake.createSecurityGroupReturnsOnCall == nil {
		fake.createSecurityGroupReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_SecurityGroup
			result2 error
		})
	}
	fake.createSecurityGroupReturnsOnCall[i] = struct {
		result1 datatypes.Network_SecurityGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) DeleteSecurityGroup(arg1 int) error {
	fake.deleteSecurityGroupMutex.Lock()
	ret, specificReturn := fake.deleteSecurityGroupReturnsOnCall[len(fake.deleteSecurityGroupArgsForCall)]
	fake.deleteSecurityGroupArgsForCall = append(fake.deleteSecurityGroupArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("DeleteSecurityGroup", []interface{}{arg1})
	fake.deleteSecurityGroupMutex.Unlock()
	if fake.DeleteSecurityGroupStub != nil {
		return fake.DeleteSecurityGroupStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteSecurityGroupReturns
	return fakeReturns.result1
}

func (fake *FakeNetworkManager) DeleteSecurityGroupCallCount() int {
	fake.deleteSecurityGroupMutex.RLock()
	defer fake.deleteSecurityGroupMutex.RUnlock()
	return len(fake.deleteSecurityGroupArgsForCall)
}

func (fake *FakeNetworkManager) DeleteSecurityGroupCalls(stub func(int) error) {
	fake.deleteSecurityGroupMutex.Lock()
	defer fake.deleteSecurityGroupMutex.Unlock()
	fake.DeleteSecurityGroupStub = stub
}

func (fake *FakeNetworkManager) DeleteSecurityGroupArgsForCall(i int) int {
	fake.deleteSecurityGroupMutex.RLock()
	defer fake.deleteSecurityGroupMutex.RUnlock()
	argsForCall := fake.deleteSecurityGroupArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNetworkManager) DeleteSecurityGroupReturns(result1 error) {
	fake.deleteSecurityGroupMutex.Lock()
	defer fake.deleteSecurityGroupMutex.Unlock()
	fake.DeleteSecurityGroupStub = nil
	fake.deleteSecurityGroupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) DeleteSecurityGroupReturnsOnCall(i int, result1 error) {
	fake.deleteSecurityGroupMutex.Lock()
	defer fake.deleteSecurityGroupMutex.Unlock()
	fake.DeleteSecurityGroupStub = nil
	if fake.deleteSecurityGroupReturnsOnCall == nil {
		fake.deleteSecurityGroupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteSecurityGroupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) DetachSecurityGroupComponent(arg1 int, arg2 int) error {
	fake.detachSecurityGroupComponentMutex.Lock()
	ret, specificReturn := fake.detachSecurityGroupComponentReturnsOnCall[len(fake.detachSecurityGroupComponentArgsForCall)]
	fake.detachSecurityGroupComponentArgsForCall = append(fake.detachSecurityGroupComponentArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("DetachSecurityGroupComponent", []interface{}{arg1, arg2})
	fake.detachSecurityGroupComponentMutex.Unlock()
	if fake.DetachSecurityGroupComponentStub != nil {
		return fake.DetachSecurityGroupComponentStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.detachSecurityGroupComponentReturns
	return fakeReturns.result1
}

func (fake *FakeNetworkManager) DetachSecurityGroupComponentCallCount() int {
	fake.detachSecurityGroupComponentMutex.RLock()
	defer fake.detachSecurityGroupComponentMutex.RUnlock()
	return len(fake.detachSecurityGroupComponentArgsForCall)
}

func (fake *FakeNetworkManager) DetachSecurityGroupComponentCalls(stub func(int, int) error) {
	fake.detachSecurityGroupComponentMutex.Lock()
	defer fake.detachSecurityGroupComponentMutex.Unlock()
	fake.DetachSecurityGroupComponentStub = stub
}

func (fake *FakeNetworkManager) DetachSecurityGroupComponentArgsForCall(i int) (int, int) {
	fake.detachSecurityGroupComponentMutex.RLock()
	defer fake.detachSecurityGroupComponentMutex.RUnlock()
	argsForCall := fake.detachSecurityGroupComponentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) DetachSecurityGroupComponentReturns(result1 error) {
	fake.detachSecurityGroupComponentMutex.Lock()
	defer fake.detachSecurityGroupComponentMutex.Unlock()
	fake.DetachSecurityGroupComponentStub = nil
	fake.detachSecurityGroupComponentReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) DetachSecurityGroupComponentReturnsOnCall(i int, result1 error) {
	fake.detachSecurityGroupComponentMutex.Lock()
	defer fake.detachSecurityGroupComponentMutex.Unlock()
	fake.DetachSecurityGroupComponentStub = nil
	if fake.detachSecurityGroupComponentReturnsOnCall == nil {
		fake.detachSecurityGroupComponentReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.detachSecurityGroupComponentReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) DetachSecurityGroupComponents(arg1 int, arg2 []int) error {
	var arg2Copy []int
	if arg2 != nil {
		arg2Copy = make([]int, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.detachSecurityGroupComponentsMutex.Lock()
	ret, specificReturn := fake.detachSecurityGroupComponentsReturnsOnCall[len(fake.detachSecurityGroupComponentsArgsForCall)]
	fake.detachSecurityGroupComponentsArgsForCall = append(fake.detachSecurityGroupComponentsArgsForCall, struct {
		arg1 int
		arg2 []int
	}{arg1, arg2Copy})
	fake.recordInvocation("DetachSecurityGroupComponents", []interface{}{arg1, arg2Copy})
	fake.detachSecurityGroupComponentsMutex.Unlock()
	if fake.DetachSecurityGroupComponentsStub != nil {
		return fake.DetachSecurityGroupComponentsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.detachSecurityGroupComponentsReturns
	return fakeReturns.result1
}

func (fake *FakeNetworkManager) DetachSecurityGroupComponentsCallCount() int {
	fake.detachSecurityGroupComponentsMutex.RLock()
	defer fake.detachSecurityGroupComponentsMutex.RUnlock()
	return len(fake.detachSecurityGroupComponentsArgsForCall)
}

func (fake *FakeNetworkManager) DetachSecurityGroupComponentsCalls(stub func(int, []int) error) {
	fake.detachSecurityGroupComponentsMutex.Lock()
	defer fake.detachSecurityGroupComponentsMutex.Unlock()
	fake.DetachSecurityGroupComponentsStub = stub
}

func (fake *FakeNetworkManager) DetachSecurityGroupComponentsArgsForCall(i int) (int, []int) {
	fake.detachSecurityGroupComponentsMutex.RLock()
	defer fake.detachSecurityGroupComponentsMutex.RUnlock()
	argsForCall := fake.detachSecurityGroupComponentsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) DetachSecurityGroupComponentsReturns(result1 error) {
	fake.detachSecurityGroupComponentsMutex.Lock()
	defer fake.detachSecurityGroupComponentsMutex.Unlock()
	fake.DetachSecurityGroupComponentsStub = nil
	fake.detachSecurityGroupComponentsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) DetachSecurityGroupComponentsReturnsOnCall(i int, result1 error) {
	fake.detachSecurityGroupComponentsMutex.Lock()
	defer fake.detachSecurityGroupComponentsMutex.Unlock()
	fake.DetachSecurityGroupComponentsStub = nil
	if fake.detachSecurityGroupComponentsReturnsOnCall == nil {
		fake.detachSecurityGroupComponentsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.detachSecurityGroupComponentsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) EditSecurityGroup(arg1 int, arg2 string, arg3 string) error {
	fake.editSecurityGroupMutex.Lock()
	ret, specificReturn := fake.editSecurityGroupReturnsOnCall[len(fake.editSecurityGroupArgsForCall)]
	fake.editSecurityGroupArgsForCall = append(fake.editSecurityGroupArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("EditSecurityGroup", []interface{}{arg1, arg2, arg3})
	fake.editSecurityGroupMutex.Unlock()
	if fake.EditSecurityGroupStub != nil {
		return fake.EditSecurityGroupStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.editSecurityGroupReturns
	return fakeReturns.result1
}

func (fake *FakeNetworkManager) EditSecurityGroupCallCount() int {
	fake.editSecurityGroupMutex.RLock()
	defer fake.editSecurityGroupMutex.RUnlock()
	return len(fake.editSecurityGroupArgsForCall)
}

func (fake *FakeNetworkManager) EditSecurityGroupCalls(stub func(int, string, string) error) {
	fake.editSecurityGroupMutex.Lock()
	defer fake.editSecurityGroupMutex.Unlock()
	fake.EditSecurityGroupStub = stub
}

func (fake *FakeNetworkManager) EditSecurityGroupArgsForCall(i int) (int, string, string) {
	fake.editSecurityGroupMutex.RLock()
	defer fake.editSecurityGroupMutex.RUnlock()
	argsForCall := fake.editSecurityGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeNetworkManager) EditSecurityGroupReturns(result1 error) {
	fake.editSecurityGroupMutex.Lock()
	defer fake.editSecurityGroupMutex.Unlock()
	fake.EditSecurityGroupStub = nil
	fake.editSecurityGroupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) EditSecurityGroupReturnsOnCall(i int, result1 error) {
	fake.editSecurityGroupMutex.Lock()
	defer fake.editSecurityGroupMutex.Unlock()
	fake.EditSecurityGroupStub = nil
	if fake.editSecurityGroupReturnsOnCall == nil {
		fake.editSecurityGroupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.editSecurityGroupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) EditSecurityGroupRule(arg1 int, arg2 int, arg3 string, arg4 int, arg5 string, arg6 string, arg7 int, arg8 int, arg9 string) error {
	fake.editSecurityGroupRuleMutex.Lock()
	ret, specificReturn := fake.editSecurityGroupRuleReturnsOnCall[len(fake.editSecurityGroupRuleArgsForCall)]
	fake.editSecurityGroupRuleArgsForCall = append(fake.editSecurityGroupRuleArgsForCall, struct {
		arg1 int
		arg2 int
		arg3 string
		arg4 int
		arg5 string
		arg6 string
		arg7 int
		arg8 int
		arg9 string
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9})
	fake.recordInvocation("EditSecurityGroupRule", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9})
	fake.editSecurityGroupRuleMutex.Unlock()
	if fake.EditSecurityGroupRuleStub != nil {
		return fake.EditSecurityGroupRuleStub(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.editSecurityGroupRuleReturns
	return fakeReturns.result1
}

func (fake *FakeNetworkManager) EditSecurityGroupRuleCallCount() int {
	fake.editSecurityGroupRuleMutex.RLock()
	defer fake.editSecurityGroupRuleMutex.RUnlock()
	return len(fake.editSecurityGroupRuleArgsForCall)
}

func (fake *FakeNetworkManager) EditSecurityGroupRuleCalls(stub func(int, int, string, int, string, string, int, int, string) error) {
	fake.editSecurityGroupRuleMutex.Lock()
	defer fake.editSecurityGroupRuleMutex.Unlock()
	fake.EditSecurityGroupRuleStub = stub
}

func (fake *FakeNetworkManager) EditSecurityGroupRuleArgsForCall(i int) (int, int, string, int, string, string, int, int, string) {
	fake.editSecurityGroupRuleMutex.RLock()
	defer fake.editSecurityGroupRuleMutex.RUnlock()
	argsForCall := fake.editSecurityGroupRuleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7, argsForCall.arg8, argsForCall.arg9
}

func (fake *FakeNetworkManager) EditSecurityGroupRuleReturns(result1 error) {
	fake.editSecurityGroupRuleMutex.Lock()
	defer fake.editSecurityGroupRuleMutex.Unlock()
	fake.EditSecurityGroupRuleStub = nil
	fake.editSecurityGroupRuleReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) EditSecurityGroupRuleReturnsOnCall(i int, result1 error) {
	fake.editSecurityGroupRuleMutex.Lock()
	defer fake.editSecurityGroupRuleMutex.Unlock()
	fake.EditSecurityGroupRuleStub = nil
	if fake.editSecurityGroupRuleReturnsOnCall == nil {
		fake.editSecurityGroupRuleReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.editSecurityGroupRuleReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) EditSecurityGroupRules(arg1 int, arg2 []datatypes.Network_SecurityGroup_Rule) error {
	var arg2Copy []datatypes.Network_SecurityGroup_Rule
	if arg2 != nil {
		arg2Copy = make([]datatypes.Network_SecurityGroup_Rule, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.editSecurityGroupRulesMutex.Lock()
	ret, specificReturn := fake.editSecurityGroupRulesReturnsOnCall[len(fake.editSecurityGroupRulesArgsForCall)]
	fake.editSecurityGroupRulesArgsForCall = append(fake.editSecurityGroupRulesArgsForCall, struct {
		arg1 int
		arg2 []datatypes.Network_SecurityGroup_Rule
	}{arg1, arg2Copy})
	fake.recordInvocation("EditSecurityGroupRules", []interface{}{arg1, arg2Copy})
	fake.editSecurityGroupRulesMutex.Unlock()
	if fake.EditSecurityGroupRulesStub != nil {
		return fake.EditSecurityGroupRulesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.editSecurityGroupRulesReturns
	return fakeReturns.result1
}

func (fake *FakeNetworkManager) EditSecurityGroupRulesCallCount() int {
	fake.editSecurityGroupRulesMutex.RLock()
	defer fake.editSecurityGroupRulesMutex.RUnlock()
	return len(fake.editSecurityGroupRulesArgsForCall)
}

func (fake *FakeNetworkManager) EditSecurityGroupRulesCalls(stub func(int, []datatypes.Network_SecurityGroup_Rule) error) {
	fake.editSecurityGroupRulesMutex.Lock()
	defer fake.editSecurityGroupRulesMutex.Unlock()
	fake.EditSecurityGroupRulesStub = stub
}

func (fake *FakeNetworkManager) EditSecurityGroupRulesArgsForCall(i int) (int, []datatypes.Network_SecurityGroup_Rule) {
	fake.editSecurityGroupRulesMutex.RLock()
	defer fake.editSecurityGroupRulesMutex.RUnlock()
	argsForCall := fake.editSecurityGroupRulesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) EditSecurityGroupRulesReturns(result1 error) {
	fake.editSecurityGroupRulesMutex.Lock()
	defer fake.editSecurityGroupRulesMutex.Unlock()
	fake.EditSecurityGroupRulesStub = nil
	fake.editSecurityGroupRulesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) EditSecurityGroupRulesReturnsOnCall(i int, result1 error) {
	fake.editSecurityGroupRulesMutex.Lock()
	defer fake.editSecurityGroupRulesMutex.Unlock()
	fake.EditSecurityGroupRulesStub = nil
	if fake.editSecurityGroupRulesReturnsOnCall == nil {
		fake.editSecurityGroupRulesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.editSecurityGroupRulesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) EditVlan(arg1 int, arg2 string) error {
	fake.editVlanMutex.Lock()
	ret, specificReturn := fake.editVlanReturnsOnCall[len(fake.editVlanArgsForCall)]
	fake.editVlanArgsForCall = append(fake.editVlanArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("EditVlan", []interface{}{arg1, arg2})
	fake.editVlanMutex.Unlock()
	if fake.EditVlanStub != nil {
		return fake.EditVlanStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.editVlanReturns
	return fakeReturns.result1
}

func (fake *FakeNetworkManager) EditVlanCallCount() int {
	fake.editVlanMutex.RLock()
	defer fake.editVlanMutex.RUnlock()
	return len(fake.editVlanArgsForCall)
}

func (fake *FakeNetworkManager) EditVlanCalls(stub func(int, string) error) {
	fake.editVlanMutex.Lock()
	defer fake.editVlanMutex.Unlock()
	fake.EditVlanStub = stub
}

func (fake *FakeNetworkManager) EditVlanArgsForCall(i int) (int, string) {
	fake.editVlanMutex.RLock()
	defer fake.editVlanMutex.RUnlock()
	argsForCall := fake.editVlanArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) EditVlanReturns(result1 error) {
	fake.editVlanMutex.Lock()
	defer fake.editVlanMutex.Unlock()
	fake.EditVlanStub = nil
	fake.editVlanReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) EditVlanReturnsOnCall(i int, result1 error) {
	fake.editVlanMutex.Lock()
	defer fake.editVlanMutex.Unlock()
	fake.EditVlanStub = nil
	if fake.editVlanReturnsOnCall == nil {
		fake.editVlanReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.editVlanReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) GetSecurityGroup(arg1 int, arg2 string) (datatypes.Network_SecurityGroup, error) {
	fake.getSecurityGroupMutex.Lock()
	ret, specificReturn := fake.getSecurityGroupReturnsOnCall[len(fake.getSecurityGroupArgsForCall)]
	fake.getSecurityGroupArgsForCall = append(fake.getSecurityGroupArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetSecurityGroup", []interface{}{arg1, arg2})
	fake.getSecurityGroupMutex.Unlock()
	if fake.GetSecurityGroupStub != nil {
		return fake.GetSecurityGroupStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getSecurityGroupReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) GetSecurityGroupCallCount() int {
	fake.getSecurityGroupMutex.RLock()
	defer fake.getSecurityGroupMutex.RUnlock()
	return len(fake.getSecurityGroupArgsForCall)
}

func (fake *FakeNetworkManager) GetSecurityGroupCalls(stub func(int, string) (datatypes.Network_SecurityGroup, error)) {
	fake.getSecurityGroupMutex.Lock()
	defer fake.getSecurityGroupMutex.Unlock()
	fake.GetSecurityGroupStub = stub
}

func (fake *FakeNetworkManager) GetSecurityGroupArgsForCall(i int) (int, string) {
	fake.getSecurityGroupMutex.RLock()
	defer fake.getSecurityGroupMutex.RUnlock()
	argsForCall := fake.getSecurityGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) GetSecurityGroupReturns(result1 datatypes.Network_SecurityGroup, result2 error) {
	fake.getSecurityGroupMutex.Lock()
	defer fake.getSecurityGroupMutex.Unlock()
	fake.GetSecurityGroupStub = nil
	fake.getSecurityGroupReturns = struct {
		result1 datatypes.Network_SecurityGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) GetSecurityGroupReturnsOnCall(i int, result1 datatypes.Network_SecurityGroup, result2 error) {
	fake.getSecurityGroupMutex.Lock()
	defer fake.getSecurityGroupMutex.Unlock()
	fake.GetSecurityGroupStub = nil
	if fake.getSecurityGroupReturnsOnCall == nil {
		fake.getSecurityGroupReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_SecurityGroup
			result2 error
		})
	}
	fake.getSecurityGroupReturnsOnCall[i] = struct {
		result1 datatypes.Network_SecurityGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) GetSubnet(arg1 int, arg2 string) (datatypes.Network_Subnet, error) {
	fake.getSubnetMutex.Lock()
	ret, specificReturn := fake.getSubnetReturnsOnCall[len(fake.getSubnetArgsForCall)]
	fake.getSubnetArgsForCall = append(fake.getSubnetArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetSubnet", []interface{}{arg1, arg2})
	fake.getSubnetMutex.Unlock()
	if fake.GetSubnetStub != nil {
		return fake.GetSubnetStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getSubnetReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) GetSubnetCallCount() int {
	fake.getSubnetMutex.RLock()
	defer fake.getSubnetMutex.RUnlock()
	return len(fake.getSubnetArgsForCall)
}

func (fake *FakeNetworkManager) GetSubnetCalls(stub func(int, string) (datatypes.Network_Subnet, error)) {
	fake.getSubnetMutex.Lock()
	defer fake.getSubnetMutex.Unlock()
	fake.GetSubnetStub = stub
}

func (fake *FakeNetworkManager) GetSubnetArgsForCall(i int) (int, string) {
	fake.getSubnetMutex.RLock()
	defer fake.getSubnetMutex.RUnlock()
	argsForCall := fake.getSubnetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) GetSubnetReturns(result1 datatypes.Network_Subnet, result2 error) {
	fake.getSubnetMutex.Lock()
	defer fake.getSubnetMutex.Unlock()
	fake.GetSubnetStub = nil
	fake.getSubnetReturns = struct {
		result1 datatypes.Network_Subnet
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) GetSubnetReturnsOnCall(i int, result1 datatypes.Network_Subnet, result2 error) {
	fake.getSubnetMutex.Lock()
	defer fake.getSubnetMutex.Unlock()
	fake.GetSubnetStub = nil
	if fake.getSubnetReturnsOnCall == nil {
		fake.getSubnetReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_Subnet
			result2 error
		})
	}
	fake.getSubnetReturnsOnCall[i] = struct {
		result1 datatypes.Network_Subnet
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) GetVlan(arg1 int, arg2 string) (datatypes.Network_Vlan, error) {
	fake.getVlanMutex.Lock()
	ret, specificReturn := fake.getVlanReturnsOnCall[len(fake.getVlanArgsForCall)]
	fake.getVlanArgsForCall = append(fake.getVlanArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetVlan", []interface{}{arg1, arg2})
	fake.getVlanMutex.Unlock()
	if fake.GetVlanStub != nil {
		return fake.GetVlanStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getVlanReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) GetVlanCallCount() int {
	fake.getVlanMutex.RLock()
	defer fake.getVlanMutex.RUnlock()
	return len(fake.getVlanArgsForCall)
}

func (fake *FakeNetworkManager) GetVlanCalls(stub func(int, string) (datatypes.Network_Vlan, error)) {
	fake.getVlanMutex.Lock()
	defer fake.getVlanMutex.Unlock()
	fake.GetVlanStub = stub
}

func (fake *FakeNetworkManager) GetVlanArgsForCall(i int) (int, string) {
	fake.getVlanMutex.RLock()
	defer fake.getVlanMutex.RUnlock()
	argsForCall := fake.getVlanArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) GetVlanReturns(result1 datatypes.Network_Vlan, result2 error) {
	fake.getVlanMutex.Lock()
	defer fake.getVlanMutex.Unlock()
	fake.GetVlanStub = nil
	fake.getVlanReturns = struct {
		result1 datatypes.Network_Vlan
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) GetVlanReturnsOnCall(i int, result1 datatypes.Network_Vlan, result2 error) {
	fake.getVlanMutex.Lock()
	defer fake.getVlanMutex.Unlock()
	fake.GetVlanStub = nil
	if fake.getVlanReturnsOnCall == nil {
		fake.getVlanReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_Vlan
			result2 error
		})
	}
	fake.getVlanReturnsOnCall[i] = struct {
		result1 datatypes.Network_Vlan
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) IPLookup(arg1 string) (datatypes.Network_Subnet_IpAddress, error) {
	fake.iPLookupMutex.Lock()
	ret, specificReturn := fake.iPLookupReturnsOnCall[len(fake.iPLookupArgsForCall)]
	fake.iPLookupArgsForCall = append(fake.iPLookupArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("IPLookup", []interface{}{arg1})
	fake.iPLookupMutex.Unlock()
	if fake.IPLookupStub != nil {
		return fake.IPLookupStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.iPLookupReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) IPLookupCallCount() int {
	fake.iPLookupMutex.RLock()
	defer fake.iPLookupMutex.RUnlock()
	return len(fake.iPLookupArgsForCall)
}

func (fake *FakeNetworkManager) IPLookupCalls(stub func(string) (datatypes.Network_Subnet_IpAddress, error)) {
	fake.iPLookupMutex.Lock()
	defer fake.iPLookupMutex.Unlock()
	fake.IPLookupStub = stub
}

func (fake *FakeNetworkManager) IPLookupArgsForCall(i int) string {
	fake.iPLookupMutex.RLock()
	defer fake.iPLookupMutex.RUnlock()
	argsForCall := fake.iPLookupArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNetworkManager) IPLookupReturns(result1 datatypes.Network_Subnet_IpAddress, result2 error) {
	fake.iPLookupMutex.Lock()
	defer fake.iPLookupMutex.Unlock()
	fake.IPLookupStub = nil
	fake.iPLookupReturns = struct {
		result1 datatypes.Network_Subnet_IpAddress
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) IPLookupReturnsOnCall(i int, result1 datatypes.Network_Subnet_IpAddress, result2 error) {
	fake.iPLookupMutex.Lock()
	defer fake.iPLookupMutex.Unlock()
	fake.IPLookupStub = nil
	if fake.iPLookupReturnsOnCall == nil {
		fake.iPLookupReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_Subnet_IpAddress
			result2 error
		})
	}
	fake.iPLookupReturnsOnCall[i] = struct {
		result1 datatypes.Network_Subnet_IpAddress
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) ListDatacenters() (map[int]string, error) {
	fake.listDatacentersMutex.Lock()
	ret, specificReturn := fake.listDatacentersReturnsOnCall[len(fake.listDatacentersArgsForCall)]
	fake.listDatacentersArgsForCall = append(fake.listDatacentersArgsForCall, struct {
	}{})
	fake.recordInvocation("ListDatacenters", []interface{}{})
	fake.listDatacentersMutex.Unlock()
	if fake.ListDatacentersStub != nil {
		return fake.ListDatacentersStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listDatacentersReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) ListDatacentersCallCount() int {
	fake.listDatacentersMutex.RLock()
	defer fake.listDatacentersMutex.RUnlock()
	return len(fake.listDatacentersArgsForCall)
}

func (fake *FakeNetworkManager) ListDatacentersCalls(stub func() (map[int]string, error)) {
	fake.listDatacentersMutex.Lock()
	defer fake.listDatacentersMutex.Unlock()
	fake.ListDatacentersStub = stub
}

func (fake *FakeNetworkManager) ListDatacentersReturns(result1 map[int]string, result2 error) {
	fake.listDatacentersMutex.Lock()
	defer fake.listDatacentersMutex.Unlock()
	fake.ListDatacentersStub = nil
	fake.listDatacentersReturns = struct {
		result1 map[int]string
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) ListDatacentersReturnsOnCall(i int, result1 map[int]string, result2 error) {
	fake.listDatacentersMutex.Lock()
	defer fake.listDatacentersMutex.Unlock()
	fake.ListDatacentersStub = nil
	if fake.listDatacentersReturnsOnCall == nil {
		fake.listDatacentersReturnsOnCall = make(map[int]struct {
			result1 map[int]string
			result2 error
		})
	}
	fake.listDatacentersReturnsOnCall[i] = struct {
		result1 map[int]string
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) ListGlobalIPs(arg1 int, arg2 int) ([]datatypes.Network_Subnet_IpAddress_Global, error) {
	fake.listGlobalIPsMutex.Lock()
	ret, specificReturn := fake.listGlobalIPsReturnsOnCall[len(fake.listGlobalIPsArgsForCall)]
	fake.listGlobalIPsArgsForCall = append(fake.listGlobalIPsArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("ListGlobalIPs", []interface{}{arg1, arg2})
	fake.listGlobalIPsMutex.Unlock()
	if fake.ListGlobalIPsStub != nil {
		return fake.ListGlobalIPsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listGlobalIPsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) ListGlobalIPsCallCount() int {
	fake.listGlobalIPsMutex.RLock()
	defer fake.listGlobalIPsMutex.RUnlock()
	return len(fake.listGlobalIPsArgsForCall)
}

func (fake *FakeNetworkManager) ListGlobalIPsCalls(stub func(int, int) ([]datatypes.Network_Subnet_IpAddress_Global, error)) {
	fake.listGlobalIPsMutex.Lock()
	defer fake.listGlobalIPsMutex.Unlock()
	fake.ListGlobalIPsStub = stub
}

func (fake *FakeNetworkManager) ListGlobalIPsArgsForCall(i int) (int, int) {
	fake.listGlobalIPsMutex.RLock()
	defer fake.listGlobalIPsMutex.RUnlock()
	argsForCall := fake.listGlobalIPsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) ListGlobalIPsReturns(result1 []datatypes.Network_Subnet_IpAddress_Global, result2 error) {
	fake.listGlobalIPsMutex.Lock()
	defer fake.listGlobalIPsMutex.Unlock()
	fake.ListGlobalIPsStub = nil
	fake.listGlobalIPsReturns = struct {
		result1 []datatypes.Network_Subnet_IpAddress_Global
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) ListGlobalIPsReturnsOnCall(i int, result1 []datatypes.Network_Subnet_IpAddress_Global, result2 error) {
	fake.listGlobalIPsMutex.Lock()
	defer fake.listGlobalIPsMutex.Unlock()
	fake.ListGlobalIPsStub = nil
	if fake.listGlobalIPsReturnsOnCall == nil {
		fake.listGlobalIPsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Network_Subnet_IpAddress_Global
			result2 error
		})
	}
	fake.listGlobalIPsReturnsOnCall[i] = struct {
		result1 []datatypes.Network_Subnet_IpAddress_Global
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) ListRouters(arg1 int, arg2 string) ([]string, error) {
	fake.listRoutersMutex.Lock()
	ret, specificReturn := fake.listRoutersReturnsOnCall[len(fake.listRoutersArgsForCall)]
	fake.listRoutersArgsForCall = append(fake.listRoutersArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("ListRouters", []interface{}{arg1, arg2})
	fake.listRoutersMutex.Unlock()
	if fake.ListRoutersStub != nil {
		return fake.ListRoutersStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listRoutersReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) ListRoutersCallCount() int {
	fake.listRoutersMutex.RLock()
	defer fake.listRoutersMutex.RUnlock()
	return len(fake.listRoutersArgsForCall)
}

func (fake *FakeNetworkManager) ListRoutersCalls(stub func(int, string) ([]string, error)) {
	fake.listRoutersMutex.Lock()
	defer fake.listRoutersMutex.Unlock()
	fake.ListRoutersStub = stub
}

func (fake *FakeNetworkManager) ListRoutersArgsForCall(i int) (int, string) {
	fake.listRoutersMutex.RLock()
	defer fake.listRoutersMutex.RUnlock()
	argsForCall := fake.listRoutersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) ListRoutersReturns(result1 []string, result2 error) {
	fake.listRoutersMutex.Lock()
	defer fake.listRoutersMutex.Unlock()
	fake.ListRoutersStub = nil
	fake.listRoutersReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) ListRoutersReturnsOnCall(i int, result1 []string, result2 error) {
	fake.listRoutersMutex.Lock()
	defer fake.listRoutersMutex.Unlock()
	fake.ListRoutersStub = nil
	if fake.listRoutersReturnsOnCall == nil {
		fake.listRoutersReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.listRoutersReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) ListSecurityGroupRules(arg1 int) ([]datatypes.Network_SecurityGroup_Rule, error) {
	fake.listSecurityGroupRulesMutex.Lock()
	ret, specificReturn := fake.listSecurityGroupRulesReturnsOnCall[len(fake.listSecurityGroupRulesArgsForCall)]
	fake.listSecurityGroupRulesArgsForCall = append(fake.listSecurityGroupRulesArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("ListSecurityGroupRules", []interface{}{arg1})
	fake.listSecurityGroupRulesMutex.Unlock()
	if fake.ListSecurityGroupRulesStub != nil {
		return fake.ListSecurityGroupRulesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listSecurityGroupRulesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) ListSecurityGroupRulesCallCount() int {
	fake.listSecurityGroupRulesMutex.RLock()
	defer fake.listSecurityGroupRulesMutex.RUnlock()
	return len(fake.listSecurityGroupRulesArgsForCall)
}

func (fake *FakeNetworkManager) ListSecurityGroupRulesCalls(stub func(int) ([]datatypes.Network_SecurityGroup_Rule, error)) {
	fake.listSecurityGroupRulesMutex.Lock()
	defer fake.listSecurityGroupRulesMutex.Unlock()
	fake.ListSecurityGroupRulesStub = stub
}

func (fake *FakeNetworkManager) ListSecurityGroupRulesArgsForCall(i int) int {
	fake.listSecurityGroupRulesMutex.RLock()
	defer fake.listSecurityGroupRulesMutex.RUnlock()
	argsForCall := fake.listSecurityGroupRulesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNetworkManager) ListSecurityGroupRulesReturns(result1 []datatypes.Network_SecurityGroup_Rule, result2 error) {
	fake.listSecurityGroupRulesMutex.Lock()
	defer fake.listSecurityGroupRulesMutex.Unlock()
	fake.ListSecurityGroupRulesStub = nil
	fake.listSecurityGroupRulesReturns = struct {
		result1 []datatypes.Network_SecurityGroup_Rule
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) ListSecurityGroupRulesReturnsOnCall(i int, result1 []datatypes.Network_SecurityGroup_Rule, result2 error) {
	fake.listSecurityGroupRulesMutex.Lock()
	defer fake.listSecurityGroupRulesMutex.Unlock()
	fake.ListSecurityGroupRulesStub = nil
	if fake.listSecurityGroupRulesReturnsOnCall == nil {
		fake.listSecurityGroupRulesReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Network_SecurityGroup_Rule
			result2 error
		})
	}
	fake.listSecurityGroupRulesReturnsOnCall[i] = struct {
		result1 []datatypes.Network_SecurityGroup_Rule
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) ListSecurityGroups() ([]datatypes.Network_SecurityGroup, error) {
	fake.listSecurityGroupsMutex.Lock()
	ret, specificReturn := fake.listSecurityGroupsReturnsOnCall[len(fake.listSecurityGroupsArgsForCall)]
	fake.listSecurityGroupsArgsForCall = append(fake.listSecurityGroupsArgsForCall, struct {
	}{})
	fake.recordInvocation("ListSecurityGroups", []interface{}{})
	fake.listSecurityGroupsMutex.Unlock()
	if fake.ListSecurityGroupsStub != nil {
		return fake.ListSecurityGroupsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listSecurityGroupsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) ListSecurityGroupsCallCount() int {
	fake.listSecurityGroupsMutex.RLock()
	defer fake.listSecurityGroupsMutex.RUnlock()
	return len(fake.listSecurityGroupsArgsForCall)
}

func (fake *FakeNetworkManager) ListSecurityGroupsCalls(stub func() ([]datatypes.Network_SecurityGroup, error)) {
	fake.listSecurityGroupsMutex.Lock()
	defer fake.listSecurityGroupsMutex.Unlock()
	fake.ListSecurityGroupsStub = stub
}

func (fake *FakeNetworkManager) ListSecurityGroupsReturns(result1 []datatypes.Network_SecurityGroup, result2 error) {
	fake.listSecurityGroupsMutex.Lock()
	defer fake.listSecurityGroupsMutex.Unlock()
	fake.ListSecurityGroupsStub = nil
	fake.listSecurityGroupsReturns = struct {
		result1 []datatypes.Network_SecurityGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) ListSecurityGroupsReturnsOnCall(i int, result1 []datatypes.Network_SecurityGroup, result2 error) {
	fake.listSecurityGroupsMutex.Lock()
	defer fake.listSecurityGroupsMutex.Unlock()
	fake.ListSecurityGroupsStub = nil
	if fake.listSecurityGroupsReturnsOnCall == nil {
		fake.listSecurityGroupsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Network_SecurityGroup
			result2 error
		})
	}
	fake.listSecurityGroupsReturnsOnCall[i] = struct {
		result1 []datatypes.Network_SecurityGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) ListSubnets(arg1 string, arg2 string, arg3 int, arg4 string, arg5 string, arg6 int, arg7 string) ([]datatypes.Network_Subnet, error) {
	fake.listSubnetsMutex.Lock()
	ret, specificReturn := fake.listSubnetsReturnsOnCall[len(fake.listSubnetsArgsForCall)]
	fake.listSubnetsArgsForCall = append(fake.listSubnetsArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 int
		arg4 string
		arg5 string
		arg6 int
		arg7 string
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.recordInvocation("ListSubnets", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.listSubnetsMutex.Unlock()
	if fake.ListSubnetsStub != nil {
		return fake.ListSubnetsStub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listSubnetsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) ListSubnetsCallCount() int {
	fake.listSubnetsMutex.RLock()
	defer fake.listSubnetsMutex.RUnlock()
	return len(fake.listSubnetsArgsForCall)
}

func (fake *FakeNetworkManager) ListSubnetsCalls(stub func(string, string, int, string, string, int, string) ([]datatypes.Network_Subnet, error)) {
	fake.listSubnetsMutex.Lock()
	defer fake.listSubnetsMutex.Unlock()
	fake.ListSubnetsStub = stub
}

func (fake *FakeNetworkManager) ListSubnetsArgsForCall(i int) (string, string, int, string, string, int, string) {
	fake.listSubnetsMutex.RLock()
	defer fake.listSubnetsMutex.RUnlock()
	argsForCall := fake.listSubnetsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeNetworkManager) ListSubnetsReturns(result1 []datatypes.Network_Subnet, result2 error) {
	fake.listSubnetsMutex.Lock()
	defer fake.listSubnetsMutex.Unlock()
	fake.ListSubnetsStub = nil
	fake.listSubnetsReturns = struct {
		result1 []datatypes.Network_Subnet
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) ListSubnetsReturnsOnCall(i int, result1 []datatypes.Network_Subnet, result2 error) {
	fake.listSubnetsMutex.Lock()
	defer fake.listSubnetsMutex.Unlock()
	fake.ListSubnetsStub = nil
	if fake.listSubnetsReturnsOnCall == nil {
		fake.listSubnetsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Network_Subnet
			result2 error
		})
	}
	fake.listSubnetsReturnsOnCall[i] = struct {
		result1 []datatypes.Network_Subnet
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) ListVlans(arg1 string, arg2 int, arg3 string, arg4 int, arg5 string) ([]datatypes.Network_Vlan, error) {
	fake.listVlansMutex.Lock()
	ret, specificReturn := fake.listVlansReturnsOnCall[len(fake.listVlansArgsForCall)]
	fake.listVlansArgsForCall = append(fake.listVlansArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 string
		arg4 int
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("ListVlans", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.listVlansMutex.Unlock()
	if fake.ListVlansStub != nil {
		return fake.ListVlansStub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listVlansReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) ListVlansCallCount() int {
	fake.listVlansMutex.RLock()
	defer fake.listVlansMutex.RUnlock()
	return len(fake.listVlansArgsForCall)
}

func (fake *FakeNetworkManager) ListVlansCalls(stub func(string, int, string, int, string) ([]datatypes.Network_Vlan, error)) {
	fake.listVlansMutex.Lock()
	defer fake.listVlansMutex.Unlock()
	fake.ListVlansStub = stub
}

func (fake *FakeNetworkManager) ListVlansArgsForCall(i int) (string, int, string, int, string) {
	fake.listVlansMutex.RLock()
	defer fake.listVlansMutex.RUnlock()
	argsForCall := fake.listVlansArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeNetworkManager) ListVlansReturns(result1 []datatypes.Network_Vlan, result2 error) {
	fake.listVlansMutex.Lock()
	defer fake.listVlansMutex.Unlock()
	fake.ListVlansStub = nil
	fake.listVlansReturns = struct {
		result1 []datatypes.Network_Vlan
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) ListVlansReturnsOnCall(i int, result1 []datatypes.Network_Vlan, result2 error) {
	fake.listVlansMutex.Lock()
	defer fake.listVlansMutex.Unlock()
	fake.ListVlansStub = nil
	if fake.listVlansReturnsOnCall == nil {
		fake.listVlansReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Network_Vlan
			result2 error
		})
	}
	fake.listVlansReturnsOnCall[i] = struct {
		result1 []datatypes.Network_Vlan
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) RemoveSecurityGroupRule(arg1 int, arg2 int) error {
	fake.removeSecurityGroupRuleMutex.Lock()
	ret, specificReturn := fake.removeSecurityGroupRuleReturnsOnCall[len(fake.removeSecurityGroupRuleArgsForCall)]
	fake.removeSecurityGroupRuleArgsForCall = append(fake.removeSecurityGroupRuleArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("RemoveSecurityGroupRule", []interface{}{arg1, arg2})
	fake.removeSecurityGroupRuleMutex.Unlock()
	if fake.RemoveSecurityGroupRuleStub != nil {
		return fake.RemoveSecurityGroupRuleStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removeSecurityGroupRuleReturns
	return fakeReturns.result1
}

func (fake *FakeNetworkManager) RemoveSecurityGroupRuleCallCount() int {
	fake.removeSecurityGroupRuleMutex.RLock()
	defer fake.removeSecurityGroupRuleMutex.RUnlock()
	return len(fake.removeSecurityGroupRuleArgsForCall)
}

func (fake *FakeNetworkManager) RemoveSecurityGroupRuleCalls(stub func(int, int) error) {
	fake.removeSecurityGroupRuleMutex.Lock()
	defer fake.removeSecurityGroupRuleMutex.Unlock()
	fake.RemoveSecurityGroupRuleStub = stub
}

func (fake *FakeNetworkManager) RemoveSecurityGroupRuleArgsForCall(i int) (int, int) {
	fake.removeSecurityGroupRuleMutex.RLock()
	defer fake.removeSecurityGroupRuleMutex.RUnlock()
	argsForCall := fake.removeSecurityGroupRuleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) RemoveSecurityGroupRuleReturns(result1 error) {
	fake.removeSecurityGroupRuleMutex.Lock()
	defer fake.removeSecurityGroupRuleMutex.Unlock()
	fake.RemoveSecurityGroupRuleStub = nil
	fake.removeSecurityGroupRuleReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) RemoveSecurityGroupRuleReturnsOnCall(i int, result1 error) {
	fake.removeSecurityGroupRuleMutex.Lock()
	defer fake.removeSecurityGroupRuleMutex.Unlock()
	fake.RemoveSecurityGroupRuleStub = nil
	if fake.removeSecurityGroupRuleReturnsOnCall == nil {
		fake.removeSecurityGroupRuleReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeSecurityGroupRuleReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) RemoveSecurityGroupRules(arg1 int, arg2 []int) error {
	var arg2Copy []int
	if arg2 != nil {
		arg2Copy = make([]int, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.removeSecurityGroupRulesMutex.Lock()
	ret, specificReturn := fake.removeSecurityGroupRulesReturnsOnCall[len(fake.removeSecurityGroupRulesArgsForCall)]
	fake.removeSecurityGroupRulesArgsForCall = append(fake.removeSecurityGroupRulesArgsForCall, struct {
		arg1 int
		arg2 []int
	}{arg1, arg2Copy})
	fake.recordInvocation("RemoveSecurityGroupRules", []interface{}{arg1, arg2Copy})
	fake.removeSecurityGroupRulesMutex.Unlock()
	if fake.RemoveSecurityGroupRulesStub != nil {
		return fake.RemoveSecurityGroupRulesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removeSecurityGroupRulesReturns
	return fakeReturns.result1
}

func (fake *FakeNetworkManager) RemoveSecurityGroupRulesCallCount() int {
	fake.removeSecurityGroupRulesMutex.RLock()
	defer fake.removeSecurityGroupRulesMutex.RUnlock()
	return len(fake.removeSecurityGroupRulesArgsForCall)
}

func (fake *FakeNetworkManager) RemoveSecurityGroupRulesCalls(stub func(int, []int) error) {
	fake.removeSecurityGroupRulesMutex.Lock()
	defer fake.removeSecurityGroupRulesMutex.Unlock()
	fake.RemoveSecurityGroupRulesStub = stub
}

func (fake *FakeNetworkManager) RemoveSecurityGroupRulesArgsForCall(i int) (int, []int) {
	fake.removeSecurityGroupRulesMutex.RLock()
	defer fake.removeSecurityGroupRulesMutex.RUnlock()
	argsForCall := fake.removeSecurityGroupRulesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNetworkManager) RemoveSecurityGroupRulesReturns(result1 error) {
	fake.removeSecurityGroupRulesMutex.Lock()
	defer fake.removeSecurityGroupRulesMutex.Unlock()
	fake.RemoveSecurityGroupRulesStub = nil
	fake.removeSecurityGroupRulesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) RemoveSecurityGroupRulesReturnsOnCall(i int, result1 error) {
	fake.removeSecurityGroupRulesMutex.Lock()
	defer fake.removeSecurityGroupRulesMutex.Unlock()
	fake.RemoveSecurityGroupRulesStub = nil
	if fake.removeSecurityGroupRulesReturnsOnCall == nil {
		fake.removeSecurityGroupRulesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeSecurityGroupRulesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) UnassignGlobalIP(arg1 int) (datatypes.Provisioning_Version1_Transaction, error) {
	fake.unassignGlobalIPMutex.Lock()
	ret, specificReturn := fake.unassignGlobalIPReturnsOnCall[len(fake.unassignGlobalIPArgsForCall)]
	fake.unassignGlobalIPArgsForCall = append(fake.unassignGlobalIPArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("UnassignGlobalIP", []interface{}{arg1})
	fake.unassignGlobalIPMutex.Unlock()
	if fake.UnassignGlobalIPStub != nil {
		return fake.UnassignGlobalIPStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.unassignGlobalIPReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNetworkManager) UnassignGlobalIPCallCount() int {
	fake.unassignGlobalIPMutex.RLock()
	defer fake.unassignGlobalIPMutex.RUnlock()
	return len(fake.unassignGlobalIPArgsForCall)
}

func (fake *FakeNetworkManager) UnassignGlobalIPCalls(stub func(int) (datatypes.Provisioning_Version1_Transaction, error)) {
	fake.unassignGlobalIPMutex.Lock()
	defer fake.unassignGlobalIPMutex.Unlock()
	fake.UnassignGlobalIPStub = stub
}

func (fake *FakeNetworkManager) UnassignGlobalIPArgsForCall(i int) int {
	fake.unassignGlobalIPMutex.RLock()
	defer fake.unassignGlobalIPMutex.RUnlock()
	argsForCall := fake.unassignGlobalIPArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNetworkManager) UnassignGlobalIPReturns(result1 datatypes.Provisioning_Version1_Transaction, result2 error) {
	fake.unassignGlobalIPMutex.Lock()
	defer fake.unassignGlobalIPMutex.Unlock()
	fake.UnassignGlobalIPStub = nil
	fake.unassignGlobalIPReturns = struct {
		result1 datatypes.Provisioning_Version1_Transaction
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) UnassignGlobalIPReturnsOnCall(i int, result1 datatypes.Provisioning_Version1_Transaction, result2 error) {
	fake.unassignGlobalIPMutex.Lock()
	defer fake.unassignGlobalIPMutex.Unlock()
	fake.UnassignGlobalIPStub = nil
	if fake.unassignGlobalIPReturnsOnCall == nil {
		fake.unassignGlobalIPReturnsOnCall = make(map[int]struct {
			result1 datatypes.Provisioning_Version1_Transaction
			result2 error
		})
	}
	fake.unassignGlobalIPReturnsOnCall[i] = struct {
		result1 datatypes.Provisioning_Version1_Transaction
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addGlobalIPMutex.RLock()
	defer fake.addGlobalIPMutex.RUnlock()
	fake.addSecurityGroupRuleMutex.RLock()
	defer fake.addSecurityGroupRuleMutex.RUnlock()
	fake.addSecurityGroupRulesMutex.RLock()
	defer fake.addSecurityGroupRulesMutex.RUnlock()
	fake.addSubnetMutex.RLock()
	defer fake.addSubnetMutex.RUnlock()
	fake.addVlanMutex.RLock()
	defer fake.addVlanMutex.RUnlock()
	fake.assignGlobalIPMutex.RLock()
	defer fake.assignGlobalIPMutex.RUnlock()
	fake.attachSecurityGroupComponentMutex.RLock()
	defer fake.attachSecurityGroupComponentMutex.RUnlock()
	fake.attachSecurityGroupComponentsMutex.RLock()
	defer fake.attachSecurityGroupComponentsMutex.RUnlock()
	fake.cancelGlobalIPMutex.RLock()
	defer fake.cancelGlobalIPMutex.RUnlock()
	fake.cancelSubnetMutex.RLock()
	defer fake.cancelSubnetMutex.RUnlock()
	fake.cancelVLANMutex.RLock()
	defer fake.cancelVLANMutex.RUnlock()
	fake.createSecurityGroupMutex.RLock()
	defer fake.createSecurityGroupMutex.RUnlock()
	fake.deleteSecurityGroupMutex.RLock()
	defer fake.deleteSecurityGroupMutex.RUnlock()
	fake.detachSecurityGroupComponentMutex.RLock()
	defer fake.detachSecurityGroupComponentMutex.RUnlock()
	fake.detachSecurityGroupComponentsMutex.RLock()
	defer fake.detachSecurityGroupComponentsMutex.RUnlock()
	fake.editSecurityGroupMutex.RLock()
	defer fake.editSecurityGroupMutex.RUnlock()
	fake.editSecurityGroupRuleMutex.RLock()
	defer fake.editSecurityGroupRuleMutex.RUnlock()
	fake.editSecurityGroupRulesMutex.RLock()
	defer fake.editSecurityGroupRulesMutex.RUnlock()
	fake.editVlanMutex.RLock()
	defer fake.editVlanMutex.RUnlock()
	fake.getSecurityGroupMutex.RLock()
	defer fake.getSecurityGroupMutex.RUnlock()
	fake.getSubnetMutex.RLock()
	defer fake.getSubnetMutex.RUnlock()
	fake.getVlanMutex.RLock()
	defer fake.getVlanMutex.RUnlock()
	fake.iPLookupMutex.RLock()
	defer fake.iPLookupMutex.RUnlock()
	fake.listDatacentersMutex.RLock()
	defer fake.listDatacentersMutex.RUnlock()
	fake.listGlobalIPsMutex.RLock()
	defer fake.listGlobalIPsMutex.RUnlock()
	fake.listRoutersMutex.RLock()
	defer fake.listRoutersMutex.RUnlock()
	fake.listSecurityGroupRulesMutex.RLock()
	defer fake.listSecurityGroupRulesMutex.RUnlock()
	fake.listSecurityGroupsMutex.RLock()
	defer fake.listSecurityGroupsMutex.RUnlock()
	fake.listSubnetsMutex.RLock()
	defer fake.listSubnetsMutex.RUnlock()
	fake.listVlansMutex.RLock()
	defer fake.listVlansMutex.RUnlock()
	fake.removeSecurityGroupRuleMutex.RLock()
	defer fake.removeSecurityGroupRuleMutex.RUnlock()
	fake.removeSecurityGroupRulesMutex.RLock()
	defer fake.removeSecurityGroupRulesMutex.RUnlock()
	fake.unassignGlobalIPMutex.RLock()
	defer fake.unassignGlobalIPMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeNetworkManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ managers.NetworkManager = new(FakeNetworkManager)
