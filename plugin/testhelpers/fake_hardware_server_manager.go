// Code generated by counterfeiter. DO NOT EDIT.
package testhelpers

import (
	"sync"
	"time"

	"github.com/softlayer/softlayer-go/datatypes"
	"github.ibm.com/SoftLayer/softlayer-cli/plugin/managers"
)

type FakeHardwareServerManager struct {
	AuthorizeStorageStub        func(int, string) (bool, error)
	authorizeStorageMutex       sync.RWMutex
	authorizeStorageArgsForCall []struct {
		arg1 int
		arg2 string
	}
	authorizeStorageReturns struct {
		result1 bool
		result2 error
	}
	authorizeStorageReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CancelHardwareStub        func(int, string, string, bool) error
	cancelHardwareMutex       sync.RWMutex
	cancelHardwareArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 string
		arg4 bool
	}
	cancelHardwareReturns struct {
		result1 error
	}
	cancelHardwareReturnsOnCall map[int]struct {
		result1 error
	}
	CreateFirmwareReflashTransactionStub        func(int) (bool, error)
	createFirmwareReflashTransactionMutex       sync.RWMutex
	createFirmwareReflashTransactionArgsForCall []struct {
		arg1 int
	}
	createFirmwareReflashTransactionReturns struct {
		result1 bool
		result2 error
	}
	createFirmwareReflashTransactionReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CreateUserCustomerNotificationStub        func(int, int) (datatypes.User_Customer_Notification_Hardware, error)
	createUserCustomerNotificationMutex       sync.RWMutex
	createUserCustomerNotificationArgsForCall []struct {
		arg1 int
		arg2 int
	}
	createUserCustomerNotificationReturns struct {
		result1 datatypes.User_Customer_Notification_Hardware
		result2 error
	}
	createUserCustomerNotificationReturnsOnCall map[int]struct {
		result1 datatypes.User_Customer_Notification_Hardware
		result2 error
	}
	DeleteUserCustomerNotificationStub        func(int) (bool, error)
	deleteUserCustomerNotificationMutex       sync.RWMutex
	deleteUserCustomerNotificationArgsForCall []struct {
		arg1 int
	}
	deleteUserCustomerNotificationReturns struct {
		result1 bool
		result2 error
	}
	deleteUserCustomerNotificationReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	EditStub        func(int, string, string, string, string, string, int, int) ([]bool, []string)
	editMutex       sync.RWMutex
	editArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 string
		arg7 int
		arg8 int
	}
	editReturns struct {
		result1 []bool
		result2 []string
	}
	editReturnsOnCall map[int]struct {
		result1 []bool
		result2 []string
	}
	GenerateCreateTemplateStub        func(datatypes.Product_Package, map[string]interface{}) (datatypes.Container_Product_Order, error)
	generateCreateTemplateMutex       sync.RWMutex
	generateCreateTemplateArgsForCall []struct {
		arg1 datatypes.Product_Package
		arg2 map[string]interface{}
	}
	generateCreateTemplateReturns struct {
		result1 datatypes.Container_Product_Order
		result2 error
	}
	generateCreateTemplateReturnsOnCall map[int]struct {
		result1 datatypes.Container_Product_Order
		result2 error
	}
	GetBandwidthAllotmentDetailStub        func(int, string) (datatypes.Network_Bandwidth_Version1_Allotment_Detail, error)
	getBandwidthAllotmentDetailMutex       sync.RWMutex
	getBandwidthAllotmentDetailArgsForCall []struct {
		arg1 int
		arg2 string
	}
	getBandwidthAllotmentDetailReturns struct {
		result1 datatypes.Network_Bandwidth_Version1_Allotment_Detail
		result2 error
	}
	getBandwidthAllotmentDetailReturnsOnCall map[int]struct {
		result1 datatypes.Network_Bandwidth_Version1_Allotment_Detail
		result2 error
	}
	GetBandwidthDataStub        func(int, time.Time, time.Time, int) ([]datatypes.Metric_Tracking_Object_Data, error)
	getBandwidthDataMutex       sync.RWMutex
	getBandwidthDataArgsForCall []struct {
		arg1 int
		arg2 time.Time
		arg3 time.Time
		arg4 int
	}
	getBandwidthDataReturns struct {
		result1 []datatypes.Metric_Tracking_Object_Data
		result2 error
	}
	getBandwidthDataReturnsOnCall map[int]struct {
		result1 []datatypes.Metric_Tracking_Object_Data
		result2 error
	}
	GetBandwidthPriceIdStub        func([]datatypes.Product_Item, bool, bool, datatypes.Location_Region) (int, error)
	getBandwidthPriceIdMutex       sync.RWMutex
	getBandwidthPriceIdArgsForCall []struct {
		arg1 []datatypes.Product_Item
		arg2 bool
		arg3 bool
		arg4 datatypes.Location_Region
	}
	getBandwidthPriceIdReturns struct {
		result1 int
		result2 error
	}
	getBandwidthPriceIdReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	GetBillingCycleBandwidthUsageStub        func(int, string) ([]datatypes.Network_Bandwidth_Usage, error)
	getBillingCycleBandwidthUsageMutex       sync.RWMutex
	getBillingCycleBandwidthUsageArgsForCall []struct {
		arg1 int
		arg2 string
	}
	getBillingCycleBandwidthUsageReturns struct {
		result1 []datatypes.Network_Bandwidth_Usage
		result2 error
	}
	getBillingCycleBandwidthUsageReturnsOnCall map[int]struct {
		result1 []datatypes.Network_Bandwidth_Usage
		result2 error
	}
	GetCancellationReasonsStub        func() map[string]string
	getCancellationReasonsMutex       sync.RWMutex
	getCancellationReasonsArgsForCall []struct {
	}
	getCancellationReasonsReturns struct {
		result1 map[string]string
	}
	getCancellationReasonsReturnsOnCall map[int]struct {
		result1 map[string]string
	}
	GetCreateOptionsStub        func(datatypes.Product_Package) map[string]map[string]string
	getCreateOptionsMutex       sync.RWMutex
	getCreateOptionsArgsForCall []struct {
		arg1 datatypes.Product_Package
	}
	getCreateOptionsReturns struct {
		result1 map[string]map[string]string
	}
	getCreateOptionsReturnsOnCall map[int]struct {
		result1 map[string]map[string]string
	}
	GetDefaultPriceIdStub        func([]datatypes.Product_Item, string, bool, datatypes.Location_Region) (int, error)
	getDefaultPriceIdMutex       sync.RWMutex
	getDefaultPriceIdArgsForCall []struct {
		arg1 []datatypes.Product_Item
		arg2 string
		arg3 bool
		arg4 datatypes.Location_Region
	}
	getDefaultPriceIdReturns struct {
		result1 int
		result2 error
	}
	getDefaultPriceIdReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	GetExtraPriceIdStub        func([]datatypes.Product_Item, string, bool, datatypes.Location_Region) (int, error)
	getExtraPriceIdMutex       sync.RWMutex
	getExtraPriceIdArgsForCall []struct {
		arg1 []datatypes.Product_Item
		arg2 string
		arg3 bool
		arg4 datatypes.Location_Region
	}
	getExtraPriceIdReturns struct {
		result1 int
		result2 error
	}
	getExtraPriceIdReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	GetHardDrivesStub        func(int) ([]datatypes.Hardware_Component, error)
	getHardDrivesMutex       sync.RWMutex
	getHardDrivesArgsForCall []struct {
		arg1 int
	}
	getHardDrivesReturns struct {
		result1 []datatypes.Hardware_Component
		result2 error
	}
	getHardDrivesReturnsOnCall map[int]struct {
		result1 []datatypes.Hardware_Component
		result2 error
	}
	GetHardwareStub        func(int, string) (datatypes.Hardware_Server, error)
	getHardwareMutex       sync.RWMutex
	getHardwareArgsForCall []struct {
		arg1 int
		arg2 string
	}
	getHardwareReturns struct {
		result1 datatypes.Hardware_Server
		result2 error
	}
	getHardwareReturnsOnCall map[int]struct {
		result1 datatypes.Hardware_Server
		result2 error
	}
	GetHardwareComponentsStub        func(int) ([]datatypes.Hardware_Component, error)
	getHardwareComponentsMutex       sync.RWMutex
	getHardwareComponentsArgsForCall []struct {
		arg1 int
	}
	getHardwareComponentsReturns struct {
		result1 []datatypes.Hardware_Component
		result2 error
	}
	getHardwareComponentsReturnsOnCall map[int]struct {
		result1 []datatypes.Hardware_Component
		result2 error
	}
	GetOSPriceIdStub        func([]datatypes.Product_Item, string, datatypes.Location_Region) (int, error)
	getOSPriceIdMutex       sync.RWMutex
	getOSPriceIdArgsForCall []struct {
		arg1 []datatypes.Product_Item
		arg2 string
		arg3 datatypes.Location_Region
	}
	getOSPriceIdReturns struct {
		result1 int
		result2 error
	}
	getOSPriceIdReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	GetPackageStub        func() (datatypes.Product_Package, error)
	getPackageMutex       sync.RWMutex
	getPackageArgsForCall []struct {
	}
	getPackageReturns struct {
		result1 datatypes.Product_Package
		result2 error
	}
	getPackageReturnsOnCall map[int]struct {
		result1 datatypes.Product_Package
		result2 error
	}
	GetPortSpeedPriceIdStub        func([]datatypes.Product_Item, int, bool, datatypes.Location_Region) (int, error)
	getPortSpeedPriceIdMutex       sync.RWMutex
	getPortSpeedPriceIdArgsForCall []struct {
		arg1 []datatypes.Product_Item
		arg2 int
		arg3 bool
		arg4 datatypes.Location_Region
	}
	getPortSpeedPriceIdReturns struct {
		result1 int
		result2 error
	}
	getPortSpeedPriceIdReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	GetSensorDataStub        func(int, string) ([]datatypes.Container_RemoteManagement_SensorReading, error)
	getSensorDataMutex       sync.RWMutex
	getSensorDataArgsForCall []struct {
		arg1 int
		arg2 string
	}
	getSensorDataReturns struct {
		result1 []datatypes.Container_RemoteManagement_SensorReading
		result2 error
	}
	getSensorDataReturnsOnCall map[int]struct {
		result1 []datatypes.Container_RemoteManagement_SensorReading
		result2 error
	}
	GetStorageCredentialsStub        func(int) (datatypes.Network_Storage_Allowed_Host, error)
	getStorageCredentialsMutex       sync.RWMutex
	getStorageCredentialsArgsForCall []struct {
		arg1 int
	}
	getStorageCredentialsReturns struct {
		result1 datatypes.Network_Storage_Allowed_Host
		result2 error
	}
	getStorageCredentialsReturnsOnCall map[int]struct {
		result1 datatypes.Network_Storage_Allowed_Host
		result2 error
	}
	GetStorageDetailsStub        func(int, string) ([]datatypes.Network_Storage, error)
	getStorageDetailsMutex       sync.RWMutex
	getStorageDetailsArgsForCall []struct {
		arg1 int
		arg2 string
	}
	getStorageDetailsReturns struct {
		result1 []datatypes.Network_Storage
		result2 error
	}
	getStorageDetailsReturnsOnCall map[int]struct {
		result1 []datatypes.Network_Storage
		result2 error
	}
	GetUserCustomerNotificationsByHardwareIdStub        func(int, string) ([]datatypes.User_Customer_Notification_Hardware, error)
	getUserCustomerNotificationsByHardwareIdMutex       sync.RWMutex
	getUserCustomerNotificationsByHardwareIdArgsForCall []struct {
		arg1 int
		arg2 string
	}
	getUserCustomerNotificationsByHardwareIdReturns struct {
		result1 []datatypes.User_Customer_Notification_Hardware
		result2 error
	}
	getUserCustomerNotificationsByHardwareIdReturnsOnCall map[int]struct {
		result1 []datatypes.User_Customer_Notification_Hardware
		result2 error
	}
	ListHardwareStub        func([]string, int, int, string, string, string, int, string, string, string, int, string) ([]datatypes.Hardware_Server, error)
	listHardwareMutex       sync.RWMutex
	listHardwareArgsForCall []struct {
		arg1  []string
		arg2  int
		arg3  int
		arg4  string
		arg5  string
		arg6  string
		arg7  int
		arg8  string
		arg9  string
		arg10 string
		arg11 int
		arg12 string
	}
	listHardwareReturns struct {
		result1 []datatypes.Hardware_Server
		result2 error
	}
	listHardwareReturnsOnCall map[int]struct {
		result1 []datatypes.Hardware_Server
		result2 error
	}
	PlaceOrderStub        func(datatypes.Container_Product_Order) (datatypes.Container_Product_Order_Receipt, error)
	placeOrderMutex       sync.RWMutex
	placeOrderArgsForCall []struct {
		arg1 datatypes.Container_Product_Order
	}
	placeOrderReturns struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	placeOrderReturnsOnCall map[int]struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	PowerCycleStub        func(int) error
	powerCycleMutex       sync.RWMutex
	powerCycleArgsForCall []struct {
		arg1 int
	}
	powerCycleReturns struct {
		result1 error
	}
	powerCycleReturnsOnCall map[int]struct {
		result1 error
	}
	PowerOffStub        func(int) error
	powerOffMutex       sync.RWMutex
	powerOffArgsForCall []struct {
		arg1 int
	}
	powerOffReturns struct {
		result1 error
	}
	powerOffReturnsOnCall map[int]struct {
		result1 error
	}
	PowerOnStub        func(int) error
	powerOnMutex       sync.RWMutex
	powerOnArgsForCall []struct {
		arg1 int
	}
	powerOnReturns struct {
		result1 error
	}
	powerOnReturnsOnCall map[int]struct {
		result1 error
	}
	RebootStub        func(int, bool, bool) error
	rebootMutex       sync.RWMutex
	rebootArgsForCall []struct {
		arg1 int
		arg2 bool
		arg3 bool
	}
	rebootReturns struct {
		result1 error
	}
	rebootReturnsOnCall map[int]struct {
		result1 error
	}
	ReloadStub        func(int, string, []int, bool, bool) error
	reloadMutex       sync.RWMutex
	reloadArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 []int
		arg4 bool
		arg5 bool
	}
	reloadReturns struct {
		result1 error
	}
	reloadReturnsOnCall map[int]struct {
		result1 error
	}
	RescureStub        func(int) error
	rescureMutex       sync.RWMutex
	rescureArgsForCall []struct {
		arg1 int
	}
	rescureReturns struct {
		result1 error
	}
	rescureReturnsOnCall map[int]struct {
		result1 error
	}
	ToggleIPMIStub        func(int, bool) error
	toggleIPMIMutex       sync.RWMutex
	toggleIPMIArgsForCall []struct {
		arg1 int
		arg2 bool
	}
	toggleIPMIReturns struct {
		result1 error
	}
	toggleIPMIReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateFirmwareStub        func(int, bool, bool, bool, bool) error
	updateFirmwareMutex       sync.RWMutex
	updateFirmwareArgsForCall []struct {
		arg1 int
		arg2 bool
		arg3 bool
		arg4 bool
		arg5 bool
	}
	updateFirmwareReturns struct {
		result1 error
	}
	updateFirmwareReturnsOnCall map[int]struct {
		result1 error
	}
	VerifyOrderStub        func(datatypes.Container_Product_Order) (datatypes.Container_Product_Order, error)
	verifyOrderMutex       sync.RWMutex
	verifyOrderArgsForCall []struct {
		arg1 datatypes.Container_Product_Order
	}
	verifyOrderReturns struct {
		result1 datatypes.Container_Product_Order
		result2 error
	}
	verifyOrderReturnsOnCall map[int]struct {
		result1 datatypes.Container_Product_Order
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeHardwareServerManager) AuthorizeStorage(arg1 int, arg2 string) (bool, error) {
	fake.authorizeStorageMutex.Lock()
	ret, specificReturn := fake.authorizeStorageReturnsOnCall[len(fake.authorizeStorageArgsForCall)]
	fake.authorizeStorageArgsForCall = append(fake.authorizeStorageArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.AuthorizeStorageStub
	fakeReturns := fake.authorizeStorageReturns
	fake.recordInvocation("AuthorizeStorage", []interface{}{arg1, arg2})
	fake.authorizeStorageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHardwareServerManager) AuthorizeStorageCallCount() int {
	fake.authorizeStorageMutex.RLock()
	defer fake.authorizeStorageMutex.RUnlock()
	return len(fake.authorizeStorageArgsForCall)
}

func (fake *FakeHardwareServerManager) AuthorizeStorageCalls(stub func(int, string) (bool, error)) {
	fake.authorizeStorageMutex.Lock()
	defer fake.authorizeStorageMutex.Unlock()
	fake.AuthorizeStorageStub = stub
}

func (fake *FakeHardwareServerManager) AuthorizeStorageArgsForCall(i int) (int, string) {
	fake.authorizeStorageMutex.RLock()
	defer fake.authorizeStorageMutex.RUnlock()
	argsForCall := fake.authorizeStorageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeHardwareServerManager) AuthorizeStorageReturns(result1 bool, result2 error) {
	fake.authorizeStorageMutex.Lock()
	defer fake.authorizeStorageMutex.Unlock()
	fake.AuthorizeStorageStub = nil
	fake.authorizeStorageReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) AuthorizeStorageReturnsOnCall(i int, result1 bool, result2 error) {
	fake.authorizeStorageMutex.Lock()
	defer fake.authorizeStorageMutex.Unlock()
	fake.AuthorizeStorageStub = nil
	if fake.authorizeStorageReturnsOnCall == nil {
		fake.authorizeStorageReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.authorizeStorageReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) CancelHardware(arg1 int, arg2 string, arg3 string, arg4 bool) error {
	fake.cancelHardwareMutex.Lock()
	ret, specificReturn := fake.cancelHardwareReturnsOnCall[len(fake.cancelHardwareArgsForCall)]
	fake.cancelHardwareArgsForCall = append(fake.cancelHardwareArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 string
		arg4 bool
	}{arg1, arg2, arg3, arg4})
	stub := fake.CancelHardwareStub
	fakeReturns := fake.cancelHardwareReturns
	fake.recordInvocation("CancelHardware", []interface{}{arg1, arg2, arg3, arg4})
	fake.cancelHardwareMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeHardwareServerManager) CancelHardwareCallCount() int {
	fake.cancelHardwareMutex.RLock()
	defer fake.cancelHardwareMutex.RUnlock()
	return len(fake.cancelHardwareArgsForCall)
}

func (fake *FakeHardwareServerManager) CancelHardwareCalls(stub func(int, string, string, bool) error) {
	fake.cancelHardwareMutex.Lock()
	defer fake.cancelHardwareMutex.Unlock()
	fake.CancelHardwareStub = stub
}

func (fake *FakeHardwareServerManager) CancelHardwareArgsForCall(i int) (int, string, string, bool) {
	fake.cancelHardwareMutex.RLock()
	defer fake.cancelHardwareMutex.RUnlock()
	argsForCall := fake.cancelHardwareArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeHardwareServerManager) CancelHardwareReturns(result1 error) {
	fake.cancelHardwareMutex.Lock()
	defer fake.cancelHardwareMutex.Unlock()
	fake.CancelHardwareStub = nil
	fake.cancelHardwareReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeHardwareServerManager) CancelHardwareReturnsOnCall(i int, result1 error) {
	fake.cancelHardwareMutex.Lock()
	defer fake.cancelHardwareMutex.Unlock()
	fake.CancelHardwareStub = nil
	if fake.cancelHardwareReturnsOnCall == nil {
		fake.cancelHardwareReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelHardwareReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeHardwareServerManager) CreateFirmwareReflashTransaction(arg1 int) (bool, error) {
	fake.createFirmwareReflashTransactionMutex.Lock()
	ret, specificReturn := fake.createFirmwareReflashTransactionReturnsOnCall[len(fake.createFirmwareReflashTransactionArgsForCall)]
	fake.createFirmwareReflashTransactionArgsForCall = append(fake.createFirmwareReflashTransactionArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.CreateFirmwareReflashTransactionStub
	fakeReturns := fake.createFirmwareReflashTransactionReturns
	fake.recordInvocation("CreateFirmwareReflashTransaction", []interface{}{arg1})
	fake.createFirmwareReflashTransactionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHardwareServerManager) CreateFirmwareReflashTransactionCallCount() int {
	fake.createFirmwareReflashTransactionMutex.RLock()
	defer fake.createFirmwareReflashTransactionMutex.RUnlock()
	return len(fake.createFirmwareReflashTransactionArgsForCall)
}

func (fake *FakeHardwareServerManager) CreateFirmwareReflashTransactionCalls(stub func(int) (bool, error)) {
	fake.createFirmwareReflashTransactionMutex.Lock()
	defer fake.createFirmwareReflashTransactionMutex.Unlock()
	fake.CreateFirmwareReflashTransactionStub = stub
}

func (fake *FakeHardwareServerManager) CreateFirmwareReflashTransactionArgsForCall(i int) int {
	fake.createFirmwareReflashTransactionMutex.RLock()
	defer fake.createFirmwareReflashTransactionMutex.RUnlock()
	argsForCall := fake.createFirmwareReflashTransactionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeHardwareServerManager) CreateFirmwareReflashTransactionReturns(result1 bool, result2 error) {
	fake.createFirmwareReflashTransactionMutex.Lock()
	defer fake.createFirmwareReflashTransactionMutex.Unlock()
	fake.CreateFirmwareReflashTransactionStub = nil
	fake.createFirmwareReflashTransactionReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) CreateFirmwareReflashTransactionReturnsOnCall(i int, result1 bool, result2 error) {
	fake.createFirmwareReflashTransactionMutex.Lock()
	defer fake.createFirmwareReflashTransactionMutex.Unlock()
	fake.CreateFirmwareReflashTransactionStub = nil
	if fake.createFirmwareReflashTransactionReturnsOnCall == nil {
		fake.createFirmwareReflashTransactionReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.createFirmwareReflashTransactionReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) CreateUserCustomerNotification(arg1 int, arg2 int) (datatypes.User_Customer_Notification_Hardware, error) {
	fake.createUserCustomerNotificationMutex.Lock()
	ret, specificReturn := fake.createUserCustomerNotificationReturnsOnCall[len(fake.createUserCustomerNotificationArgsForCall)]
	fake.createUserCustomerNotificationArgsForCall = append(fake.createUserCustomerNotificationArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.CreateUserCustomerNotificationStub
	fakeReturns := fake.createUserCustomerNotificationReturns
	fake.recordInvocation("CreateUserCustomerNotification", []interface{}{arg1, arg2})
	fake.createUserCustomerNotificationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHardwareServerManager) CreateUserCustomerNotificationCallCount() int {
	fake.createUserCustomerNotificationMutex.RLock()
	defer fake.createUserCustomerNotificationMutex.RUnlock()
	return len(fake.createUserCustomerNotificationArgsForCall)
}

func (fake *FakeHardwareServerManager) CreateUserCustomerNotificationCalls(stub func(int, int) (datatypes.User_Customer_Notification_Hardware, error)) {
	fake.createUserCustomerNotificationMutex.Lock()
	defer fake.createUserCustomerNotificationMutex.Unlock()
	fake.CreateUserCustomerNotificationStub = stub
}

func (fake *FakeHardwareServerManager) CreateUserCustomerNotificationArgsForCall(i int) (int, int) {
	fake.createUserCustomerNotificationMutex.RLock()
	defer fake.createUserCustomerNotificationMutex.RUnlock()
	argsForCall := fake.createUserCustomerNotificationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeHardwareServerManager) CreateUserCustomerNotificationReturns(result1 datatypes.User_Customer_Notification_Hardware, result2 error) {
	fake.createUserCustomerNotificationMutex.Lock()
	defer fake.createUserCustomerNotificationMutex.Unlock()
	fake.CreateUserCustomerNotificationStub = nil
	fake.createUserCustomerNotificationReturns = struct {
		result1 datatypes.User_Customer_Notification_Hardware
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) CreateUserCustomerNotificationReturnsOnCall(i int, result1 datatypes.User_Customer_Notification_Hardware, result2 error) {
	fake.createUserCustomerNotificationMutex.Lock()
	defer fake.createUserCustomerNotificationMutex.Unlock()
	fake.CreateUserCustomerNotificationStub = nil
	if fake.createUserCustomerNotificationReturnsOnCall == nil {
		fake.createUserCustomerNotificationReturnsOnCall = make(map[int]struct {
			result1 datatypes.User_Customer_Notification_Hardware
			result2 error
		})
	}
	fake.createUserCustomerNotificationReturnsOnCall[i] = struct {
		result1 datatypes.User_Customer_Notification_Hardware
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) DeleteUserCustomerNotification(arg1 int) (bool, error) {
	fake.deleteUserCustomerNotificationMutex.Lock()
	ret, specificReturn := fake.deleteUserCustomerNotificationReturnsOnCall[len(fake.deleteUserCustomerNotificationArgsForCall)]
	fake.deleteUserCustomerNotificationArgsForCall = append(fake.deleteUserCustomerNotificationArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.DeleteUserCustomerNotificationStub
	fakeReturns := fake.deleteUserCustomerNotificationReturns
	fake.recordInvocation("DeleteUserCustomerNotification", []interface{}{arg1})
	fake.deleteUserCustomerNotificationMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHardwareServerManager) DeleteUserCustomerNotificationCallCount() int {
	fake.deleteUserCustomerNotificationMutex.RLock()
	defer fake.deleteUserCustomerNotificationMutex.RUnlock()
	return len(fake.deleteUserCustomerNotificationArgsForCall)
}

func (fake *FakeHardwareServerManager) DeleteUserCustomerNotificationCalls(stub func(int) (bool, error)) {
	fake.deleteUserCustomerNotificationMutex.Lock()
	defer fake.deleteUserCustomerNotificationMutex.Unlock()
	fake.DeleteUserCustomerNotificationStub = stub
}

func (fake *FakeHardwareServerManager) DeleteUserCustomerNotificationArgsForCall(i int) int {
	fake.deleteUserCustomerNotificationMutex.RLock()
	defer fake.deleteUserCustomerNotificationMutex.RUnlock()
	argsForCall := fake.deleteUserCustomerNotificationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeHardwareServerManager) DeleteUserCustomerNotificationReturns(result1 bool, result2 error) {
	fake.deleteUserCustomerNotificationMutex.Lock()
	defer fake.deleteUserCustomerNotificationMutex.Unlock()
	fake.DeleteUserCustomerNotificationStub = nil
	fake.deleteUserCustomerNotificationReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) DeleteUserCustomerNotificationReturnsOnCall(i int, result1 bool, result2 error) {
	fake.deleteUserCustomerNotificationMutex.Lock()
	defer fake.deleteUserCustomerNotificationMutex.Unlock()
	fake.DeleteUserCustomerNotificationStub = nil
	if fake.deleteUserCustomerNotificationReturnsOnCall == nil {
		fake.deleteUserCustomerNotificationReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.deleteUserCustomerNotificationReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) Edit(arg1 int, arg2 string, arg3 string, arg4 string, arg5 string, arg6 string, arg7 int, arg8 int) ([]bool, []string) {
	fake.editMutex.Lock()
	ret, specificReturn := fake.editReturnsOnCall[len(fake.editArgsForCall)]
	fake.editArgsForCall = append(fake.editArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 string
		arg7 int
		arg8 int
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8})
	stub := fake.EditStub
	fakeReturns := fake.editReturns
	fake.recordInvocation("Edit", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8})
	fake.editMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHardwareServerManager) EditCallCount() int {
	fake.editMutex.RLock()
	defer fake.editMutex.RUnlock()
	return len(fake.editArgsForCall)
}

func (fake *FakeHardwareServerManager) EditCalls(stub func(int, string, string, string, string, string, int, int) ([]bool, []string)) {
	fake.editMutex.Lock()
	defer fake.editMutex.Unlock()
	fake.EditStub = stub
}

func (fake *FakeHardwareServerManager) EditArgsForCall(i int) (int, string, string, string, string, string, int, int) {
	fake.editMutex.RLock()
	defer fake.editMutex.RUnlock()
	argsForCall := fake.editArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7, argsForCall.arg8
}

func (fake *FakeHardwareServerManager) EditReturns(result1 []bool, result2 []string) {
	fake.editMutex.Lock()
	defer fake.editMutex.Unlock()
	fake.EditStub = nil
	fake.editReturns = struct {
		result1 []bool
		result2 []string
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) EditReturnsOnCall(i int, result1 []bool, result2 []string) {
	fake.editMutex.Lock()
	defer fake.editMutex.Unlock()
	fake.EditStub = nil
	if fake.editReturnsOnCall == nil {
		fake.editReturnsOnCall = make(map[int]struct {
			result1 []bool
			result2 []string
		})
	}
	fake.editReturnsOnCall[i] = struct {
		result1 []bool
		result2 []string
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GenerateCreateTemplate(arg1 datatypes.Product_Package, arg2 map[string]interface{}) (datatypes.Container_Product_Order, error) {
	fake.generateCreateTemplateMutex.Lock()
	ret, specificReturn := fake.generateCreateTemplateReturnsOnCall[len(fake.generateCreateTemplateArgsForCall)]
	fake.generateCreateTemplateArgsForCall = append(fake.generateCreateTemplateArgsForCall, struct {
		arg1 datatypes.Product_Package
		arg2 map[string]interface{}
	}{arg1, arg2})
	stub := fake.GenerateCreateTemplateStub
	fakeReturns := fake.generateCreateTemplateReturns
	fake.recordInvocation("GenerateCreateTemplate", []interface{}{arg1, arg2})
	fake.generateCreateTemplateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHardwareServerManager) GenerateCreateTemplateCallCount() int {
	fake.generateCreateTemplateMutex.RLock()
	defer fake.generateCreateTemplateMutex.RUnlock()
	return len(fake.generateCreateTemplateArgsForCall)
}

func (fake *FakeHardwareServerManager) GenerateCreateTemplateCalls(stub func(datatypes.Product_Package, map[string]interface{}) (datatypes.Container_Product_Order, error)) {
	fake.generateCreateTemplateMutex.Lock()
	defer fake.generateCreateTemplateMutex.Unlock()
	fake.GenerateCreateTemplateStub = stub
}

func (fake *FakeHardwareServerManager) GenerateCreateTemplateArgsForCall(i int) (datatypes.Product_Package, map[string]interface{}) {
	fake.generateCreateTemplateMutex.RLock()
	defer fake.generateCreateTemplateMutex.RUnlock()
	argsForCall := fake.generateCreateTemplateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeHardwareServerManager) GenerateCreateTemplateReturns(result1 datatypes.Container_Product_Order, result2 error) {
	fake.generateCreateTemplateMutex.Lock()
	defer fake.generateCreateTemplateMutex.Unlock()
	fake.GenerateCreateTemplateStub = nil
	fake.generateCreateTemplateReturns = struct {
		result1 datatypes.Container_Product_Order
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GenerateCreateTemplateReturnsOnCall(i int, result1 datatypes.Container_Product_Order, result2 error) {
	fake.generateCreateTemplateMutex.Lock()
	defer fake.generateCreateTemplateMutex.Unlock()
	fake.GenerateCreateTemplateStub = nil
	if fake.generateCreateTemplateReturnsOnCall == nil {
		fake.generateCreateTemplateReturnsOnCall = make(map[int]struct {
			result1 datatypes.Container_Product_Order
			result2 error
		})
	}
	fake.generateCreateTemplateReturnsOnCall[i] = struct {
		result1 datatypes.Container_Product_Order
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetBandwidthAllotmentDetail(arg1 int, arg2 string) (datatypes.Network_Bandwidth_Version1_Allotment_Detail, error) {
	fake.getBandwidthAllotmentDetailMutex.Lock()
	ret, specificReturn := fake.getBandwidthAllotmentDetailReturnsOnCall[len(fake.getBandwidthAllotmentDetailArgsForCall)]
	fake.getBandwidthAllotmentDetailArgsForCall = append(fake.getBandwidthAllotmentDetailArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.GetBandwidthAllotmentDetailStub
	fakeReturns := fake.getBandwidthAllotmentDetailReturns
	fake.recordInvocation("GetBandwidthAllotmentDetail", []interface{}{arg1, arg2})
	fake.getBandwidthAllotmentDetailMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHardwareServerManager) GetBandwidthAllotmentDetailCallCount() int {
	fake.getBandwidthAllotmentDetailMutex.RLock()
	defer fake.getBandwidthAllotmentDetailMutex.RUnlock()
	return len(fake.getBandwidthAllotmentDetailArgsForCall)
}

func (fake *FakeHardwareServerManager) GetBandwidthAllotmentDetailCalls(stub func(int, string) (datatypes.Network_Bandwidth_Version1_Allotment_Detail, error)) {
	fake.getBandwidthAllotmentDetailMutex.Lock()
	defer fake.getBandwidthAllotmentDetailMutex.Unlock()
	fake.GetBandwidthAllotmentDetailStub = stub
}

func (fake *FakeHardwareServerManager) GetBandwidthAllotmentDetailArgsForCall(i int) (int, string) {
	fake.getBandwidthAllotmentDetailMutex.RLock()
	defer fake.getBandwidthAllotmentDetailMutex.RUnlock()
	argsForCall := fake.getBandwidthAllotmentDetailArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeHardwareServerManager) GetBandwidthAllotmentDetailReturns(result1 datatypes.Network_Bandwidth_Version1_Allotment_Detail, result2 error) {
	fake.getBandwidthAllotmentDetailMutex.Lock()
	defer fake.getBandwidthAllotmentDetailMutex.Unlock()
	fake.GetBandwidthAllotmentDetailStub = nil
	fake.getBandwidthAllotmentDetailReturns = struct {
		result1 datatypes.Network_Bandwidth_Version1_Allotment_Detail
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetBandwidthAllotmentDetailReturnsOnCall(i int, result1 datatypes.Network_Bandwidth_Version1_Allotment_Detail, result2 error) {
	fake.getBandwidthAllotmentDetailMutex.Lock()
	defer fake.getBandwidthAllotmentDetailMutex.Unlock()
	fake.GetBandwidthAllotmentDetailStub = nil
	if fake.getBandwidthAllotmentDetailReturnsOnCall == nil {
		fake.getBandwidthAllotmentDetailReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_Bandwidth_Version1_Allotment_Detail
			result2 error
		})
	}
	fake.getBandwidthAllotmentDetailReturnsOnCall[i] = struct {
		result1 datatypes.Network_Bandwidth_Version1_Allotment_Detail
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetBandwidthData(arg1 int, arg2 time.Time, arg3 time.Time, arg4 int) ([]datatypes.Metric_Tracking_Object_Data, error) {
	fake.getBandwidthDataMutex.Lock()
	ret, specificReturn := fake.getBandwidthDataReturnsOnCall[len(fake.getBandwidthDataArgsForCall)]
	fake.getBandwidthDataArgsForCall = append(fake.getBandwidthDataArgsForCall, struct {
		arg1 int
		arg2 time.Time
		arg3 time.Time
		arg4 int
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetBandwidthDataStub
	fakeReturns := fake.getBandwidthDataReturns
	fake.recordInvocation("GetBandwidthData", []interface{}{arg1, arg2, arg3, arg4})
	fake.getBandwidthDataMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHardwareServerManager) GetBandwidthDataCallCount() int {
	fake.getBandwidthDataMutex.RLock()
	defer fake.getBandwidthDataMutex.RUnlock()
	return len(fake.getBandwidthDataArgsForCall)
}

func (fake *FakeHardwareServerManager) GetBandwidthDataCalls(stub func(int, time.Time, time.Time, int) ([]datatypes.Metric_Tracking_Object_Data, error)) {
	fake.getBandwidthDataMutex.Lock()
	defer fake.getBandwidthDataMutex.Unlock()
	fake.GetBandwidthDataStub = stub
}

func (fake *FakeHardwareServerManager) GetBandwidthDataArgsForCall(i int) (int, time.Time, time.Time, int) {
	fake.getBandwidthDataMutex.RLock()
	defer fake.getBandwidthDataMutex.RUnlock()
	argsForCall := fake.getBandwidthDataArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeHardwareServerManager) GetBandwidthDataReturns(result1 []datatypes.Metric_Tracking_Object_Data, result2 error) {
	fake.getBandwidthDataMutex.Lock()
	defer fake.getBandwidthDataMutex.Unlock()
	fake.GetBandwidthDataStub = nil
	fake.getBandwidthDataReturns = struct {
		result1 []datatypes.Metric_Tracking_Object_Data
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetBandwidthDataReturnsOnCall(i int, result1 []datatypes.Metric_Tracking_Object_Data, result2 error) {
	fake.getBandwidthDataMutex.Lock()
	defer fake.getBandwidthDataMutex.Unlock()
	fake.GetBandwidthDataStub = nil
	if fake.getBandwidthDataReturnsOnCall == nil {
		fake.getBandwidthDataReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Metric_Tracking_Object_Data
			result2 error
		})
	}
	fake.getBandwidthDataReturnsOnCall[i] = struct {
		result1 []datatypes.Metric_Tracking_Object_Data
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetBandwidthPriceId(arg1 []datatypes.Product_Item, arg2 bool, arg3 bool, arg4 datatypes.Location_Region) (int, error) {
	var arg1Copy []datatypes.Product_Item
	if arg1 != nil {
		arg1Copy = make([]datatypes.Product_Item, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.getBandwidthPriceIdMutex.Lock()
	ret, specificReturn := fake.getBandwidthPriceIdReturnsOnCall[len(fake.getBandwidthPriceIdArgsForCall)]
	fake.getBandwidthPriceIdArgsForCall = append(fake.getBandwidthPriceIdArgsForCall, struct {
		arg1 []datatypes.Product_Item
		arg2 bool
		arg3 bool
		arg4 datatypes.Location_Region
	}{arg1Copy, arg2, arg3, arg4})
	stub := fake.GetBandwidthPriceIdStub
	fakeReturns := fake.getBandwidthPriceIdReturns
	fake.recordInvocation("GetBandwidthPriceId", []interface{}{arg1Copy, arg2, arg3, arg4})
	fake.getBandwidthPriceIdMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHardwareServerManager) GetBandwidthPriceIdCallCount() int {
	fake.getBandwidthPriceIdMutex.RLock()
	defer fake.getBandwidthPriceIdMutex.RUnlock()
	return len(fake.getBandwidthPriceIdArgsForCall)
}

func (fake *FakeHardwareServerManager) GetBandwidthPriceIdCalls(stub func([]datatypes.Product_Item, bool, bool, datatypes.Location_Region) (int, error)) {
	fake.getBandwidthPriceIdMutex.Lock()
	defer fake.getBandwidthPriceIdMutex.Unlock()
	fake.GetBandwidthPriceIdStub = stub
}

func (fake *FakeHardwareServerManager) GetBandwidthPriceIdArgsForCall(i int) ([]datatypes.Product_Item, bool, bool, datatypes.Location_Region) {
	fake.getBandwidthPriceIdMutex.RLock()
	defer fake.getBandwidthPriceIdMutex.RUnlock()
	argsForCall := fake.getBandwidthPriceIdArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeHardwareServerManager) GetBandwidthPriceIdReturns(result1 int, result2 error) {
	fake.getBandwidthPriceIdMutex.Lock()
	defer fake.getBandwidthPriceIdMutex.Unlock()
	fake.GetBandwidthPriceIdStub = nil
	fake.getBandwidthPriceIdReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetBandwidthPriceIdReturnsOnCall(i int, result1 int, result2 error) {
	fake.getBandwidthPriceIdMutex.Lock()
	defer fake.getBandwidthPriceIdMutex.Unlock()
	fake.GetBandwidthPriceIdStub = nil
	if fake.getBandwidthPriceIdReturnsOnCall == nil {
		fake.getBandwidthPriceIdReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.getBandwidthPriceIdReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetBillingCycleBandwidthUsage(arg1 int, arg2 string) ([]datatypes.Network_Bandwidth_Usage, error) {
	fake.getBillingCycleBandwidthUsageMutex.Lock()
	ret, specificReturn := fake.getBillingCycleBandwidthUsageReturnsOnCall[len(fake.getBillingCycleBandwidthUsageArgsForCall)]
	fake.getBillingCycleBandwidthUsageArgsForCall = append(fake.getBillingCycleBandwidthUsageArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.GetBillingCycleBandwidthUsageStub
	fakeReturns := fake.getBillingCycleBandwidthUsageReturns
	fake.recordInvocation("GetBillingCycleBandwidthUsage", []interface{}{arg1, arg2})
	fake.getBillingCycleBandwidthUsageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHardwareServerManager) GetBillingCycleBandwidthUsageCallCount() int {
	fake.getBillingCycleBandwidthUsageMutex.RLock()
	defer fake.getBillingCycleBandwidthUsageMutex.RUnlock()
	return len(fake.getBillingCycleBandwidthUsageArgsForCall)
}

func (fake *FakeHardwareServerManager) GetBillingCycleBandwidthUsageCalls(stub func(int, string) ([]datatypes.Network_Bandwidth_Usage, error)) {
	fake.getBillingCycleBandwidthUsageMutex.Lock()
	defer fake.getBillingCycleBandwidthUsageMutex.Unlock()
	fake.GetBillingCycleBandwidthUsageStub = stub
}

func (fake *FakeHardwareServerManager) GetBillingCycleBandwidthUsageArgsForCall(i int) (int, string) {
	fake.getBillingCycleBandwidthUsageMutex.RLock()
	defer fake.getBillingCycleBandwidthUsageMutex.RUnlock()
	argsForCall := fake.getBillingCycleBandwidthUsageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeHardwareServerManager) GetBillingCycleBandwidthUsageReturns(result1 []datatypes.Network_Bandwidth_Usage, result2 error) {
	fake.getBillingCycleBandwidthUsageMutex.Lock()
	defer fake.getBillingCycleBandwidthUsageMutex.Unlock()
	fake.GetBillingCycleBandwidthUsageStub = nil
	fake.getBillingCycleBandwidthUsageReturns = struct {
		result1 []datatypes.Network_Bandwidth_Usage
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetBillingCycleBandwidthUsageReturnsOnCall(i int, result1 []datatypes.Network_Bandwidth_Usage, result2 error) {
	fake.getBillingCycleBandwidthUsageMutex.Lock()
	defer fake.getBillingCycleBandwidthUsageMutex.Unlock()
	fake.GetBillingCycleBandwidthUsageStub = nil
	if fake.getBillingCycleBandwidthUsageReturnsOnCall == nil {
		fake.getBillingCycleBandwidthUsageReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Network_Bandwidth_Usage
			result2 error
		})
	}
	fake.getBillingCycleBandwidthUsageReturnsOnCall[i] = struct {
		result1 []datatypes.Network_Bandwidth_Usage
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetCancellationReasons() map[string]string {
	fake.getCancellationReasonsMutex.Lock()
	ret, specificReturn := fake.getCancellationReasonsReturnsOnCall[len(fake.getCancellationReasonsArgsForCall)]
	fake.getCancellationReasonsArgsForCall = append(fake.getCancellationReasonsArgsForCall, struct {
	}{})
	stub := fake.GetCancellationReasonsStub
	fakeReturns := fake.getCancellationReasonsReturns
	fake.recordInvocation("GetCancellationReasons", []interface{}{})
	fake.getCancellationReasonsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeHardwareServerManager) GetCancellationReasonsCallCount() int {
	fake.getCancellationReasonsMutex.RLock()
	defer fake.getCancellationReasonsMutex.RUnlock()
	return len(fake.getCancellationReasonsArgsForCall)
}

func (fake *FakeHardwareServerManager) GetCancellationReasonsCalls(stub func() map[string]string) {
	fake.getCancellationReasonsMutex.Lock()
	defer fake.getCancellationReasonsMutex.Unlock()
	fake.GetCancellationReasonsStub = stub
}

func (fake *FakeHardwareServerManager) GetCancellationReasonsReturns(result1 map[string]string) {
	fake.getCancellationReasonsMutex.Lock()
	defer fake.getCancellationReasonsMutex.Unlock()
	fake.GetCancellationReasonsStub = nil
	fake.getCancellationReasonsReturns = struct {
		result1 map[string]string
	}{result1}
}

func (fake *FakeHardwareServerManager) GetCancellationReasonsReturnsOnCall(i int, result1 map[string]string) {
	fake.getCancellationReasonsMutex.Lock()
	defer fake.getCancellationReasonsMutex.Unlock()
	fake.GetCancellationReasonsStub = nil
	if fake.getCancellationReasonsReturnsOnCall == nil {
		fake.getCancellationReasonsReturnsOnCall = make(map[int]struct {
			result1 map[string]string
		})
	}
	fake.getCancellationReasonsReturnsOnCall[i] = struct {
		result1 map[string]string
	}{result1}
}

func (fake *FakeHardwareServerManager) GetCreateOptions(arg1 datatypes.Product_Package) map[string]map[string]string {
	fake.getCreateOptionsMutex.Lock()
	ret, specificReturn := fake.getCreateOptionsReturnsOnCall[len(fake.getCreateOptionsArgsForCall)]
	fake.getCreateOptionsArgsForCall = append(fake.getCreateOptionsArgsForCall, struct {
		arg1 datatypes.Product_Package
	}{arg1})
	stub := fake.GetCreateOptionsStub
	fakeReturns := fake.getCreateOptionsReturns
	fake.recordInvocation("GetCreateOptions", []interface{}{arg1})
	fake.getCreateOptionsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeHardwareServerManager) GetCreateOptionsCallCount() int {
	fake.getCreateOptionsMutex.RLock()
	defer fake.getCreateOptionsMutex.RUnlock()
	return len(fake.getCreateOptionsArgsForCall)
}

func (fake *FakeHardwareServerManager) GetCreateOptionsCalls(stub func(datatypes.Product_Package) map[string]map[string]string) {
	fake.getCreateOptionsMutex.Lock()
	defer fake.getCreateOptionsMutex.Unlock()
	fake.GetCreateOptionsStub = stub
}

func (fake *FakeHardwareServerManager) GetCreateOptionsArgsForCall(i int) datatypes.Product_Package {
	fake.getCreateOptionsMutex.RLock()
	defer fake.getCreateOptionsMutex.RUnlock()
	argsForCall := fake.getCreateOptionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeHardwareServerManager) GetCreateOptionsReturns(result1 map[string]map[string]string) {
	fake.getCreateOptionsMutex.Lock()
	defer fake.getCreateOptionsMutex.Unlock()
	fake.GetCreateOptionsStub = nil
	fake.getCreateOptionsReturns = struct {
		result1 map[string]map[string]string
	}{result1}
}

func (fake *FakeHardwareServerManager) GetCreateOptionsReturnsOnCall(i int, result1 map[string]map[string]string) {
	fake.getCreateOptionsMutex.Lock()
	defer fake.getCreateOptionsMutex.Unlock()
	fake.GetCreateOptionsStub = nil
	if fake.getCreateOptionsReturnsOnCall == nil {
		fake.getCreateOptionsReturnsOnCall = make(map[int]struct {
			result1 map[string]map[string]string
		})
	}
	fake.getCreateOptionsReturnsOnCall[i] = struct {
		result1 map[string]map[string]string
	}{result1}
}

func (fake *FakeHardwareServerManager) GetDefaultPriceId(arg1 []datatypes.Product_Item, arg2 string, arg3 bool, arg4 datatypes.Location_Region) (int, error) {
	var arg1Copy []datatypes.Product_Item
	if arg1 != nil {
		arg1Copy = make([]datatypes.Product_Item, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.getDefaultPriceIdMutex.Lock()
	ret, specificReturn := fake.getDefaultPriceIdReturnsOnCall[len(fake.getDefaultPriceIdArgsForCall)]
	fake.getDefaultPriceIdArgsForCall = append(fake.getDefaultPriceIdArgsForCall, struct {
		arg1 []datatypes.Product_Item
		arg2 string
		arg3 bool
		arg4 datatypes.Location_Region
	}{arg1Copy, arg2, arg3, arg4})
	stub := fake.GetDefaultPriceIdStub
	fakeReturns := fake.getDefaultPriceIdReturns
	fake.recordInvocation("GetDefaultPriceId", []interface{}{arg1Copy, arg2, arg3, arg4})
	fake.getDefaultPriceIdMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHardwareServerManager) GetDefaultPriceIdCallCount() int {
	fake.getDefaultPriceIdMutex.RLock()
	defer fake.getDefaultPriceIdMutex.RUnlock()
	return len(fake.getDefaultPriceIdArgsForCall)
}

func (fake *FakeHardwareServerManager) GetDefaultPriceIdCalls(stub func([]datatypes.Product_Item, string, bool, datatypes.Location_Region) (int, error)) {
	fake.getDefaultPriceIdMutex.Lock()
	defer fake.getDefaultPriceIdMutex.Unlock()
	fake.GetDefaultPriceIdStub = stub
}

func (fake *FakeHardwareServerManager) GetDefaultPriceIdArgsForCall(i int) ([]datatypes.Product_Item, string, bool, datatypes.Location_Region) {
	fake.getDefaultPriceIdMutex.RLock()
	defer fake.getDefaultPriceIdMutex.RUnlock()
	argsForCall := fake.getDefaultPriceIdArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeHardwareServerManager) GetDefaultPriceIdReturns(result1 int, result2 error) {
	fake.getDefaultPriceIdMutex.Lock()
	defer fake.getDefaultPriceIdMutex.Unlock()
	fake.GetDefaultPriceIdStub = nil
	fake.getDefaultPriceIdReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetDefaultPriceIdReturnsOnCall(i int, result1 int, result2 error) {
	fake.getDefaultPriceIdMutex.Lock()
	defer fake.getDefaultPriceIdMutex.Unlock()
	fake.GetDefaultPriceIdStub = nil
	if fake.getDefaultPriceIdReturnsOnCall == nil {
		fake.getDefaultPriceIdReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.getDefaultPriceIdReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetExtraPriceId(arg1 []datatypes.Product_Item, arg2 string, arg3 bool, arg4 datatypes.Location_Region) (int, error) {
	var arg1Copy []datatypes.Product_Item
	if arg1 != nil {
		arg1Copy = make([]datatypes.Product_Item, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.getExtraPriceIdMutex.Lock()
	ret, specificReturn := fake.getExtraPriceIdReturnsOnCall[len(fake.getExtraPriceIdArgsForCall)]
	fake.getExtraPriceIdArgsForCall = append(fake.getExtraPriceIdArgsForCall, struct {
		arg1 []datatypes.Product_Item
		arg2 string
		arg3 bool
		arg4 datatypes.Location_Region
	}{arg1Copy, arg2, arg3, arg4})
	stub := fake.GetExtraPriceIdStub
	fakeReturns := fake.getExtraPriceIdReturns
	fake.recordInvocation("GetExtraPriceId", []interface{}{arg1Copy, arg2, arg3, arg4})
	fake.getExtraPriceIdMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHardwareServerManager) GetExtraPriceIdCallCount() int {
	fake.getExtraPriceIdMutex.RLock()
	defer fake.getExtraPriceIdMutex.RUnlock()
	return len(fake.getExtraPriceIdArgsForCall)
}

func (fake *FakeHardwareServerManager) GetExtraPriceIdCalls(stub func([]datatypes.Product_Item, string, bool, datatypes.Location_Region) (int, error)) {
	fake.getExtraPriceIdMutex.Lock()
	defer fake.getExtraPriceIdMutex.Unlock()
	fake.GetExtraPriceIdStub = stub
}

func (fake *FakeHardwareServerManager) GetExtraPriceIdArgsForCall(i int) ([]datatypes.Product_Item, string, bool, datatypes.Location_Region) {
	fake.getExtraPriceIdMutex.RLock()
	defer fake.getExtraPriceIdMutex.RUnlock()
	argsForCall := fake.getExtraPriceIdArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeHardwareServerManager) GetExtraPriceIdReturns(result1 int, result2 error) {
	fake.getExtraPriceIdMutex.Lock()
	defer fake.getExtraPriceIdMutex.Unlock()
	fake.GetExtraPriceIdStub = nil
	fake.getExtraPriceIdReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetExtraPriceIdReturnsOnCall(i int, result1 int, result2 error) {
	fake.getExtraPriceIdMutex.Lock()
	defer fake.getExtraPriceIdMutex.Unlock()
	fake.GetExtraPriceIdStub = nil
	if fake.getExtraPriceIdReturnsOnCall == nil {
		fake.getExtraPriceIdReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.getExtraPriceIdReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetHardDrives(arg1 int) ([]datatypes.Hardware_Component, error) {
	fake.getHardDrivesMutex.Lock()
	ret, specificReturn := fake.getHardDrivesReturnsOnCall[len(fake.getHardDrivesArgsForCall)]
	fake.getHardDrivesArgsForCall = append(fake.getHardDrivesArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.GetHardDrivesStub
	fakeReturns := fake.getHardDrivesReturns
	fake.recordInvocation("GetHardDrives", []interface{}{arg1})
	fake.getHardDrivesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHardwareServerManager) GetHardDrivesCallCount() int {
	fake.getHardDrivesMutex.RLock()
	defer fake.getHardDrivesMutex.RUnlock()
	return len(fake.getHardDrivesArgsForCall)
}

func (fake *FakeHardwareServerManager) GetHardDrivesCalls(stub func(int) ([]datatypes.Hardware_Component, error)) {
	fake.getHardDrivesMutex.Lock()
	defer fake.getHardDrivesMutex.Unlock()
	fake.GetHardDrivesStub = stub
}

func (fake *FakeHardwareServerManager) GetHardDrivesArgsForCall(i int) int {
	fake.getHardDrivesMutex.RLock()
	defer fake.getHardDrivesMutex.RUnlock()
	argsForCall := fake.getHardDrivesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeHardwareServerManager) GetHardDrivesReturns(result1 []datatypes.Hardware_Component, result2 error) {
	fake.getHardDrivesMutex.Lock()
	defer fake.getHardDrivesMutex.Unlock()
	fake.GetHardDrivesStub = nil
	fake.getHardDrivesReturns = struct {
		result1 []datatypes.Hardware_Component
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetHardDrivesReturnsOnCall(i int, result1 []datatypes.Hardware_Component, result2 error) {
	fake.getHardDrivesMutex.Lock()
	defer fake.getHardDrivesMutex.Unlock()
	fake.GetHardDrivesStub = nil
	if fake.getHardDrivesReturnsOnCall == nil {
		fake.getHardDrivesReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Hardware_Component
			result2 error
		})
	}
	fake.getHardDrivesReturnsOnCall[i] = struct {
		result1 []datatypes.Hardware_Component
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetHardware(arg1 int, arg2 string) (datatypes.Hardware_Server, error) {
	fake.getHardwareMutex.Lock()
	ret, specificReturn := fake.getHardwareReturnsOnCall[len(fake.getHardwareArgsForCall)]
	fake.getHardwareArgsForCall = append(fake.getHardwareArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.GetHardwareStub
	fakeReturns := fake.getHardwareReturns
	fake.recordInvocation("GetHardware", []interface{}{arg1, arg2})
	fake.getHardwareMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHardwareServerManager) GetHardwareCallCount() int {
	fake.getHardwareMutex.RLock()
	defer fake.getHardwareMutex.RUnlock()
	return len(fake.getHardwareArgsForCall)
}

func (fake *FakeHardwareServerManager) GetHardwareCalls(stub func(int, string) (datatypes.Hardware_Server, error)) {
	fake.getHardwareMutex.Lock()
	defer fake.getHardwareMutex.Unlock()
	fake.GetHardwareStub = stub
}

func (fake *FakeHardwareServerManager) GetHardwareArgsForCall(i int) (int, string) {
	fake.getHardwareMutex.RLock()
	defer fake.getHardwareMutex.RUnlock()
	argsForCall := fake.getHardwareArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeHardwareServerManager) GetHardwareReturns(result1 datatypes.Hardware_Server, result2 error) {
	fake.getHardwareMutex.Lock()
	defer fake.getHardwareMutex.Unlock()
	fake.GetHardwareStub = nil
	fake.getHardwareReturns = struct {
		result1 datatypes.Hardware_Server
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetHardwareReturnsOnCall(i int, result1 datatypes.Hardware_Server, result2 error) {
	fake.getHardwareMutex.Lock()
	defer fake.getHardwareMutex.Unlock()
	fake.GetHardwareStub = nil
	if fake.getHardwareReturnsOnCall == nil {
		fake.getHardwareReturnsOnCall = make(map[int]struct {
			result1 datatypes.Hardware_Server
			result2 error
		})
	}
	fake.getHardwareReturnsOnCall[i] = struct {
		result1 datatypes.Hardware_Server
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetHardwareComponents(arg1 int) ([]datatypes.Hardware_Component, error) {
	fake.getHardwareComponentsMutex.Lock()
	ret, specificReturn := fake.getHardwareComponentsReturnsOnCall[len(fake.getHardwareComponentsArgsForCall)]
	fake.getHardwareComponentsArgsForCall = append(fake.getHardwareComponentsArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.GetHardwareComponentsStub
	fakeReturns := fake.getHardwareComponentsReturns
	fake.recordInvocation("GetHardwareComponents", []interface{}{arg1})
	fake.getHardwareComponentsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHardwareServerManager) GetHardwareComponentsCallCount() int {
	fake.getHardwareComponentsMutex.RLock()
	defer fake.getHardwareComponentsMutex.RUnlock()
	return len(fake.getHardwareComponentsArgsForCall)
}

func (fake *FakeHardwareServerManager) GetHardwareComponentsCalls(stub func(int) ([]datatypes.Hardware_Component, error)) {
	fake.getHardwareComponentsMutex.Lock()
	defer fake.getHardwareComponentsMutex.Unlock()
	fake.GetHardwareComponentsStub = stub
}

func (fake *FakeHardwareServerManager) GetHardwareComponentsArgsForCall(i int) int {
	fake.getHardwareComponentsMutex.RLock()
	defer fake.getHardwareComponentsMutex.RUnlock()
	argsForCall := fake.getHardwareComponentsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeHardwareServerManager) GetHardwareComponentsReturns(result1 []datatypes.Hardware_Component, result2 error) {
	fake.getHardwareComponentsMutex.Lock()
	defer fake.getHardwareComponentsMutex.Unlock()
	fake.GetHardwareComponentsStub = nil
	fake.getHardwareComponentsReturns = struct {
		result1 []datatypes.Hardware_Component
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetHardwareComponentsReturnsOnCall(i int, result1 []datatypes.Hardware_Component, result2 error) {
	fake.getHardwareComponentsMutex.Lock()
	defer fake.getHardwareComponentsMutex.Unlock()
	fake.GetHardwareComponentsStub = nil
	if fake.getHardwareComponentsReturnsOnCall == nil {
		fake.getHardwareComponentsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Hardware_Component
			result2 error
		})
	}
	fake.getHardwareComponentsReturnsOnCall[i] = struct {
		result1 []datatypes.Hardware_Component
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetOSPriceId(arg1 []datatypes.Product_Item, arg2 string, arg3 datatypes.Location_Region) (int, error) {
	var arg1Copy []datatypes.Product_Item
	if arg1 != nil {
		arg1Copy = make([]datatypes.Product_Item, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.getOSPriceIdMutex.Lock()
	ret, specificReturn := fake.getOSPriceIdReturnsOnCall[len(fake.getOSPriceIdArgsForCall)]
	fake.getOSPriceIdArgsForCall = append(fake.getOSPriceIdArgsForCall, struct {
		arg1 []datatypes.Product_Item
		arg2 string
		arg3 datatypes.Location_Region
	}{arg1Copy, arg2, arg3})
	stub := fake.GetOSPriceIdStub
	fakeReturns := fake.getOSPriceIdReturns
	fake.recordInvocation("GetOSPriceId", []interface{}{arg1Copy, arg2, arg3})
	fake.getOSPriceIdMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHardwareServerManager) GetOSPriceIdCallCount() int {
	fake.getOSPriceIdMutex.RLock()
	defer fake.getOSPriceIdMutex.RUnlock()
	return len(fake.getOSPriceIdArgsForCall)
}

func (fake *FakeHardwareServerManager) GetOSPriceIdCalls(stub func([]datatypes.Product_Item, string, datatypes.Location_Region) (int, error)) {
	fake.getOSPriceIdMutex.Lock()
	defer fake.getOSPriceIdMutex.Unlock()
	fake.GetOSPriceIdStub = stub
}

func (fake *FakeHardwareServerManager) GetOSPriceIdArgsForCall(i int) ([]datatypes.Product_Item, string, datatypes.Location_Region) {
	fake.getOSPriceIdMutex.RLock()
	defer fake.getOSPriceIdMutex.RUnlock()
	argsForCall := fake.getOSPriceIdArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeHardwareServerManager) GetOSPriceIdReturns(result1 int, result2 error) {
	fake.getOSPriceIdMutex.Lock()
	defer fake.getOSPriceIdMutex.Unlock()
	fake.GetOSPriceIdStub = nil
	fake.getOSPriceIdReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetOSPriceIdReturnsOnCall(i int, result1 int, result2 error) {
	fake.getOSPriceIdMutex.Lock()
	defer fake.getOSPriceIdMutex.Unlock()
	fake.GetOSPriceIdStub = nil
	if fake.getOSPriceIdReturnsOnCall == nil {
		fake.getOSPriceIdReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.getOSPriceIdReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetPackage() (datatypes.Product_Package, error) {
	fake.getPackageMutex.Lock()
	ret, specificReturn := fake.getPackageReturnsOnCall[len(fake.getPackageArgsForCall)]
	fake.getPackageArgsForCall = append(fake.getPackageArgsForCall, struct {
	}{})
	stub := fake.GetPackageStub
	fakeReturns := fake.getPackageReturns
	fake.recordInvocation("GetPackage", []interface{}{})
	fake.getPackageMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHardwareServerManager) GetPackageCallCount() int {
	fake.getPackageMutex.RLock()
	defer fake.getPackageMutex.RUnlock()
	return len(fake.getPackageArgsForCall)
}

func (fake *FakeHardwareServerManager) GetPackageCalls(stub func() (datatypes.Product_Package, error)) {
	fake.getPackageMutex.Lock()
	defer fake.getPackageMutex.Unlock()
	fake.GetPackageStub = stub
}

func (fake *FakeHardwareServerManager) GetPackageReturns(result1 datatypes.Product_Package, result2 error) {
	fake.getPackageMutex.Lock()
	defer fake.getPackageMutex.Unlock()
	fake.GetPackageStub = nil
	fake.getPackageReturns = struct {
		result1 datatypes.Product_Package
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetPackageReturnsOnCall(i int, result1 datatypes.Product_Package, result2 error) {
	fake.getPackageMutex.Lock()
	defer fake.getPackageMutex.Unlock()
	fake.GetPackageStub = nil
	if fake.getPackageReturnsOnCall == nil {
		fake.getPackageReturnsOnCall = make(map[int]struct {
			result1 datatypes.Product_Package
			result2 error
		})
	}
	fake.getPackageReturnsOnCall[i] = struct {
		result1 datatypes.Product_Package
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetPortSpeedPriceId(arg1 []datatypes.Product_Item, arg2 int, arg3 bool, arg4 datatypes.Location_Region) (int, error) {
	var arg1Copy []datatypes.Product_Item
	if arg1 != nil {
		arg1Copy = make([]datatypes.Product_Item, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.getPortSpeedPriceIdMutex.Lock()
	ret, specificReturn := fake.getPortSpeedPriceIdReturnsOnCall[len(fake.getPortSpeedPriceIdArgsForCall)]
	fake.getPortSpeedPriceIdArgsForCall = append(fake.getPortSpeedPriceIdArgsForCall, struct {
		arg1 []datatypes.Product_Item
		arg2 int
		arg3 bool
		arg4 datatypes.Location_Region
	}{arg1Copy, arg2, arg3, arg4})
	stub := fake.GetPortSpeedPriceIdStub
	fakeReturns := fake.getPortSpeedPriceIdReturns
	fake.recordInvocation("GetPortSpeedPriceId", []interface{}{arg1Copy, arg2, arg3, arg4})
	fake.getPortSpeedPriceIdMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHardwareServerManager) GetPortSpeedPriceIdCallCount() int {
	fake.getPortSpeedPriceIdMutex.RLock()
	defer fake.getPortSpeedPriceIdMutex.RUnlock()
	return len(fake.getPortSpeedPriceIdArgsForCall)
}

func (fake *FakeHardwareServerManager) GetPortSpeedPriceIdCalls(stub func([]datatypes.Product_Item, int, bool, datatypes.Location_Region) (int, error)) {
	fake.getPortSpeedPriceIdMutex.Lock()
	defer fake.getPortSpeedPriceIdMutex.Unlock()
	fake.GetPortSpeedPriceIdStub = stub
}

func (fake *FakeHardwareServerManager) GetPortSpeedPriceIdArgsForCall(i int) ([]datatypes.Product_Item, int, bool, datatypes.Location_Region) {
	fake.getPortSpeedPriceIdMutex.RLock()
	defer fake.getPortSpeedPriceIdMutex.RUnlock()
	argsForCall := fake.getPortSpeedPriceIdArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeHardwareServerManager) GetPortSpeedPriceIdReturns(result1 int, result2 error) {
	fake.getPortSpeedPriceIdMutex.Lock()
	defer fake.getPortSpeedPriceIdMutex.Unlock()
	fake.GetPortSpeedPriceIdStub = nil
	fake.getPortSpeedPriceIdReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetPortSpeedPriceIdReturnsOnCall(i int, result1 int, result2 error) {
	fake.getPortSpeedPriceIdMutex.Lock()
	defer fake.getPortSpeedPriceIdMutex.Unlock()
	fake.GetPortSpeedPriceIdStub = nil
	if fake.getPortSpeedPriceIdReturnsOnCall == nil {
		fake.getPortSpeedPriceIdReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.getPortSpeedPriceIdReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetSensorData(arg1 int, arg2 string) ([]datatypes.Container_RemoteManagement_SensorReading, error) {
	fake.getSensorDataMutex.Lock()
	ret, specificReturn := fake.getSensorDataReturnsOnCall[len(fake.getSensorDataArgsForCall)]
	fake.getSensorDataArgsForCall = append(fake.getSensorDataArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.GetSensorDataStub
	fakeReturns := fake.getSensorDataReturns
	fake.recordInvocation("GetSensorData", []interface{}{arg1, arg2})
	fake.getSensorDataMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHardwareServerManager) GetSensorDataCallCount() int {
	fake.getSensorDataMutex.RLock()
	defer fake.getSensorDataMutex.RUnlock()
	return len(fake.getSensorDataArgsForCall)
}

func (fake *FakeHardwareServerManager) GetSensorDataCalls(stub func(int, string) ([]datatypes.Container_RemoteManagement_SensorReading, error)) {
	fake.getSensorDataMutex.Lock()
	defer fake.getSensorDataMutex.Unlock()
	fake.GetSensorDataStub = stub
}

func (fake *FakeHardwareServerManager) GetSensorDataArgsForCall(i int) (int, string) {
	fake.getSensorDataMutex.RLock()
	defer fake.getSensorDataMutex.RUnlock()
	argsForCall := fake.getSensorDataArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeHardwareServerManager) GetSensorDataReturns(result1 []datatypes.Container_RemoteManagement_SensorReading, result2 error) {
	fake.getSensorDataMutex.Lock()
	defer fake.getSensorDataMutex.Unlock()
	fake.GetSensorDataStub = nil
	fake.getSensorDataReturns = struct {
		result1 []datatypes.Container_RemoteManagement_SensorReading
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetSensorDataReturnsOnCall(i int, result1 []datatypes.Container_RemoteManagement_SensorReading, result2 error) {
	fake.getSensorDataMutex.Lock()
	defer fake.getSensorDataMutex.Unlock()
	fake.GetSensorDataStub = nil
	if fake.getSensorDataReturnsOnCall == nil {
		fake.getSensorDataReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Container_RemoteManagement_SensorReading
			result2 error
		})
	}
	fake.getSensorDataReturnsOnCall[i] = struct {
		result1 []datatypes.Container_RemoteManagement_SensorReading
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetStorageCredentials(arg1 int) (datatypes.Network_Storage_Allowed_Host, error) {
	fake.getStorageCredentialsMutex.Lock()
	ret, specificReturn := fake.getStorageCredentialsReturnsOnCall[len(fake.getStorageCredentialsArgsForCall)]
	fake.getStorageCredentialsArgsForCall = append(fake.getStorageCredentialsArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.GetStorageCredentialsStub
	fakeReturns := fake.getStorageCredentialsReturns
	fake.recordInvocation("GetStorageCredentials", []interface{}{arg1})
	fake.getStorageCredentialsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHardwareServerManager) GetStorageCredentialsCallCount() int {
	fake.getStorageCredentialsMutex.RLock()
	defer fake.getStorageCredentialsMutex.RUnlock()
	return len(fake.getStorageCredentialsArgsForCall)
}

func (fake *FakeHardwareServerManager) GetStorageCredentialsCalls(stub func(int) (datatypes.Network_Storage_Allowed_Host, error)) {
	fake.getStorageCredentialsMutex.Lock()
	defer fake.getStorageCredentialsMutex.Unlock()
	fake.GetStorageCredentialsStub = stub
}

func (fake *FakeHardwareServerManager) GetStorageCredentialsArgsForCall(i int) int {
	fake.getStorageCredentialsMutex.RLock()
	defer fake.getStorageCredentialsMutex.RUnlock()
	argsForCall := fake.getStorageCredentialsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeHardwareServerManager) GetStorageCredentialsReturns(result1 datatypes.Network_Storage_Allowed_Host, result2 error) {
	fake.getStorageCredentialsMutex.Lock()
	defer fake.getStorageCredentialsMutex.Unlock()
	fake.GetStorageCredentialsStub = nil
	fake.getStorageCredentialsReturns = struct {
		result1 datatypes.Network_Storage_Allowed_Host
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetStorageCredentialsReturnsOnCall(i int, result1 datatypes.Network_Storage_Allowed_Host, result2 error) {
	fake.getStorageCredentialsMutex.Lock()
	defer fake.getStorageCredentialsMutex.Unlock()
	fake.GetStorageCredentialsStub = nil
	if fake.getStorageCredentialsReturnsOnCall == nil {
		fake.getStorageCredentialsReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_Storage_Allowed_Host
			result2 error
		})
	}
	fake.getStorageCredentialsReturnsOnCall[i] = struct {
		result1 datatypes.Network_Storage_Allowed_Host
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetStorageDetails(arg1 int, arg2 string) ([]datatypes.Network_Storage, error) {
	fake.getStorageDetailsMutex.Lock()
	ret, specificReturn := fake.getStorageDetailsReturnsOnCall[len(fake.getStorageDetailsArgsForCall)]
	fake.getStorageDetailsArgsForCall = append(fake.getStorageDetailsArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.GetStorageDetailsStub
	fakeReturns := fake.getStorageDetailsReturns
	fake.recordInvocation("GetStorageDetails", []interface{}{arg1, arg2})
	fake.getStorageDetailsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHardwareServerManager) GetStorageDetailsCallCount() int {
	fake.getStorageDetailsMutex.RLock()
	defer fake.getStorageDetailsMutex.RUnlock()
	return len(fake.getStorageDetailsArgsForCall)
}

func (fake *FakeHardwareServerManager) GetStorageDetailsCalls(stub func(int, string) ([]datatypes.Network_Storage, error)) {
	fake.getStorageDetailsMutex.Lock()
	defer fake.getStorageDetailsMutex.Unlock()
	fake.GetStorageDetailsStub = stub
}

func (fake *FakeHardwareServerManager) GetStorageDetailsArgsForCall(i int) (int, string) {
	fake.getStorageDetailsMutex.RLock()
	defer fake.getStorageDetailsMutex.RUnlock()
	argsForCall := fake.getStorageDetailsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeHardwareServerManager) GetStorageDetailsReturns(result1 []datatypes.Network_Storage, result2 error) {
	fake.getStorageDetailsMutex.Lock()
	defer fake.getStorageDetailsMutex.Unlock()
	fake.GetStorageDetailsStub = nil
	fake.getStorageDetailsReturns = struct {
		result1 []datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetStorageDetailsReturnsOnCall(i int, result1 []datatypes.Network_Storage, result2 error) {
	fake.getStorageDetailsMutex.Lock()
	defer fake.getStorageDetailsMutex.Unlock()
	fake.GetStorageDetailsStub = nil
	if fake.getStorageDetailsReturnsOnCall == nil {
		fake.getStorageDetailsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Network_Storage
			result2 error
		})
	}
	fake.getStorageDetailsReturnsOnCall[i] = struct {
		result1 []datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetUserCustomerNotificationsByHardwareId(arg1 int, arg2 string) ([]datatypes.User_Customer_Notification_Hardware, error) {
	fake.getUserCustomerNotificationsByHardwareIdMutex.Lock()
	ret, specificReturn := fake.getUserCustomerNotificationsByHardwareIdReturnsOnCall[len(fake.getUserCustomerNotificationsByHardwareIdArgsForCall)]
	fake.getUserCustomerNotificationsByHardwareIdArgsForCall = append(fake.getUserCustomerNotificationsByHardwareIdArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.GetUserCustomerNotificationsByHardwareIdStub
	fakeReturns := fake.getUserCustomerNotificationsByHardwareIdReturns
	fake.recordInvocation("GetUserCustomerNotificationsByHardwareId", []interface{}{arg1, arg2})
	fake.getUserCustomerNotificationsByHardwareIdMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHardwareServerManager) GetUserCustomerNotificationsByHardwareIdCallCount() int {
	fake.getUserCustomerNotificationsByHardwareIdMutex.RLock()
	defer fake.getUserCustomerNotificationsByHardwareIdMutex.RUnlock()
	return len(fake.getUserCustomerNotificationsByHardwareIdArgsForCall)
}

func (fake *FakeHardwareServerManager) GetUserCustomerNotificationsByHardwareIdCalls(stub func(int, string) ([]datatypes.User_Customer_Notification_Hardware, error)) {
	fake.getUserCustomerNotificationsByHardwareIdMutex.Lock()
	defer fake.getUserCustomerNotificationsByHardwareIdMutex.Unlock()
	fake.GetUserCustomerNotificationsByHardwareIdStub = stub
}

func (fake *FakeHardwareServerManager) GetUserCustomerNotificationsByHardwareIdArgsForCall(i int) (int, string) {
	fake.getUserCustomerNotificationsByHardwareIdMutex.RLock()
	defer fake.getUserCustomerNotificationsByHardwareIdMutex.RUnlock()
	argsForCall := fake.getUserCustomerNotificationsByHardwareIdArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeHardwareServerManager) GetUserCustomerNotificationsByHardwareIdReturns(result1 []datatypes.User_Customer_Notification_Hardware, result2 error) {
	fake.getUserCustomerNotificationsByHardwareIdMutex.Lock()
	defer fake.getUserCustomerNotificationsByHardwareIdMutex.Unlock()
	fake.GetUserCustomerNotificationsByHardwareIdStub = nil
	fake.getUserCustomerNotificationsByHardwareIdReturns = struct {
		result1 []datatypes.User_Customer_Notification_Hardware
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) GetUserCustomerNotificationsByHardwareIdReturnsOnCall(i int, result1 []datatypes.User_Customer_Notification_Hardware, result2 error) {
	fake.getUserCustomerNotificationsByHardwareIdMutex.Lock()
	defer fake.getUserCustomerNotificationsByHardwareIdMutex.Unlock()
	fake.GetUserCustomerNotificationsByHardwareIdStub = nil
	if fake.getUserCustomerNotificationsByHardwareIdReturnsOnCall == nil {
		fake.getUserCustomerNotificationsByHardwareIdReturnsOnCall = make(map[int]struct {
			result1 []datatypes.User_Customer_Notification_Hardware
			result2 error
		})
	}
	fake.getUserCustomerNotificationsByHardwareIdReturnsOnCall[i] = struct {
		result1 []datatypes.User_Customer_Notification_Hardware
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) ListHardware(arg1 []string, arg2 int, arg3 int, arg4 string, arg5 string, arg6 string, arg7 int, arg8 string, arg9 string, arg10 string, arg11 int, arg12 string) ([]datatypes.Hardware_Server, error) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.listHardwareMutex.Lock()
	ret, specificReturn := fake.listHardwareReturnsOnCall[len(fake.listHardwareArgsForCall)]
	fake.listHardwareArgsForCall = append(fake.listHardwareArgsForCall, struct {
		arg1  []string
		arg2  int
		arg3  int
		arg4  string
		arg5  string
		arg6  string
		arg7  int
		arg8  string
		arg9  string
		arg10 string
		arg11 int
		arg12 string
	}{arg1Copy, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12})
	stub := fake.ListHardwareStub
	fakeReturns := fake.listHardwareReturns
	fake.recordInvocation("ListHardware", []interface{}{arg1Copy, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12})
	fake.listHardwareMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHardwareServerManager) ListHardwareCallCount() int {
	fake.listHardwareMutex.RLock()
	defer fake.listHardwareMutex.RUnlock()
	return len(fake.listHardwareArgsForCall)
}

func (fake *FakeHardwareServerManager) ListHardwareCalls(stub func([]string, int, int, string, string, string, int, string, string, string, int, string) ([]datatypes.Hardware_Server, error)) {
	fake.listHardwareMutex.Lock()
	defer fake.listHardwareMutex.Unlock()
	fake.ListHardwareStub = stub
}

func (fake *FakeHardwareServerManager) ListHardwareArgsForCall(i int) ([]string, int, int, string, string, string, int, string, string, string, int, string) {
	fake.listHardwareMutex.RLock()
	defer fake.listHardwareMutex.RUnlock()
	argsForCall := fake.listHardwareArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7, argsForCall.arg8, argsForCall.arg9, argsForCall.arg10, argsForCall.arg11, argsForCall.arg12
}

func (fake *FakeHardwareServerManager) ListHardwareReturns(result1 []datatypes.Hardware_Server, result2 error) {
	fake.listHardwareMutex.Lock()
	defer fake.listHardwareMutex.Unlock()
	fake.ListHardwareStub = nil
	fake.listHardwareReturns = struct {
		result1 []datatypes.Hardware_Server
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) ListHardwareReturnsOnCall(i int, result1 []datatypes.Hardware_Server, result2 error) {
	fake.listHardwareMutex.Lock()
	defer fake.listHardwareMutex.Unlock()
	fake.ListHardwareStub = nil
	if fake.listHardwareReturnsOnCall == nil {
		fake.listHardwareReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Hardware_Server
			result2 error
		})
	}
	fake.listHardwareReturnsOnCall[i] = struct {
		result1 []datatypes.Hardware_Server
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) PlaceOrder(arg1 datatypes.Container_Product_Order) (datatypes.Container_Product_Order_Receipt, error) {
	fake.placeOrderMutex.Lock()
	ret, specificReturn := fake.placeOrderReturnsOnCall[len(fake.placeOrderArgsForCall)]
	fake.placeOrderArgsForCall = append(fake.placeOrderArgsForCall, struct {
		arg1 datatypes.Container_Product_Order
	}{arg1})
	stub := fake.PlaceOrderStub
	fakeReturns := fake.placeOrderReturns
	fake.recordInvocation("PlaceOrder", []interface{}{arg1})
	fake.placeOrderMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHardwareServerManager) PlaceOrderCallCount() int {
	fake.placeOrderMutex.RLock()
	defer fake.placeOrderMutex.RUnlock()
	return len(fake.placeOrderArgsForCall)
}

func (fake *FakeHardwareServerManager) PlaceOrderCalls(stub func(datatypes.Container_Product_Order) (datatypes.Container_Product_Order_Receipt, error)) {
	fake.placeOrderMutex.Lock()
	defer fake.placeOrderMutex.Unlock()
	fake.PlaceOrderStub = stub
}

func (fake *FakeHardwareServerManager) PlaceOrderArgsForCall(i int) datatypes.Container_Product_Order {
	fake.placeOrderMutex.RLock()
	defer fake.placeOrderMutex.RUnlock()
	argsForCall := fake.placeOrderArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeHardwareServerManager) PlaceOrderReturns(result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.placeOrderMutex.Lock()
	defer fake.placeOrderMutex.Unlock()
	fake.PlaceOrderStub = nil
	fake.placeOrderReturns = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) PlaceOrderReturnsOnCall(i int, result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.placeOrderMutex.Lock()
	defer fake.placeOrderMutex.Unlock()
	fake.PlaceOrderStub = nil
	if fake.placeOrderReturnsOnCall == nil {
		fake.placeOrderReturnsOnCall = make(map[int]struct {
			result1 datatypes.Container_Product_Order_Receipt
			result2 error
		})
	}
	fake.placeOrderReturnsOnCall[i] = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) PowerCycle(arg1 int) error {
	fake.powerCycleMutex.Lock()
	ret, specificReturn := fake.powerCycleReturnsOnCall[len(fake.powerCycleArgsForCall)]
	fake.powerCycleArgsForCall = append(fake.powerCycleArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.PowerCycleStub
	fakeReturns := fake.powerCycleReturns
	fake.recordInvocation("PowerCycle", []interface{}{arg1})
	fake.powerCycleMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeHardwareServerManager) PowerCycleCallCount() int {
	fake.powerCycleMutex.RLock()
	defer fake.powerCycleMutex.RUnlock()
	return len(fake.powerCycleArgsForCall)
}

func (fake *FakeHardwareServerManager) PowerCycleCalls(stub func(int) error) {
	fake.powerCycleMutex.Lock()
	defer fake.powerCycleMutex.Unlock()
	fake.PowerCycleStub = stub
}

func (fake *FakeHardwareServerManager) PowerCycleArgsForCall(i int) int {
	fake.powerCycleMutex.RLock()
	defer fake.powerCycleMutex.RUnlock()
	argsForCall := fake.powerCycleArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeHardwareServerManager) PowerCycleReturns(result1 error) {
	fake.powerCycleMutex.Lock()
	defer fake.powerCycleMutex.Unlock()
	fake.PowerCycleStub = nil
	fake.powerCycleReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeHardwareServerManager) PowerCycleReturnsOnCall(i int, result1 error) {
	fake.powerCycleMutex.Lock()
	defer fake.powerCycleMutex.Unlock()
	fake.PowerCycleStub = nil
	if fake.powerCycleReturnsOnCall == nil {
		fake.powerCycleReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.powerCycleReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeHardwareServerManager) PowerOff(arg1 int) error {
	fake.powerOffMutex.Lock()
	ret, specificReturn := fake.powerOffReturnsOnCall[len(fake.powerOffArgsForCall)]
	fake.powerOffArgsForCall = append(fake.powerOffArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.PowerOffStub
	fakeReturns := fake.powerOffReturns
	fake.recordInvocation("PowerOff", []interface{}{arg1})
	fake.powerOffMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeHardwareServerManager) PowerOffCallCount() int {
	fake.powerOffMutex.RLock()
	defer fake.powerOffMutex.RUnlock()
	return len(fake.powerOffArgsForCall)
}

func (fake *FakeHardwareServerManager) PowerOffCalls(stub func(int) error) {
	fake.powerOffMutex.Lock()
	defer fake.powerOffMutex.Unlock()
	fake.PowerOffStub = stub
}

func (fake *FakeHardwareServerManager) PowerOffArgsForCall(i int) int {
	fake.powerOffMutex.RLock()
	defer fake.powerOffMutex.RUnlock()
	argsForCall := fake.powerOffArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeHardwareServerManager) PowerOffReturns(result1 error) {
	fake.powerOffMutex.Lock()
	defer fake.powerOffMutex.Unlock()
	fake.PowerOffStub = nil
	fake.powerOffReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeHardwareServerManager) PowerOffReturnsOnCall(i int, result1 error) {
	fake.powerOffMutex.Lock()
	defer fake.powerOffMutex.Unlock()
	fake.PowerOffStub = nil
	if fake.powerOffReturnsOnCall == nil {
		fake.powerOffReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.powerOffReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeHardwareServerManager) PowerOn(arg1 int) error {
	fake.powerOnMutex.Lock()
	ret, specificReturn := fake.powerOnReturnsOnCall[len(fake.powerOnArgsForCall)]
	fake.powerOnArgsForCall = append(fake.powerOnArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.PowerOnStub
	fakeReturns := fake.powerOnReturns
	fake.recordInvocation("PowerOn", []interface{}{arg1})
	fake.powerOnMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeHardwareServerManager) PowerOnCallCount() int {
	fake.powerOnMutex.RLock()
	defer fake.powerOnMutex.RUnlock()
	return len(fake.powerOnArgsForCall)
}

func (fake *FakeHardwareServerManager) PowerOnCalls(stub func(int) error) {
	fake.powerOnMutex.Lock()
	defer fake.powerOnMutex.Unlock()
	fake.PowerOnStub = stub
}

func (fake *FakeHardwareServerManager) PowerOnArgsForCall(i int) int {
	fake.powerOnMutex.RLock()
	defer fake.powerOnMutex.RUnlock()
	argsForCall := fake.powerOnArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeHardwareServerManager) PowerOnReturns(result1 error) {
	fake.powerOnMutex.Lock()
	defer fake.powerOnMutex.Unlock()
	fake.PowerOnStub = nil
	fake.powerOnReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeHardwareServerManager) PowerOnReturnsOnCall(i int, result1 error) {
	fake.powerOnMutex.Lock()
	defer fake.powerOnMutex.Unlock()
	fake.PowerOnStub = nil
	if fake.powerOnReturnsOnCall == nil {
		fake.powerOnReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.powerOnReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeHardwareServerManager) Reboot(arg1 int, arg2 bool, arg3 bool) error {
	fake.rebootMutex.Lock()
	ret, specificReturn := fake.rebootReturnsOnCall[len(fake.rebootArgsForCall)]
	fake.rebootArgsForCall = append(fake.rebootArgsForCall, struct {
		arg1 int
		arg2 bool
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.RebootStub
	fakeReturns := fake.rebootReturns
	fake.recordInvocation("Reboot", []interface{}{arg1, arg2, arg3})
	fake.rebootMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeHardwareServerManager) RebootCallCount() int {
	fake.rebootMutex.RLock()
	defer fake.rebootMutex.RUnlock()
	return len(fake.rebootArgsForCall)
}

func (fake *FakeHardwareServerManager) RebootCalls(stub func(int, bool, bool) error) {
	fake.rebootMutex.Lock()
	defer fake.rebootMutex.Unlock()
	fake.RebootStub = stub
}

func (fake *FakeHardwareServerManager) RebootArgsForCall(i int) (int, bool, bool) {
	fake.rebootMutex.RLock()
	defer fake.rebootMutex.RUnlock()
	argsForCall := fake.rebootArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeHardwareServerManager) RebootReturns(result1 error) {
	fake.rebootMutex.Lock()
	defer fake.rebootMutex.Unlock()
	fake.RebootStub = nil
	fake.rebootReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeHardwareServerManager) RebootReturnsOnCall(i int, result1 error) {
	fake.rebootMutex.Lock()
	defer fake.rebootMutex.Unlock()
	fake.RebootStub = nil
	if fake.rebootReturnsOnCall == nil {
		fake.rebootReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.rebootReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeHardwareServerManager) Reload(arg1 int, arg2 string, arg3 []int, arg4 bool, arg5 bool) error {
	var arg3Copy []int
	if arg3 != nil {
		arg3Copy = make([]int, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.reloadMutex.Lock()
	ret, specificReturn := fake.reloadReturnsOnCall[len(fake.reloadArgsForCall)]
	fake.reloadArgsForCall = append(fake.reloadArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 []int
		arg4 bool
		arg5 bool
	}{arg1, arg2, arg3Copy, arg4, arg5})
	stub := fake.ReloadStub
	fakeReturns := fake.reloadReturns
	fake.recordInvocation("Reload", []interface{}{arg1, arg2, arg3Copy, arg4, arg5})
	fake.reloadMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeHardwareServerManager) ReloadCallCount() int {
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	return len(fake.reloadArgsForCall)
}

func (fake *FakeHardwareServerManager) ReloadCalls(stub func(int, string, []int, bool, bool) error) {
	fake.reloadMutex.Lock()
	defer fake.reloadMutex.Unlock()
	fake.ReloadStub = stub
}

func (fake *FakeHardwareServerManager) ReloadArgsForCall(i int) (int, string, []int, bool, bool) {
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	argsForCall := fake.reloadArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeHardwareServerManager) ReloadReturns(result1 error) {
	fake.reloadMutex.Lock()
	defer fake.reloadMutex.Unlock()
	fake.ReloadStub = nil
	fake.reloadReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeHardwareServerManager) ReloadReturnsOnCall(i int, result1 error) {
	fake.reloadMutex.Lock()
	defer fake.reloadMutex.Unlock()
	fake.ReloadStub = nil
	if fake.reloadReturnsOnCall == nil {
		fake.reloadReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.reloadReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeHardwareServerManager) Rescure(arg1 int) error {
	fake.rescureMutex.Lock()
	ret, specificReturn := fake.rescureReturnsOnCall[len(fake.rescureArgsForCall)]
	fake.rescureArgsForCall = append(fake.rescureArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.RescureStub
	fakeReturns := fake.rescureReturns
	fake.recordInvocation("Rescure", []interface{}{arg1})
	fake.rescureMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeHardwareServerManager) RescureCallCount() int {
	fake.rescureMutex.RLock()
	defer fake.rescureMutex.RUnlock()
	return len(fake.rescureArgsForCall)
}

func (fake *FakeHardwareServerManager) RescureCalls(stub func(int) error) {
	fake.rescureMutex.Lock()
	defer fake.rescureMutex.Unlock()
	fake.RescureStub = stub
}

func (fake *FakeHardwareServerManager) RescureArgsForCall(i int) int {
	fake.rescureMutex.RLock()
	defer fake.rescureMutex.RUnlock()
	argsForCall := fake.rescureArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeHardwareServerManager) RescureReturns(result1 error) {
	fake.rescureMutex.Lock()
	defer fake.rescureMutex.Unlock()
	fake.RescureStub = nil
	fake.rescureReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeHardwareServerManager) RescureReturnsOnCall(i int, result1 error) {
	fake.rescureMutex.Lock()
	defer fake.rescureMutex.Unlock()
	fake.RescureStub = nil
	if fake.rescureReturnsOnCall == nil {
		fake.rescureReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.rescureReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeHardwareServerManager) ToggleIPMI(arg1 int, arg2 bool) error {
	fake.toggleIPMIMutex.Lock()
	ret, specificReturn := fake.toggleIPMIReturnsOnCall[len(fake.toggleIPMIArgsForCall)]
	fake.toggleIPMIArgsForCall = append(fake.toggleIPMIArgsForCall, struct {
		arg1 int
		arg2 bool
	}{arg1, arg2})
	stub := fake.ToggleIPMIStub
	fakeReturns := fake.toggleIPMIReturns
	fake.recordInvocation("ToggleIPMI", []interface{}{arg1, arg2})
	fake.toggleIPMIMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeHardwareServerManager) ToggleIPMICallCount() int {
	fake.toggleIPMIMutex.RLock()
	defer fake.toggleIPMIMutex.RUnlock()
	return len(fake.toggleIPMIArgsForCall)
}

func (fake *FakeHardwareServerManager) ToggleIPMICalls(stub func(int, bool) error) {
	fake.toggleIPMIMutex.Lock()
	defer fake.toggleIPMIMutex.Unlock()
	fake.ToggleIPMIStub = stub
}

func (fake *FakeHardwareServerManager) ToggleIPMIArgsForCall(i int) (int, bool) {
	fake.toggleIPMIMutex.RLock()
	defer fake.toggleIPMIMutex.RUnlock()
	argsForCall := fake.toggleIPMIArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeHardwareServerManager) ToggleIPMIReturns(result1 error) {
	fake.toggleIPMIMutex.Lock()
	defer fake.toggleIPMIMutex.Unlock()
	fake.ToggleIPMIStub = nil
	fake.toggleIPMIReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeHardwareServerManager) ToggleIPMIReturnsOnCall(i int, result1 error) {
	fake.toggleIPMIMutex.Lock()
	defer fake.toggleIPMIMutex.Unlock()
	fake.ToggleIPMIStub = nil
	if fake.toggleIPMIReturnsOnCall == nil {
		fake.toggleIPMIReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.toggleIPMIReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeHardwareServerManager) UpdateFirmware(arg1 int, arg2 bool, arg3 bool, arg4 bool, arg5 bool) error {
	fake.updateFirmwareMutex.Lock()
	ret, specificReturn := fake.updateFirmwareReturnsOnCall[len(fake.updateFirmwareArgsForCall)]
	fake.updateFirmwareArgsForCall = append(fake.updateFirmwareArgsForCall, struct {
		arg1 int
		arg2 bool
		arg3 bool
		arg4 bool
		arg5 bool
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.UpdateFirmwareStub
	fakeReturns := fake.updateFirmwareReturns
	fake.recordInvocation("UpdateFirmware", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.updateFirmwareMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeHardwareServerManager) UpdateFirmwareCallCount() int {
	fake.updateFirmwareMutex.RLock()
	defer fake.updateFirmwareMutex.RUnlock()
	return len(fake.updateFirmwareArgsForCall)
}

func (fake *FakeHardwareServerManager) UpdateFirmwareCalls(stub func(int, bool, bool, bool, bool) error) {
	fake.updateFirmwareMutex.Lock()
	defer fake.updateFirmwareMutex.Unlock()
	fake.UpdateFirmwareStub = stub
}

func (fake *FakeHardwareServerManager) UpdateFirmwareArgsForCall(i int) (int, bool, bool, bool, bool) {
	fake.updateFirmwareMutex.RLock()
	defer fake.updateFirmwareMutex.RUnlock()
	argsForCall := fake.updateFirmwareArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeHardwareServerManager) UpdateFirmwareReturns(result1 error) {
	fake.updateFirmwareMutex.Lock()
	defer fake.updateFirmwareMutex.Unlock()
	fake.UpdateFirmwareStub = nil
	fake.updateFirmwareReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeHardwareServerManager) UpdateFirmwareReturnsOnCall(i int, result1 error) {
	fake.updateFirmwareMutex.Lock()
	defer fake.updateFirmwareMutex.Unlock()
	fake.UpdateFirmwareStub = nil
	if fake.updateFirmwareReturnsOnCall == nil {
		fake.updateFirmwareReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateFirmwareReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeHardwareServerManager) VerifyOrder(arg1 datatypes.Container_Product_Order) (datatypes.Container_Product_Order, error) {
	fake.verifyOrderMutex.Lock()
	ret, specificReturn := fake.verifyOrderReturnsOnCall[len(fake.verifyOrderArgsForCall)]
	fake.verifyOrderArgsForCall = append(fake.verifyOrderArgsForCall, struct {
		arg1 datatypes.Container_Product_Order
	}{arg1})
	stub := fake.VerifyOrderStub
	fakeReturns := fake.verifyOrderReturns
	fake.recordInvocation("VerifyOrder", []interface{}{arg1})
	fake.verifyOrderMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeHardwareServerManager) VerifyOrderCallCount() int {
	fake.verifyOrderMutex.RLock()
	defer fake.verifyOrderMutex.RUnlock()
	return len(fake.verifyOrderArgsForCall)
}

func (fake *FakeHardwareServerManager) VerifyOrderCalls(stub func(datatypes.Container_Product_Order) (datatypes.Container_Product_Order, error)) {
	fake.verifyOrderMutex.Lock()
	defer fake.verifyOrderMutex.Unlock()
	fake.VerifyOrderStub = stub
}

func (fake *FakeHardwareServerManager) VerifyOrderArgsForCall(i int) datatypes.Container_Product_Order {
	fake.verifyOrderMutex.RLock()
	defer fake.verifyOrderMutex.RUnlock()
	argsForCall := fake.verifyOrderArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeHardwareServerManager) VerifyOrderReturns(result1 datatypes.Container_Product_Order, result2 error) {
	fake.verifyOrderMutex.Lock()
	defer fake.verifyOrderMutex.Unlock()
	fake.VerifyOrderStub = nil
	fake.verifyOrderReturns = struct {
		result1 datatypes.Container_Product_Order
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) VerifyOrderReturnsOnCall(i int, result1 datatypes.Container_Product_Order, result2 error) {
	fake.verifyOrderMutex.Lock()
	defer fake.verifyOrderMutex.Unlock()
	fake.VerifyOrderStub = nil
	if fake.verifyOrderReturnsOnCall == nil {
		fake.verifyOrderReturnsOnCall = make(map[int]struct {
			result1 datatypes.Container_Product_Order
			result2 error
		})
	}
	fake.verifyOrderReturnsOnCall[i] = struct {
		result1 datatypes.Container_Product_Order
		result2 error
	}{result1, result2}
}

func (fake *FakeHardwareServerManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.authorizeStorageMutex.RLock()
	defer fake.authorizeStorageMutex.RUnlock()
	fake.cancelHardwareMutex.RLock()
	defer fake.cancelHardwareMutex.RUnlock()
	fake.createFirmwareReflashTransactionMutex.RLock()
	defer fake.createFirmwareReflashTransactionMutex.RUnlock()
	fake.createUserCustomerNotificationMutex.RLock()
	defer fake.createUserCustomerNotificationMutex.RUnlock()
	fake.deleteUserCustomerNotificationMutex.RLock()
	defer fake.deleteUserCustomerNotificationMutex.RUnlock()
	fake.editMutex.RLock()
	defer fake.editMutex.RUnlock()
	fake.generateCreateTemplateMutex.RLock()
	defer fake.generateCreateTemplateMutex.RUnlock()
	fake.getBandwidthAllotmentDetailMutex.RLock()
	defer fake.getBandwidthAllotmentDetailMutex.RUnlock()
	fake.getBandwidthDataMutex.RLock()
	defer fake.getBandwidthDataMutex.RUnlock()
	fake.getBandwidthPriceIdMutex.RLock()
	defer fake.getBandwidthPriceIdMutex.RUnlock()
	fake.getBillingCycleBandwidthUsageMutex.RLock()
	defer fake.getBillingCycleBandwidthUsageMutex.RUnlock()
	fake.getCancellationReasonsMutex.RLock()
	defer fake.getCancellationReasonsMutex.RUnlock()
	fake.getCreateOptionsMutex.RLock()
	defer fake.getCreateOptionsMutex.RUnlock()
	fake.getDefaultPriceIdMutex.RLock()
	defer fake.getDefaultPriceIdMutex.RUnlock()
	fake.getExtraPriceIdMutex.RLock()
	defer fake.getExtraPriceIdMutex.RUnlock()
	fake.getHardDrivesMutex.RLock()
	defer fake.getHardDrivesMutex.RUnlock()
	fake.getHardwareMutex.RLock()
	defer fake.getHardwareMutex.RUnlock()
	fake.getHardwareComponentsMutex.RLock()
	defer fake.getHardwareComponentsMutex.RUnlock()
	fake.getOSPriceIdMutex.RLock()
	defer fake.getOSPriceIdMutex.RUnlock()
	fake.getPackageMutex.RLock()
	defer fake.getPackageMutex.RUnlock()
	fake.getPortSpeedPriceIdMutex.RLock()
	defer fake.getPortSpeedPriceIdMutex.RUnlock()
	fake.getSensorDataMutex.RLock()
	defer fake.getSensorDataMutex.RUnlock()
	fake.getStorageCredentialsMutex.RLock()
	defer fake.getStorageCredentialsMutex.RUnlock()
	fake.getStorageDetailsMutex.RLock()
	defer fake.getStorageDetailsMutex.RUnlock()
	fake.getUserCustomerNotificationsByHardwareIdMutex.RLock()
	defer fake.getUserCustomerNotificationsByHardwareIdMutex.RUnlock()
	fake.listHardwareMutex.RLock()
	defer fake.listHardwareMutex.RUnlock()
	fake.placeOrderMutex.RLock()
	defer fake.placeOrderMutex.RUnlock()
	fake.powerCycleMutex.RLock()
	defer fake.powerCycleMutex.RUnlock()
	fake.powerOffMutex.RLock()
	defer fake.powerOffMutex.RUnlock()
	fake.powerOnMutex.RLock()
	defer fake.powerOnMutex.RUnlock()
	fake.rebootMutex.RLock()
	defer fake.rebootMutex.RUnlock()
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	fake.rescureMutex.RLock()
	defer fake.rescureMutex.RUnlock()
	fake.toggleIPMIMutex.RLock()
	defer fake.toggleIPMIMutex.RUnlock()
	fake.updateFirmwareMutex.RLock()
	defer fake.updateFirmwareMutex.RUnlock()
	fake.verifyOrderMutex.RLock()
	defer fake.verifyOrderMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeHardwareServerManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ managers.HardwareServerManager = new(FakeHardwareServerManager)
