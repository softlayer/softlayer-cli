// Code generated by counterfeiter. DO NOT EDIT.
package testhelpers

import (
	"sync"
	"time"

	"github.com/softlayer/softlayer-go/datatypes"
	"github.ibm.com/SoftLayer/softlayer-cli/plugin/managers"
)

type FakeUserManager struct {
	AddApiAuthenticationKeyStub        func(int) (string, error)
	addApiAuthenticationKeyMutex       sync.RWMutex
	addApiAuthenticationKeyArgsForCall []struct {
		arg1 int
	}
	addApiAuthenticationKeyReturns struct {
		result1 string
		result2 error
	}
	addApiAuthenticationKeyReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	AddDedicatedHostAccessStub        func(int, int) (bool, error)
	addDedicatedHostAccessMutex       sync.RWMutex
	addDedicatedHostAccessArgsForCall []struct {
		arg1 int
		arg2 int
	}
	addDedicatedHostAccessReturns struct {
		result1 bool
		result2 error
	}
	addDedicatedHostAccessReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	AddHardwareAccessStub        func(int, int) (bool, error)
	addHardwareAccessMutex       sync.RWMutex
	addHardwareAccessArgsForCall []struct {
		arg1 int
		arg2 int
	}
	addHardwareAccessReturns struct {
		result1 bool
		result2 error
	}
	addHardwareAccessReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	AddPermissionStub        func(int, []datatypes.User_Customer_CustomerPermission_Permission) (bool, error)
	addPermissionMutex       sync.RWMutex
	addPermissionArgsForCall []struct {
		arg1 int
		arg2 []datatypes.User_Customer_CustomerPermission_Permission
	}
	addPermissionReturns struct {
		result1 bool
		result2 error
	}
	addPermissionReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	AddVirtualGuestAccessStub        func(int, int) (bool, error)
	addVirtualGuestAccessMutex       sync.RWMutex
	addVirtualGuestAccessArgsForCall []struct {
		arg1 int
		arg2 int
	}
	addVirtualGuestAccessReturns struct {
		result1 bool
		result2 error
	}
	addVirtualGuestAccessReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CreateUserStub        func(datatypes.User_Customer, string, string) (datatypes.User_Customer, error)
	createUserMutex       sync.RWMutex
	createUserArgsForCall []struct {
		arg1 datatypes.User_Customer
		arg2 string
		arg3 string
	}
	createUserReturns struct {
		result1 datatypes.User_Customer
		result2 error
	}
	createUserReturnsOnCall map[int]struct {
		result1 datatypes.User_Customer
		result2 error
	}
	CreateUserVpnOverrideStub        func(int, int) (bool, error)
	createUserVpnOverrideMutex       sync.RWMutex
	createUserVpnOverrideArgsForCall []struct {
		arg1 int
		arg2 int
	}
	createUserVpnOverrideReturns struct {
		result1 bool
		result2 error
	}
	createUserVpnOverrideReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	DeleteUserVpnOverrideStub        func(int) (bool, error)
	deleteUserVpnOverrideMutex       sync.RWMutex
	deleteUserVpnOverrideArgsForCall []struct {
		arg1 int
	}
	deleteUserVpnOverrideReturns struct {
		result1 bool
		result2 error
	}
	deleteUserVpnOverrideReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	DisableEmailSubscriptionNotificationStub        func(int) (bool, error)
	disableEmailSubscriptionNotificationMutex       sync.RWMutex
	disableEmailSubscriptionNotificationArgsForCall []struct {
		arg1 int
	}
	disableEmailSubscriptionNotificationReturns struct {
		result1 bool
		result2 error
	}
	disableEmailSubscriptionNotificationReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	EditUserStub        func(datatypes.User_Customer, int) (bool, error)
	editUserMutex       sync.RWMutex
	editUserArgsForCall []struct {
		arg1 datatypes.User_Customer
		arg2 int
	}
	editUserReturns struct {
		result1 bool
		result2 error
	}
	editUserReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	EnableEmailSubscriptionNotificationStub        func(int) (bool, error)
	enableEmailSubscriptionNotificationMutex       sync.RWMutex
	enableEmailSubscriptionNotificationArgsForCall []struct {
		arg1 int
	}
	enableEmailSubscriptionNotificationReturns struct {
		result1 bool
		result2 error
	}
	enableEmailSubscriptionNotificationReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	FormatPermissionObjectStub        func([]string) ([]datatypes.User_Customer_CustomerPermission_Permission, error)
	formatPermissionObjectMutex       sync.RWMutex
	formatPermissionObjectArgsForCall []struct {
		arg1 []string
	}
	formatPermissionObjectReturns struct {
		result1 []datatypes.User_Customer_CustomerPermission_Permission
		result2 error
	}
	formatPermissionObjectReturnsOnCall map[int]struct {
		result1 []datatypes.User_Customer_CustomerPermission_Permission
		result2 error
	}
	GetAllNotificationsStub        func(string) ([]datatypes.Email_Subscription, error)
	getAllNotificationsMutex       sync.RWMutex
	getAllNotificationsArgsForCall []struct {
		arg1 string
	}
	getAllNotificationsReturns struct {
		result1 []datatypes.Email_Subscription
		result2 error
	}
	getAllNotificationsReturnsOnCall map[int]struct {
		result1 []datatypes.Email_Subscription
		result2 error
	}
	GetAllPermissionStub        func() ([]datatypes.User_Customer_CustomerPermission_Permission, error)
	getAllPermissionMutex       sync.RWMutex
	getAllPermissionArgsForCall []struct {
	}
	getAllPermissionReturns struct {
		result1 []datatypes.User_Customer_CustomerPermission_Permission
		result2 error
	}
	getAllPermissionReturnsOnCall map[int]struct {
		result1 []datatypes.User_Customer_CustomerPermission_Permission
		result2 error
	}
	GetCurrentUserStub        func() (datatypes.User_Customer, error)
	getCurrentUserMutex       sync.RWMutex
	getCurrentUserArgsForCall []struct {
	}
	getCurrentUserReturns struct {
		result1 datatypes.User_Customer
		result2 error
	}
	getCurrentUserReturnsOnCall map[int]struct {
		result1 datatypes.User_Customer
		result2 error
	}
	GetDedicatedHostsStub        func(int, string) ([]datatypes.Virtual_DedicatedHost, error)
	getDedicatedHostsMutex       sync.RWMutex
	getDedicatedHostsArgsForCall []struct {
		arg1 int
		arg2 string
	}
	getDedicatedHostsReturns struct {
		result1 []datatypes.Virtual_DedicatedHost
		result2 error
	}
	getDedicatedHostsReturnsOnCall map[int]struct {
		result1 []datatypes.Virtual_DedicatedHost
		result2 error
	}
	GetEventsStub        func(int, time.Time) ([]datatypes.Event_Log, error)
	getEventsMutex       sync.RWMutex
	getEventsArgsForCall []struct {
		arg1 int
		arg2 time.Time
	}
	getEventsReturns struct {
		result1 []datatypes.Event_Log
		result2 error
	}
	getEventsReturnsOnCall map[int]struct {
		result1 []datatypes.Event_Log
		result2 error
	}
	GetHardwareStub        func(int, string) ([]datatypes.Hardware, error)
	getHardwareMutex       sync.RWMutex
	getHardwareArgsForCall []struct {
		arg1 int
		arg2 string
	}
	getHardwareReturns struct {
		result1 []datatypes.Hardware
		result2 error
	}
	getHardwareReturnsOnCall map[int]struct {
		result1 []datatypes.Hardware
		result2 error
	}
	GetIdFromUsernameStub        func(string) (int, error)
	getIdFromUsernameMutex       sync.RWMutex
	getIdFromUsernameArgsForCall []struct {
		arg1 string
	}
	getIdFromUsernameReturns struct {
		result1 int
		result2 error
	}
	getIdFromUsernameReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	GetLoginsStub        func(int, time.Time) ([]datatypes.User_Customer_Access_Authentication, error)
	getLoginsMutex       sync.RWMutex
	getLoginsArgsForCall []struct {
		arg1 int
		arg2 time.Time
	}
	getLoginsReturns struct {
		result1 []datatypes.User_Customer_Access_Authentication
		result2 error
	}
	getLoginsReturnsOnCall map[int]struct {
		result1 []datatypes.User_Customer_Access_Authentication
		result2 error
	}
	GetOverridesStub        func(int) ([]datatypes.Network_Service_Vpn_Overrides, error)
	getOverridesMutex       sync.RWMutex
	getOverridesArgsForCall []struct {
		arg1 int
	}
	getOverridesReturns struct {
		result1 []datatypes.Network_Service_Vpn_Overrides
		result2 error
	}
	getOverridesReturnsOnCall map[int]struct {
		result1 []datatypes.Network_Service_Vpn_Overrides
		result2 error
	}
	GetUserStub        func(int, string) (datatypes.User_Customer, error)
	getUserMutex       sync.RWMutex
	getUserArgsForCall []struct {
		arg1 int
		arg2 string
	}
	getUserReturns struct {
		result1 datatypes.User_Customer
		result2 error
	}
	getUserReturnsOnCall map[int]struct {
		result1 datatypes.User_Customer
		result2 error
	}
	GetUserAllowDevicesPermissionsStub        func(int) ([]datatypes.User_Customer_CustomerPermission_Permission, error)
	getUserAllowDevicesPermissionsMutex       sync.RWMutex
	getUserAllowDevicesPermissionsArgsForCall []struct {
		arg1 int
	}
	getUserAllowDevicesPermissionsReturns struct {
		result1 []datatypes.User_Customer_CustomerPermission_Permission
		result2 error
	}
	getUserAllowDevicesPermissionsReturnsOnCall map[int]struct {
		result1 []datatypes.User_Customer_CustomerPermission_Permission
		result2 error
	}
	GetUserPermissionsStub        func(int) ([]datatypes.User_Customer_CustomerPermission_Permission, error)
	getUserPermissionsMutex       sync.RWMutex
	getUserPermissionsArgsForCall []struct {
		arg1 int
	}
	getUserPermissionsReturns struct {
		result1 []datatypes.User_Customer_CustomerPermission_Permission
		result2 error
	}
	getUserPermissionsReturnsOnCall map[int]struct {
		result1 []datatypes.User_Customer_CustomerPermission_Permission
		result2 error
	}
	GetVirtualGuestsStub        func(int, string) ([]datatypes.Virtual_Guest, error)
	getVirtualGuestsMutex       sync.RWMutex
	getVirtualGuestsArgsForCall []struct {
		arg1 int
		arg2 string
	}
	getVirtualGuestsReturns struct {
		result1 []datatypes.Virtual_Guest
		result2 error
	}
	getVirtualGuestsReturnsOnCall map[int]struct {
		result1 []datatypes.Virtual_Guest
		result2 error
	}
	ListUsersStub        func(string) ([]datatypes.User_Customer, error)
	listUsersMutex       sync.RWMutex
	listUsersArgsForCall []struct {
		arg1 string
	}
	listUsersReturns struct {
		result1 []datatypes.User_Customer
		result2 error
	}
	listUsersReturnsOnCall map[int]struct {
		result1 []datatypes.User_Customer
		result2 error
	}
	PermissionFromUserStub        func(int, int) error
	permissionFromUserMutex       sync.RWMutex
	permissionFromUserArgsForCall []struct {
		arg1 int
		arg2 int
	}
	permissionFromUserReturns struct {
		result1 error
	}
	permissionFromUserReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveDedicatedHostAccessStub        func(int, int) (bool, error)
	removeDedicatedHostAccessMutex       sync.RWMutex
	removeDedicatedHostAccessArgsForCall []struct {
		arg1 int
		arg2 int
	}
	removeDedicatedHostAccessReturns struct {
		result1 bool
		result2 error
	}
	removeDedicatedHostAccessReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	RemoveHardwareAccessStub        func(int, int) (bool, error)
	removeHardwareAccessMutex       sync.RWMutex
	removeHardwareAccessArgsForCall []struct {
		arg1 int
		arg2 int
	}
	removeHardwareAccessReturns struct {
		result1 bool
		result2 error
	}
	removeHardwareAccessReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	RemovePermissionStub        func(int, []datatypes.User_Customer_CustomerPermission_Permission) (bool, error)
	removePermissionMutex       sync.RWMutex
	removePermissionArgsForCall []struct {
		arg1 int
		arg2 []datatypes.User_Customer_CustomerPermission_Permission
	}
	removePermissionReturns struct {
		result1 bool
		result2 error
	}
	removePermissionReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	RemoveVirtualGuestAccessStub        func(int, int) (bool, error)
	removeVirtualGuestAccessMutex       sync.RWMutex
	removeVirtualGuestAccessArgsForCall []struct {
		arg1 int
		arg2 int
	}
	removeVirtualGuestAccessReturns struct {
		result1 bool
		result2 error
	}
	removeVirtualGuestAccessReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	UpdateVpnUserStub        func(int) (bool, error)
	updateVpnUserMutex       sync.RWMutex
	updateVpnUserArgsForCall []struct {
		arg1 int
	}
	updateVpnUserReturns struct {
		result1 bool
		result2 error
	}
	updateVpnUserReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeUserManager) AddApiAuthenticationKey(arg1 int) (string, error) {
	fake.addApiAuthenticationKeyMutex.Lock()
	ret, specificReturn := fake.addApiAuthenticationKeyReturnsOnCall[len(fake.addApiAuthenticationKeyArgsForCall)]
	fake.addApiAuthenticationKeyArgsForCall = append(fake.addApiAuthenticationKeyArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.AddApiAuthenticationKeyStub
	fakeReturns := fake.addApiAuthenticationKeyReturns
	fake.recordInvocation("AddApiAuthenticationKey", []interface{}{arg1})
	fake.addApiAuthenticationKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) AddApiAuthenticationKeyCallCount() int {
	fake.addApiAuthenticationKeyMutex.RLock()
	defer fake.addApiAuthenticationKeyMutex.RUnlock()
	return len(fake.addApiAuthenticationKeyArgsForCall)
}

func (fake *FakeUserManager) AddApiAuthenticationKeyCalls(stub func(int) (string, error)) {
	fake.addApiAuthenticationKeyMutex.Lock()
	defer fake.addApiAuthenticationKeyMutex.Unlock()
	fake.AddApiAuthenticationKeyStub = stub
}

func (fake *FakeUserManager) AddApiAuthenticationKeyArgsForCall(i int) int {
	fake.addApiAuthenticationKeyMutex.RLock()
	defer fake.addApiAuthenticationKeyMutex.RUnlock()
	argsForCall := fake.addApiAuthenticationKeyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserManager) AddApiAuthenticationKeyReturns(result1 string, result2 error) {
	fake.addApiAuthenticationKeyMutex.Lock()
	defer fake.addApiAuthenticationKeyMutex.Unlock()
	fake.AddApiAuthenticationKeyStub = nil
	fake.addApiAuthenticationKeyReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) AddApiAuthenticationKeyReturnsOnCall(i int, result1 string, result2 error) {
	fake.addApiAuthenticationKeyMutex.Lock()
	defer fake.addApiAuthenticationKeyMutex.Unlock()
	fake.AddApiAuthenticationKeyStub = nil
	if fake.addApiAuthenticationKeyReturnsOnCall == nil {
		fake.addApiAuthenticationKeyReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.addApiAuthenticationKeyReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) AddDedicatedHostAccess(arg1 int, arg2 int) (bool, error) {
	fake.addDedicatedHostAccessMutex.Lock()
	ret, specificReturn := fake.addDedicatedHostAccessReturnsOnCall[len(fake.addDedicatedHostAccessArgsForCall)]
	fake.addDedicatedHostAccessArgsForCall = append(fake.addDedicatedHostAccessArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.AddDedicatedHostAccessStub
	fakeReturns := fake.addDedicatedHostAccessReturns
	fake.recordInvocation("AddDedicatedHostAccess", []interface{}{arg1, arg2})
	fake.addDedicatedHostAccessMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) AddDedicatedHostAccessCallCount() int {
	fake.addDedicatedHostAccessMutex.RLock()
	defer fake.addDedicatedHostAccessMutex.RUnlock()
	return len(fake.addDedicatedHostAccessArgsForCall)
}

func (fake *FakeUserManager) AddDedicatedHostAccessCalls(stub func(int, int) (bool, error)) {
	fake.addDedicatedHostAccessMutex.Lock()
	defer fake.addDedicatedHostAccessMutex.Unlock()
	fake.AddDedicatedHostAccessStub = stub
}

func (fake *FakeUserManager) AddDedicatedHostAccessArgsForCall(i int) (int, int) {
	fake.addDedicatedHostAccessMutex.RLock()
	defer fake.addDedicatedHostAccessMutex.RUnlock()
	argsForCall := fake.addDedicatedHostAccessArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserManager) AddDedicatedHostAccessReturns(result1 bool, result2 error) {
	fake.addDedicatedHostAccessMutex.Lock()
	defer fake.addDedicatedHostAccessMutex.Unlock()
	fake.AddDedicatedHostAccessStub = nil
	fake.addDedicatedHostAccessReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) AddDedicatedHostAccessReturnsOnCall(i int, result1 bool, result2 error) {
	fake.addDedicatedHostAccessMutex.Lock()
	defer fake.addDedicatedHostAccessMutex.Unlock()
	fake.AddDedicatedHostAccessStub = nil
	if fake.addDedicatedHostAccessReturnsOnCall == nil {
		fake.addDedicatedHostAccessReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.addDedicatedHostAccessReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) AddHardwareAccess(arg1 int, arg2 int) (bool, error) {
	fake.addHardwareAccessMutex.Lock()
	ret, specificReturn := fake.addHardwareAccessReturnsOnCall[len(fake.addHardwareAccessArgsForCall)]
	fake.addHardwareAccessArgsForCall = append(fake.addHardwareAccessArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.AddHardwareAccessStub
	fakeReturns := fake.addHardwareAccessReturns
	fake.recordInvocation("AddHardwareAccess", []interface{}{arg1, arg2})
	fake.addHardwareAccessMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) AddHardwareAccessCallCount() int {
	fake.addHardwareAccessMutex.RLock()
	defer fake.addHardwareAccessMutex.RUnlock()
	return len(fake.addHardwareAccessArgsForCall)
}

func (fake *FakeUserManager) AddHardwareAccessCalls(stub func(int, int) (bool, error)) {
	fake.addHardwareAccessMutex.Lock()
	defer fake.addHardwareAccessMutex.Unlock()
	fake.AddHardwareAccessStub = stub
}

func (fake *FakeUserManager) AddHardwareAccessArgsForCall(i int) (int, int) {
	fake.addHardwareAccessMutex.RLock()
	defer fake.addHardwareAccessMutex.RUnlock()
	argsForCall := fake.addHardwareAccessArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserManager) AddHardwareAccessReturns(result1 bool, result2 error) {
	fake.addHardwareAccessMutex.Lock()
	defer fake.addHardwareAccessMutex.Unlock()
	fake.AddHardwareAccessStub = nil
	fake.addHardwareAccessReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) AddHardwareAccessReturnsOnCall(i int, result1 bool, result2 error) {
	fake.addHardwareAccessMutex.Lock()
	defer fake.addHardwareAccessMutex.Unlock()
	fake.AddHardwareAccessStub = nil
	if fake.addHardwareAccessReturnsOnCall == nil {
		fake.addHardwareAccessReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.addHardwareAccessReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) AddPermission(arg1 int, arg2 []datatypes.User_Customer_CustomerPermission_Permission) (bool, error) {
	var arg2Copy []datatypes.User_Customer_CustomerPermission_Permission
	if arg2 != nil {
		arg2Copy = make([]datatypes.User_Customer_CustomerPermission_Permission, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.addPermissionMutex.Lock()
	ret, specificReturn := fake.addPermissionReturnsOnCall[len(fake.addPermissionArgsForCall)]
	fake.addPermissionArgsForCall = append(fake.addPermissionArgsForCall, struct {
		arg1 int
		arg2 []datatypes.User_Customer_CustomerPermission_Permission
	}{arg1, arg2Copy})
	stub := fake.AddPermissionStub
	fakeReturns := fake.addPermissionReturns
	fake.recordInvocation("AddPermission", []interface{}{arg1, arg2Copy})
	fake.addPermissionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) AddPermissionCallCount() int {
	fake.addPermissionMutex.RLock()
	defer fake.addPermissionMutex.RUnlock()
	return len(fake.addPermissionArgsForCall)
}

func (fake *FakeUserManager) AddPermissionCalls(stub func(int, []datatypes.User_Customer_CustomerPermission_Permission) (bool, error)) {
	fake.addPermissionMutex.Lock()
	defer fake.addPermissionMutex.Unlock()
	fake.AddPermissionStub = stub
}

func (fake *FakeUserManager) AddPermissionArgsForCall(i int) (int, []datatypes.User_Customer_CustomerPermission_Permission) {
	fake.addPermissionMutex.RLock()
	defer fake.addPermissionMutex.RUnlock()
	argsForCall := fake.addPermissionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserManager) AddPermissionReturns(result1 bool, result2 error) {
	fake.addPermissionMutex.Lock()
	defer fake.addPermissionMutex.Unlock()
	fake.AddPermissionStub = nil
	fake.addPermissionReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) AddPermissionReturnsOnCall(i int, result1 bool, result2 error) {
	fake.addPermissionMutex.Lock()
	defer fake.addPermissionMutex.Unlock()
	fake.AddPermissionStub = nil
	if fake.addPermissionReturnsOnCall == nil {
		fake.addPermissionReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.addPermissionReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) AddVirtualGuestAccess(arg1 int, arg2 int) (bool, error) {
	fake.addVirtualGuestAccessMutex.Lock()
	ret, specificReturn := fake.addVirtualGuestAccessReturnsOnCall[len(fake.addVirtualGuestAccessArgsForCall)]
	fake.addVirtualGuestAccessArgsForCall = append(fake.addVirtualGuestAccessArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.AddVirtualGuestAccessStub
	fakeReturns := fake.addVirtualGuestAccessReturns
	fake.recordInvocation("AddVirtualGuestAccess", []interface{}{arg1, arg2})
	fake.addVirtualGuestAccessMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) AddVirtualGuestAccessCallCount() int {
	fake.addVirtualGuestAccessMutex.RLock()
	defer fake.addVirtualGuestAccessMutex.RUnlock()
	return len(fake.addVirtualGuestAccessArgsForCall)
}

func (fake *FakeUserManager) AddVirtualGuestAccessCalls(stub func(int, int) (bool, error)) {
	fake.addVirtualGuestAccessMutex.Lock()
	defer fake.addVirtualGuestAccessMutex.Unlock()
	fake.AddVirtualGuestAccessStub = stub
}

func (fake *FakeUserManager) AddVirtualGuestAccessArgsForCall(i int) (int, int) {
	fake.addVirtualGuestAccessMutex.RLock()
	defer fake.addVirtualGuestAccessMutex.RUnlock()
	argsForCall := fake.addVirtualGuestAccessArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserManager) AddVirtualGuestAccessReturns(result1 bool, result2 error) {
	fake.addVirtualGuestAccessMutex.Lock()
	defer fake.addVirtualGuestAccessMutex.Unlock()
	fake.AddVirtualGuestAccessStub = nil
	fake.addVirtualGuestAccessReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) AddVirtualGuestAccessReturnsOnCall(i int, result1 bool, result2 error) {
	fake.addVirtualGuestAccessMutex.Lock()
	defer fake.addVirtualGuestAccessMutex.Unlock()
	fake.AddVirtualGuestAccessStub = nil
	if fake.addVirtualGuestAccessReturnsOnCall == nil {
		fake.addVirtualGuestAccessReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.addVirtualGuestAccessReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) CreateUser(arg1 datatypes.User_Customer, arg2 string, arg3 string) (datatypes.User_Customer, error) {
	fake.createUserMutex.Lock()
	ret, specificReturn := fake.createUserReturnsOnCall[len(fake.createUserArgsForCall)]
	fake.createUserArgsForCall = append(fake.createUserArgsForCall, struct {
		arg1 datatypes.User_Customer
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.CreateUserStub
	fakeReturns := fake.createUserReturns
	fake.recordInvocation("CreateUser", []interface{}{arg1, arg2, arg3})
	fake.createUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) CreateUserCallCount() int {
	fake.createUserMutex.RLock()
	defer fake.createUserMutex.RUnlock()
	return len(fake.createUserArgsForCall)
}

func (fake *FakeUserManager) CreateUserCalls(stub func(datatypes.User_Customer, string, string) (datatypes.User_Customer, error)) {
	fake.createUserMutex.Lock()
	defer fake.createUserMutex.Unlock()
	fake.CreateUserStub = stub
}

func (fake *FakeUserManager) CreateUserArgsForCall(i int) (datatypes.User_Customer, string, string) {
	fake.createUserMutex.RLock()
	defer fake.createUserMutex.RUnlock()
	argsForCall := fake.createUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUserManager) CreateUserReturns(result1 datatypes.User_Customer, result2 error) {
	fake.createUserMutex.Lock()
	defer fake.createUserMutex.Unlock()
	fake.CreateUserStub = nil
	fake.createUserReturns = struct {
		result1 datatypes.User_Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) CreateUserReturnsOnCall(i int, result1 datatypes.User_Customer, result2 error) {
	fake.createUserMutex.Lock()
	defer fake.createUserMutex.Unlock()
	fake.CreateUserStub = nil
	if fake.createUserReturnsOnCall == nil {
		fake.createUserReturnsOnCall = make(map[int]struct {
			result1 datatypes.User_Customer
			result2 error
		})
	}
	fake.createUserReturnsOnCall[i] = struct {
		result1 datatypes.User_Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) CreateUserVpnOverride(arg1 int, arg2 int) (bool, error) {
	fake.createUserVpnOverrideMutex.Lock()
	ret, specificReturn := fake.createUserVpnOverrideReturnsOnCall[len(fake.createUserVpnOverrideArgsForCall)]
	fake.createUserVpnOverrideArgsForCall = append(fake.createUserVpnOverrideArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.CreateUserVpnOverrideStub
	fakeReturns := fake.createUserVpnOverrideReturns
	fake.recordInvocation("CreateUserVpnOverride", []interface{}{arg1, arg2})
	fake.createUserVpnOverrideMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) CreateUserVpnOverrideCallCount() int {
	fake.createUserVpnOverrideMutex.RLock()
	defer fake.createUserVpnOverrideMutex.RUnlock()
	return len(fake.createUserVpnOverrideArgsForCall)
}

func (fake *FakeUserManager) CreateUserVpnOverrideCalls(stub func(int, int) (bool, error)) {
	fake.createUserVpnOverrideMutex.Lock()
	defer fake.createUserVpnOverrideMutex.Unlock()
	fake.CreateUserVpnOverrideStub = stub
}

func (fake *FakeUserManager) CreateUserVpnOverrideArgsForCall(i int) (int, int) {
	fake.createUserVpnOverrideMutex.RLock()
	defer fake.createUserVpnOverrideMutex.RUnlock()
	argsForCall := fake.createUserVpnOverrideArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserManager) CreateUserVpnOverrideReturns(result1 bool, result2 error) {
	fake.createUserVpnOverrideMutex.Lock()
	defer fake.createUserVpnOverrideMutex.Unlock()
	fake.CreateUserVpnOverrideStub = nil
	fake.createUserVpnOverrideReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) CreateUserVpnOverrideReturnsOnCall(i int, result1 bool, result2 error) {
	fake.createUserVpnOverrideMutex.Lock()
	defer fake.createUserVpnOverrideMutex.Unlock()
	fake.CreateUserVpnOverrideStub = nil
	if fake.createUserVpnOverrideReturnsOnCall == nil {
		fake.createUserVpnOverrideReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.createUserVpnOverrideReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) DeleteUserVpnOverride(arg1 int) (bool, error) {
	fake.deleteUserVpnOverrideMutex.Lock()
	ret, specificReturn := fake.deleteUserVpnOverrideReturnsOnCall[len(fake.deleteUserVpnOverrideArgsForCall)]
	fake.deleteUserVpnOverrideArgsForCall = append(fake.deleteUserVpnOverrideArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.DeleteUserVpnOverrideStub
	fakeReturns := fake.deleteUserVpnOverrideReturns
	fake.recordInvocation("DeleteUserVpnOverride", []interface{}{arg1})
	fake.deleteUserVpnOverrideMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) DeleteUserVpnOverrideCallCount() int {
	fake.deleteUserVpnOverrideMutex.RLock()
	defer fake.deleteUserVpnOverrideMutex.RUnlock()
	return len(fake.deleteUserVpnOverrideArgsForCall)
}

func (fake *FakeUserManager) DeleteUserVpnOverrideCalls(stub func(int) (bool, error)) {
	fake.deleteUserVpnOverrideMutex.Lock()
	defer fake.deleteUserVpnOverrideMutex.Unlock()
	fake.DeleteUserVpnOverrideStub = stub
}

func (fake *FakeUserManager) DeleteUserVpnOverrideArgsForCall(i int) int {
	fake.deleteUserVpnOverrideMutex.RLock()
	defer fake.deleteUserVpnOverrideMutex.RUnlock()
	argsForCall := fake.deleteUserVpnOverrideArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserManager) DeleteUserVpnOverrideReturns(result1 bool, result2 error) {
	fake.deleteUserVpnOverrideMutex.Lock()
	defer fake.deleteUserVpnOverrideMutex.Unlock()
	fake.DeleteUserVpnOverrideStub = nil
	fake.deleteUserVpnOverrideReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) DeleteUserVpnOverrideReturnsOnCall(i int, result1 bool, result2 error) {
	fake.deleteUserVpnOverrideMutex.Lock()
	defer fake.deleteUserVpnOverrideMutex.Unlock()
	fake.DeleteUserVpnOverrideStub = nil
	if fake.deleteUserVpnOverrideReturnsOnCall == nil {
		fake.deleteUserVpnOverrideReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.deleteUserVpnOverrideReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) DisableEmailSubscriptionNotification(arg1 int) (bool, error) {
	fake.disableEmailSubscriptionNotificationMutex.Lock()
	ret, specificReturn := fake.disableEmailSubscriptionNotificationReturnsOnCall[len(fake.disableEmailSubscriptionNotificationArgsForCall)]
	fake.disableEmailSubscriptionNotificationArgsForCall = append(fake.disableEmailSubscriptionNotificationArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.DisableEmailSubscriptionNotificationStub
	fakeReturns := fake.disableEmailSubscriptionNotificationReturns
	fake.recordInvocation("DisableEmailSubscriptionNotification", []interface{}{arg1})
	fake.disableEmailSubscriptionNotificationMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) DisableEmailSubscriptionNotificationCallCount() int {
	fake.disableEmailSubscriptionNotificationMutex.RLock()
	defer fake.disableEmailSubscriptionNotificationMutex.RUnlock()
	return len(fake.disableEmailSubscriptionNotificationArgsForCall)
}

func (fake *FakeUserManager) DisableEmailSubscriptionNotificationCalls(stub func(int) (bool, error)) {
	fake.disableEmailSubscriptionNotificationMutex.Lock()
	defer fake.disableEmailSubscriptionNotificationMutex.Unlock()
	fake.DisableEmailSubscriptionNotificationStub = stub
}

func (fake *FakeUserManager) DisableEmailSubscriptionNotificationArgsForCall(i int) int {
	fake.disableEmailSubscriptionNotificationMutex.RLock()
	defer fake.disableEmailSubscriptionNotificationMutex.RUnlock()
	argsForCall := fake.disableEmailSubscriptionNotificationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserManager) DisableEmailSubscriptionNotificationReturns(result1 bool, result2 error) {
	fake.disableEmailSubscriptionNotificationMutex.Lock()
	defer fake.disableEmailSubscriptionNotificationMutex.Unlock()
	fake.DisableEmailSubscriptionNotificationStub = nil
	fake.disableEmailSubscriptionNotificationReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) DisableEmailSubscriptionNotificationReturnsOnCall(i int, result1 bool, result2 error) {
	fake.disableEmailSubscriptionNotificationMutex.Lock()
	defer fake.disableEmailSubscriptionNotificationMutex.Unlock()
	fake.DisableEmailSubscriptionNotificationStub = nil
	if fake.disableEmailSubscriptionNotificationReturnsOnCall == nil {
		fake.disableEmailSubscriptionNotificationReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.disableEmailSubscriptionNotificationReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) EditUser(arg1 datatypes.User_Customer, arg2 int) (bool, error) {
	fake.editUserMutex.Lock()
	ret, specificReturn := fake.editUserReturnsOnCall[len(fake.editUserArgsForCall)]
	fake.editUserArgsForCall = append(fake.editUserArgsForCall, struct {
		arg1 datatypes.User_Customer
		arg2 int
	}{arg1, arg2})
	stub := fake.EditUserStub
	fakeReturns := fake.editUserReturns
	fake.recordInvocation("EditUser", []interface{}{arg1, arg2})
	fake.editUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) EditUserCallCount() int {
	fake.editUserMutex.RLock()
	defer fake.editUserMutex.RUnlock()
	return len(fake.editUserArgsForCall)
}

func (fake *FakeUserManager) EditUserCalls(stub func(datatypes.User_Customer, int) (bool, error)) {
	fake.editUserMutex.Lock()
	defer fake.editUserMutex.Unlock()
	fake.EditUserStub = stub
}

func (fake *FakeUserManager) EditUserArgsForCall(i int) (datatypes.User_Customer, int) {
	fake.editUserMutex.RLock()
	defer fake.editUserMutex.RUnlock()
	argsForCall := fake.editUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserManager) EditUserReturns(result1 bool, result2 error) {
	fake.editUserMutex.Lock()
	defer fake.editUserMutex.Unlock()
	fake.EditUserStub = nil
	fake.editUserReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) EditUserReturnsOnCall(i int, result1 bool, result2 error) {
	fake.editUserMutex.Lock()
	defer fake.editUserMutex.Unlock()
	fake.EditUserStub = nil
	if fake.editUserReturnsOnCall == nil {
		fake.editUserReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.editUserReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) EnableEmailSubscriptionNotification(arg1 int) (bool, error) {
	fake.enableEmailSubscriptionNotificationMutex.Lock()
	ret, specificReturn := fake.enableEmailSubscriptionNotificationReturnsOnCall[len(fake.enableEmailSubscriptionNotificationArgsForCall)]
	fake.enableEmailSubscriptionNotificationArgsForCall = append(fake.enableEmailSubscriptionNotificationArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.EnableEmailSubscriptionNotificationStub
	fakeReturns := fake.enableEmailSubscriptionNotificationReturns
	fake.recordInvocation("EnableEmailSubscriptionNotification", []interface{}{arg1})
	fake.enableEmailSubscriptionNotificationMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) EnableEmailSubscriptionNotificationCallCount() int {
	fake.enableEmailSubscriptionNotificationMutex.RLock()
	defer fake.enableEmailSubscriptionNotificationMutex.RUnlock()
	return len(fake.enableEmailSubscriptionNotificationArgsForCall)
}

func (fake *FakeUserManager) EnableEmailSubscriptionNotificationCalls(stub func(int) (bool, error)) {
	fake.enableEmailSubscriptionNotificationMutex.Lock()
	defer fake.enableEmailSubscriptionNotificationMutex.Unlock()
	fake.EnableEmailSubscriptionNotificationStub = stub
}

func (fake *FakeUserManager) EnableEmailSubscriptionNotificationArgsForCall(i int) int {
	fake.enableEmailSubscriptionNotificationMutex.RLock()
	defer fake.enableEmailSubscriptionNotificationMutex.RUnlock()
	argsForCall := fake.enableEmailSubscriptionNotificationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserManager) EnableEmailSubscriptionNotificationReturns(result1 bool, result2 error) {
	fake.enableEmailSubscriptionNotificationMutex.Lock()
	defer fake.enableEmailSubscriptionNotificationMutex.Unlock()
	fake.EnableEmailSubscriptionNotificationStub = nil
	fake.enableEmailSubscriptionNotificationReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) EnableEmailSubscriptionNotificationReturnsOnCall(i int, result1 bool, result2 error) {
	fake.enableEmailSubscriptionNotificationMutex.Lock()
	defer fake.enableEmailSubscriptionNotificationMutex.Unlock()
	fake.EnableEmailSubscriptionNotificationStub = nil
	if fake.enableEmailSubscriptionNotificationReturnsOnCall == nil {
		fake.enableEmailSubscriptionNotificationReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.enableEmailSubscriptionNotificationReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) FormatPermissionObject(arg1 []string) ([]datatypes.User_Customer_CustomerPermission_Permission, error) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.formatPermissionObjectMutex.Lock()
	ret, specificReturn := fake.formatPermissionObjectReturnsOnCall[len(fake.formatPermissionObjectArgsForCall)]
	fake.formatPermissionObjectArgsForCall = append(fake.formatPermissionObjectArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	stub := fake.FormatPermissionObjectStub
	fakeReturns := fake.formatPermissionObjectReturns
	fake.recordInvocation("FormatPermissionObject", []interface{}{arg1Copy})
	fake.formatPermissionObjectMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) FormatPermissionObjectCallCount() int {
	fake.formatPermissionObjectMutex.RLock()
	defer fake.formatPermissionObjectMutex.RUnlock()
	return len(fake.formatPermissionObjectArgsForCall)
}

func (fake *FakeUserManager) FormatPermissionObjectCalls(stub func([]string) ([]datatypes.User_Customer_CustomerPermission_Permission, error)) {
	fake.formatPermissionObjectMutex.Lock()
	defer fake.formatPermissionObjectMutex.Unlock()
	fake.FormatPermissionObjectStub = stub
}

func (fake *FakeUserManager) FormatPermissionObjectArgsForCall(i int) []string {
	fake.formatPermissionObjectMutex.RLock()
	defer fake.formatPermissionObjectMutex.RUnlock()
	argsForCall := fake.formatPermissionObjectArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserManager) FormatPermissionObjectReturns(result1 []datatypes.User_Customer_CustomerPermission_Permission, result2 error) {
	fake.formatPermissionObjectMutex.Lock()
	defer fake.formatPermissionObjectMutex.Unlock()
	fake.FormatPermissionObjectStub = nil
	fake.formatPermissionObjectReturns = struct {
		result1 []datatypes.User_Customer_CustomerPermission_Permission
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) FormatPermissionObjectReturnsOnCall(i int, result1 []datatypes.User_Customer_CustomerPermission_Permission, result2 error) {
	fake.formatPermissionObjectMutex.Lock()
	defer fake.formatPermissionObjectMutex.Unlock()
	fake.FormatPermissionObjectStub = nil
	if fake.formatPermissionObjectReturnsOnCall == nil {
		fake.formatPermissionObjectReturnsOnCall = make(map[int]struct {
			result1 []datatypes.User_Customer_CustomerPermission_Permission
			result2 error
		})
	}
	fake.formatPermissionObjectReturnsOnCall[i] = struct {
		result1 []datatypes.User_Customer_CustomerPermission_Permission
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetAllNotifications(arg1 string) ([]datatypes.Email_Subscription, error) {
	fake.getAllNotificationsMutex.Lock()
	ret, specificReturn := fake.getAllNotificationsReturnsOnCall[len(fake.getAllNotificationsArgsForCall)]
	fake.getAllNotificationsArgsForCall = append(fake.getAllNotificationsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetAllNotificationsStub
	fakeReturns := fake.getAllNotificationsReturns
	fake.recordInvocation("GetAllNotifications", []interface{}{arg1})
	fake.getAllNotificationsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) GetAllNotificationsCallCount() int {
	fake.getAllNotificationsMutex.RLock()
	defer fake.getAllNotificationsMutex.RUnlock()
	return len(fake.getAllNotificationsArgsForCall)
}

func (fake *FakeUserManager) GetAllNotificationsCalls(stub func(string) ([]datatypes.Email_Subscription, error)) {
	fake.getAllNotificationsMutex.Lock()
	defer fake.getAllNotificationsMutex.Unlock()
	fake.GetAllNotificationsStub = stub
}

func (fake *FakeUserManager) GetAllNotificationsArgsForCall(i int) string {
	fake.getAllNotificationsMutex.RLock()
	defer fake.getAllNotificationsMutex.RUnlock()
	argsForCall := fake.getAllNotificationsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserManager) GetAllNotificationsReturns(result1 []datatypes.Email_Subscription, result2 error) {
	fake.getAllNotificationsMutex.Lock()
	defer fake.getAllNotificationsMutex.Unlock()
	fake.GetAllNotificationsStub = nil
	fake.getAllNotificationsReturns = struct {
		result1 []datatypes.Email_Subscription
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetAllNotificationsReturnsOnCall(i int, result1 []datatypes.Email_Subscription, result2 error) {
	fake.getAllNotificationsMutex.Lock()
	defer fake.getAllNotificationsMutex.Unlock()
	fake.GetAllNotificationsStub = nil
	if fake.getAllNotificationsReturnsOnCall == nil {
		fake.getAllNotificationsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Email_Subscription
			result2 error
		})
	}
	fake.getAllNotificationsReturnsOnCall[i] = struct {
		result1 []datatypes.Email_Subscription
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetAllPermission() ([]datatypes.User_Customer_CustomerPermission_Permission, error) {
	fake.getAllPermissionMutex.Lock()
	ret, specificReturn := fake.getAllPermissionReturnsOnCall[len(fake.getAllPermissionArgsForCall)]
	fake.getAllPermissionArgsForCall = append(fake.getAllPermissionArgsForCall, struct {
	}{})
	stub := fake.GetAllPermissionStub
	fakeReturns := fake.getAllPermissionReturns
	fake.recordInvocation("GetAllPermission", []interface{}{})
	fake.getAllPermissionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) GetAllPermissionCallCount() int {
	fake.getAllPermissionMutex.RLock()
	defer fake.getAllPermissionMutex.RUnlock()
	return len(fake.getAllPermissionArgsForCall)
}

func (fake *FakeUserManager) GetAllPermissionCalls(stub func() ([]datatypes.User_Customer_CustomerPermission_Permission, error)) {
	fake.getAllPermissionMutex.Lock()
	defer fake.getAllPermissionMutex.Unlock()
	fake.GetAllPermissionStub = stub
}

func (fake *FakeUserManager) GetAllPermissionReturns(result1 []datatypes.User_Customer_CustomerPermission_Permission, result2 error) {
	fake.getAllPermissionMutex.Lock()
	defer fake.getAllPermissionMutex.Unlock()
	fake.GetAllPermissionStub = nil
	fake.getAllPermissionReturns = struct {
		result1 []datatypes.User_Customer_CustomerPermission_Permission
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetAllPermissionReturnsOnCall(i int, result1 []datatypes.User_Customer_CustomerPermission_Permission, result2 error) {
	fake.getAllPermissionMutex.Lock()
	defer fake.getAllPermissionMutex.Unlock()
	fake.GetAllPermissionStub = nil
	if fake.getAllPermissionReturnsOnCall == nil {
		fake.getAllPermissionReturnsOnCall = make(map[int]struct {
			result1 []datatypes.User_Customer_CustomerPermission_Permission
			result2 error
		})
	}
	fake.getAllPermissionReturnsOnCall[i] = struct {
		result1 []datatypes.User_Customer_CustomerPermission_Permission
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetCurrentUser() (datatypes.User_Customer, error) {
	fake.getCurrentUserMutex.Lock()
	ret, specificReturn := fake.getCurrentUserReturnsOnCall[len(fake.getCurrentUserArgsForCall)]
	fake.getCurrentUserArgsForCall = append(fake.getCurrentUserArgsForCall, struct {
	}{})
	stub := fake.GetCurrentUserStub
	fakeReturns := fake.getCurrentUserReturns
	fake.recordInvocation("GetCurrentUser", []interface{}{})
	fake.getCurrentUserMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) GetCurrentUserCallCount() int {
	fake.getCurrentUserMutex.RLock()
	defer fake.getCurrentUserMutex.RUnlock()
	return len(fake.getCurrentUserArgsForCall)
}

func (fake *FakeUserManager) GetCurrentUserCalls(stub func() (datatypes.User_Customer, error)) {
	fake.getCurrentUserMutex.Lock()
	defer fake.getCurrentUserMutex.Unlock()
	fake.GetCurrentUserStub = stub
}

func (fake *FakeUserManager) GetCurrentUserReturns(result1 datatypes.User_Customer, result2 error) {
	fake.getCurrentUserMutex.Lock()
	defer fake.getCurrentUserMutex.Unlock()
	fake.GetCurrentUserStub = nil
	fake.getCurrentUserReturns = struct {
		result1 datatypes.User_Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetCurrentUserReturnsOnCall(i int, result1 datatypes.User_Customer, result2 error) {
	fake.getCurrentUserMutex.Lock()
	defer fake.getCurrentUserMutex.Unlock()
	fake.GetCurrentUserStub = nil
	if fake.getCurrentUserReturnsOnCall == nil {
		fake.getCurrentUserReturnsOnCall = make(map[int]struct {
			result1 datatypes.User_Customer
			result2 error
		})
	}
	fake.getCurrentUserReturnsOnCall[i] = struct {
		result1 datatypes.User_Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetDedicatedHosts(arg1 int, arg2 string) ([]datatypes.Virtual_DedicatedHost, error) {
	fake.getDedicatedHostsMutex.Lock()
	ret, specificReturn := fake.getDedicatedHostsReturnsOnCall[len(fake.getDedicatedHostsArgsForCall)]
	fake.getDedicatedHostsArgsForCall = append(fake.getDedicatedHostsArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.GetDedicatedHostsStub
	fakeReturns := fake.getDedicatedHostsReturns
	fake.recordInvocation("GetDedicatedHosts", []interface{}{arg1, arg2})
	fake.getDedicatedHostsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) GetDedicatedHostsCallCount() int {
	fake.getDedicatedHostsMutex.RLock()
	defer fake.getDedicatedHostsMutex.RUnlock()
	return len(fake.getDedicatedHostsArgsForCall)
}

func (fake *FakeUserManager) GetDedicatedHostsCalls(stub func(int, string) ([]datatypes.Virtual_DedicatedHost, error)) {
	fake.getDedicatedHostsMutex.Lock()
	defer fake.getDedicatedHostsMutex.Unlock()
	fake.GetDedicatedHostsStub = stub
}

func (fake *FakeUserManager) GetDedicatedHostsArgsForCall(i int) (int, string) {
	fake.getDedicatedHostsMutex.RLock()
	defer fake.getDedicatedHostsMutex.RUnlock()
	argsForCall := fake.getDedicatedHostsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserManager) GetDedicatedHostsReturns(result1 []datatypes.Virtual_DedicatedHost, result2 error) {
	fake.getDedicatedHostsMutex.Lock()
	defer fake.getDedicatedHostsMutex.Unlock()
	fake.GetDedicatedHostsStub = nil
	fake.getDedicatedHostsReturns = struct {
		result1 []datatypes.Virtual_DedicatedHost
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetDedicatedHostsReturnsOnCall(i int, result1 []datatypes.Virtual_DedicatedHost, result2 error) {
	fake.getDedicatedHostsMutex.Lock()
	defer fake.getDedicatedHostsMutex.Unlock()
	fake.GetDedicatedHostsStub = nil
	if fake.getDedicatedHostsReturnsOnCall == nil {
		fake.getDedicatedHostsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Virtual_DedicatedHost
			result2 error
		})
	}
	fake.getDedicatedHostsReturnsOnCall[i] = struct {
		result1 []datatypes.Virtual_DedicatedHost
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetEvents(arg1 int, arg2 time.Time) ([]datatypes.Event_Log, error) {
	fake.getEventsMutex.Lock()
	ret, specificReturn := fake.getEventsReturnsOnCall[len(fake.getEventsArgsForCall)]
	fake.getEventsArgsForCall = append(fake.getEventsArgsForCall, struct {
		arg1 int
		arg2 time.Time
	}{arg1, arg2})
	stub := fake.GetEventsStub
	fakeReturns := fake.getEventsReturns
	fake.recordInvocation("GetEvents", []interface{}{arg1, arg2})
	fake.getEventsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) GetEventsCallCount() int {
	fake.getEventsMutex.RLock()
	defer fake.getEventsMutex.RUnlock()
	return len(fake.getEventsArgsForCall)
}

func (fake *FakeUserManager) GetEventsCalls(stub func(int, time.Time) ([]datatypes.Event_Log, error)) {
	fake.getEventsMutex.Lock()
	defer fake.getEventsMutex.Unlock()
	fake.GetEventsStub = stub
}

func (fake *FakeUserManager) GetEventsArgsForCall(i int) (int, time.Time) {
	fake.getEventsMutex.RLock()
	defer fake.getEventsMutex.RUnlock()
	argsForCall := fake.getEventsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserManager) GetEventsReturns(result1 []datatypes.Event_Log, result2 error) {
	fake.getEventsMutex.Lock()
	defer fake.getEventsMutex.Unlock()
	fake.GetEventsStub = nil
	fake.getEventsReturns = struct {
		result1 []datatypes.Event_Log
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetEventsReturnsOnCall(i int, result1 []datatypes.Event_Log, result2 error) {
	fake.getEventsMutex.Lock()
	defer fake.getEventsMutex.Unlock()
	fake.GetEventsStub = nil
	if fake.getEventsReturnsOnCall == nil {
		fake.getEventsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Event_Log
			result2 error
		})
	}
	fake.getEventsReturnsOnCall[i] = struct {
		result1 []datatypes.Event_Log
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetHardware(arg1 int, arg2 string) ([]datatypes.Hardware, error) {
	fake.getHardwareMutex.Lock()
	ret, specificReturn := fake.getHardwareReturnsOnCall[len(fake.getHardwareArgsForCall)]
	fake.getHardwareArgsForCall = append(fake.getHardwareArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.GetHardwareStub
	fakeReturns := fake.getHardwareReturns
	fake.recordInvocation("GetHardware", []interface{}{arg1, arg2})
	fake.getHardwareMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) GetHardwareCallCount() int {
	fake.getHardwareMutex.RLock()
	defer fake.getHardwareMutex.RUnlock()
	return len(fake.getHardwareArgsForCall)
}

func (fake *FakeUserManager) GetHardwareCalls(stub func(int, string) ([]datatypes.Hardware, error)) {
	fake.getHardwareMutex.Lock()
	defer fake.getHardwareMutex.Unlock()
	fake.GetHardwareStub = stub
}

func (fake *FakeUserManager) GetHardwareArgsForCall(i int) (int, string) {
	fake.getHardwareMutex.RLock()
	defer fake.getHardwareMutex.RUnlock()
	argsForCall := fake.getHardwareArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserManager) GetHardwareReturns(result1 []datatypes.Hardware, result2 error) {
	fake.getHardwareMutex.Lock()
	defer fake.getHardwareMutex.Unlock()
	fake.GetHardwareStub = nil
	fake.getHardwareReturns = struct {
		result1 []datatypes.Hardware
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetHardwareReturnsOnCall(i int, result1 []datatypes.Hardware, result2 error) {
	fake.getHardwareMutex.Lock()
	defer fake.getHardwareMutex.Unlock()
	fake.GetHardwareStub = nil
	if fake.getHardwareReturnsOnCall == nil {
		fake.getHardwareReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Hardware
			result2 error
		})
	}
	fake.getHardwareReturnsOnCall[i] = struct {
		result1 []datatypes.Hardware
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetIdFromUsername(arg1 string) (int, error) {
	fake.getIdFromUsernameMutex.Lock()
	ret, specificReturn := fake.getIdFromUsernameReturnsOnCall[len(fake.getIdFromUsernameArgsForCall)]
	fake.getIdFromUsernameArgsForCall = append(fake.getIdFromUsernameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetIdFromUsernameStub
	fakeReturns := fake.getIdFromUsernameReturns
	fake.recordInvocation("GetIdFromUsername", []interface{}{arg1})
	fake.getIdFromUsernameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) GetIdFromUsernameCallCount() int {
	fake.getIdFromUsernameMutex.RLock()
	defer fake.getIdFromUsernameMutex.RUnlock()
	return len(fake.getIdFromUsernameArgsForCall)
}

func (fake *FakeUserManager) GetIdFromUsernameCalls(stub func(string) (int, error)) {
	fake.getIdFromUsernameMutex.Lock()
	defer fake.getIdFromUsernameMutex.Unlock()
	fake.GetIdFromUsernameStub = stub
}

func (fake *FakeUserManager) GetIdFromUsernameArgsForCall(i int) string {
	fake.getIdFromUsernameMutex.RLock()
	defer fake.getIdFromUsernameMutex.RUnlock()
	argsForCall := fake.getIdFromUsernameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserManager) GetIdFromUsernameReturns(result1 int, result2 error) {
	fake.getIdFromUsernameMutex.Lock()
	defer fake.getIdFromUsernameMutex.Unlock()
	fake.GetIdFromUsernameStub = nil
	fake.getIdFromUsernameReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetIdFromUsernameReturnsOnCall(i int, result1 int, result2 error) {
	fake.getIdFromUsernameMutex.Lock()
	defer fake.getIdFromUsernameMutex.Unlock()
	fake.GetIdFromUsernameStub = nil
	if fake.getIdFromUsernameReturnsOnCall == nil {
		fake.getIdFromUsernameReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.getIdFromUsernameReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetLogins(arg1 int, arg2 time.Time) ([]datatypes.User_Customer_Access_Authentication, error) {
	fake.getLoginsMutex.Lock()
	ret, specificReturn := fake.getLoginsReturnsOnCall[len(fake.getLoginsArgsForCall)]
	fake.getLoginsArgsForCall = append(fake.getLoginsArgsForCall, struct {
		arg1 int
		arg2 time.Time
	}{arg1, arg2})
	stub := fake.GetLoginsStub
	fakeReturns := fake.getLoginsReturns
	fake.recordInvocation("GetLogins", []interface{}{arg1, arg2})
	fake.getLoginsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) GetLoginsCallCount() int {
	fake.getLoginsMutex.RLock()
	defer fake.getLoginsMutex.RUnlock()
	return len(fake.getLoginsArgsForCall)
}

func (fake *FakeUserManager) GetLoginsCalls(stub func(int, time.Time) ([]datatypes.User_Customer_Access_Authentication, error)) {
	fake.getLoginsMutex.Lock()
	defer fake.getLoginsMutex.Unlock()
	fake.GetLoginsStub = stub
}

func (fake *FakeUserManager) GetLoginsArgsForCall(i int) (int, time.Time) {
	fake.getLoginsMutex.RLock()
	defer fake.getLoginsMutex.RUnlock()
	argsForCall := fake.getLoginsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserManager) GetLoginsReturns(result1 []datatypes.User_Customer_Access_Authentication, result2 error) {
	fake.getLoginsMutex.Lock()
	defer fake.getLoginsMutex.Unlock()
	fake.GetLoginsStub = nil
	fake.getLoginsReturns = struct {
		result1 []datatypes.User_Customer_Access_Authentication
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetLoginsReturnsOnCall(i int, result1 []datatypes.User_Customer_Access_Authentication, result2 error) {
	fake.getLoginsMutex.Lock()
	defer fake.getLoginsMutex.Unlock()
	fake.GetLoginsStub = nil
	if fake.getLoginsReturnsOnCall == nil {
		fake.getLoginsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.User_Customer_Access_Authentication
			result2 error
		})
	}
	fake.getLoginsReturnsOnCall[i] = struct {
		result1 []datatypes.User_Customer_Access_Authentication
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetOverrides(arg1 int) ([]datatypes.Network_Service_Vpn_Overrides, error) {
	fake.getOverridesMutex.Lock()
	ret, specificReturn := fake.getOverridesReturnsOnCall[len(fake.getOverridesArgsForCall)]
	fake.getOverridesArgsForCall = append(fake.getOverridesArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.GetOverridesStub
	fakeReturns := fake.getOverridesReturns
	fake.recordInvocation("GetOverrides", []interface{}{arg1})
	fake.getOverridesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) GetOverridesCallCount() int {
	fake.getOverridesMutex.RLock()
	defer fake.getOverridesMutex.RUnlock()
	return len(fake.getOverridesArgsForCall)
}

func (fake *FakeUserManager) GetOverridesCalls(stub func(int) ([]datatypes.Network_Service_Vpn_Overrides, error)) {
	fake.getOverridesMutex.Lock()
	defer fake.getOverridesMutex.Unlock()
	fake.GetOverridesStub = stub
}

func (fake *FakeUserManager) GetOverridesArgsForCall(i int) int {
	fake.getOverridesMutex.RLock()
	defer fake.getOverridesMutex.RUnlock()
	argsForCall := fake.getOverridesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserManager) GetOverridesReturns(result1 []datatypes.Network_Service_Vpn_Overrides, result2 error) {
	fake.getOverridesMutex.Lock()
	defer fake.getOverridesMutex.Unlock()
	fake.GetOverridesStub = nil
	fake.getOverridesReturns = struct {
		result1 []datatypes.Network_Service_Vpn_Overrides
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetOverridesReturnsOnCall(i int, result1 []datatypes.Network_Service_Vpn_Overrides, result2 error) {
	fake.getOverridesMutex.Lock()
	defer fake.getOverridesMutex.Unlock()
	fake.GetOverridesStub = nil
	if fake.getOverridesReturnsOnCall == nil {
		fake.getOverridesReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Network_Service_Vpn_Overrides
			result2 error
		})
	}
	fake.getOverridesReturnsOnCall[i] = struct {
		result1 []datatypes.Network_Service_Vpn_Overrides
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetUser(arg1 int, arg2 string) (datatypes.User_Customer, error) {
	fake.getUserMutex.Lock()
	ret, specificReturn := fake.getUserReturnsOnCall[len(fake.getUserArgsForCall)]
	fake.getUserArgsForCall = append(fake.getUserArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.GetUserStub
	fakeReturns := fake.getUserReturns
	fake.recordInvocation("GetUser", []interface{}{arg1, arg2})
	fake.getUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) GetUserCallCount() int {
	fake.getUserMutex.RLock()
	defer fake.getUserMutex.RUnlock()
	return len(fake.getUserArgsForCall)
}

func (fake *FakeUserManager) GetUserCalls(stub func(int, string) (datatypes.User_Customer, error)) {
	fake.getUserMutex.Lock()
	defer fake.getUserMutex.Unlock()
	fake.GetUserStub = stub
}

func (fake *FakeUserManager) GetUserArgsForCall(i int) (int, string) {
	fake.getUserMutex.RLock()
	defer fake.getUserMutex.RUnlock()
	argsForCall := fake.getUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserManager) GetUserReturns(result1 datatypes.User_Customer, result2 error) {
	fake.getUserMutex.Lock()
	defer fake.getUserMutex.Unlock()
	fake.GetUserStub = nil
	fake.getUserReturns = struct {
		result1 datatypes.User_Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetUserReturnsOnCall(i int, result1 datatypes.User_Customer, result2 error) {
	fake.getUserMutex.Lock()
	defer fake.getUserMutex.Unlock()
	fake.GetUserStub = nil
	if fake.getUserReturnsOnCall == nil {
		fake.getUserReturnsOnCall = make(map[int]struct {
			result1 datatypes.User_Customer
			result2 error
		})
	}
	fake.getUserReturnsOnCall[i] = struct {
		result1 datatypes.User_Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetUserAllowDevicesPermissions(arg1 int) ([]datatypes.User_Customer_CustomerPermission_Permission, error) {
	fake.getUserAllowDevicesPermissionsMutex.Lock()
	ret, specificReturn := fake.getUserAllowDevicesPermissionsReturnsOnCall[len(fake.getUserAllowDevicesPermissionsArgsForCall)]
	fake.getUserAllowDevicesPermissionsArgsForCall = append(fake.getUserAllowDevicesPermissionsArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.GetUserAllowDevicesPermissionsStub
	fakeReturns := fake.getUserAllowDevicesPermissionsReturns
	fake.recordInvocation("GetUserAllowDevicesPermissions", []interface{}{arg1})
	fake.getUserAllowDevicesPermissionsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) GetUserAllowDevicesPermissionsCallCount() int {
	fake.getUserAllowDevicesPermissionsMutex.RLock()
	defer fake.getUserAllowDevicesPermissionsMutex.RUnlock()
	return len(fake.getUserAllowDevicesPermissionsArgsForCall)
}

func (fake *FakeUserManager) GetUserAllowDevicesPermissionsCalls(stub func(int) ([]datatypes.User_Customer_CustomerPermission_Permission, error)) {
	fake.getUserAllowDevicesPermissionsMutex.Lock()
	defer fake.getUserAllowDevicesPermissionsMutex.Unlock()
	fake.GetUserAllowDevicesPermissionsStub = stub
}

func (fake *FakeUserManager) GetUserAllowDevicesPermissionsArgsForCall(i int) int {
	fake.getUserAllowDevicesPermissionsMutex.RLock()
	defer fake.getUserAllowDevicesPermissionsMutex.RUnlock()
	argsForCall := fake.getUserAllowDevicesPermissionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserManager) GetUserAllowDevicesPermissionsReturns(result1 []datatypes.User_Customer_CustomerPermission_Permission, result2 error) {
	fake.getUserAllowDevicesPermissionsMutex.Lock()
	defer fake.getUserAllowDevicesPermissionsMutex.Unlock()
	fake.GetUserAllowDevicesPermissionsStub = nil
	fake.getUserAllowDevicesPermissionsReturns = struct {
		result1 []datatypes.User_Customer_CustomerPermission_Permission
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetUserAllowDevicesPermissionsReturnsOnCall(i int, result1 []datatypes.User_Customer_CustomerPermission_Permission, result2 error) {
	fake.getUserAllowDevicesPermissionsMutex.Lock()
	defer fake.getUserAllowDevicesPermissionsMutex.Unlock()
	fake.GetUserAllowDevicesPermissionsStub = nil
	if fake.getUserAllowDevicesPermissionsReturnsOnCall == nil {
		fake.getUserAllowDevicesPermissionsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.User_Customer_CustomerPermission_Permission
			result2 error
		})
	}
	fake.getUserAllowDevicesPermissionsReturnsOnCall[i] = struct {
		result1 []datatypes.User_Customer_CustomerPermission_Permission
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetUserPermissions(arg1 int) ([]datatypes.User_Customer_CustomerPermission_Permission, error) {
	fake.getUserPermissionsMutex.Lock()
	ret, specificReturn := fake.getUserPermissionsReturnsOnCall[len(fake.getUserPermissionsArgsForCall)]
	fake.getUserPermissionsArgsForCall = append(fake.getUserPermissionsArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.GetUserPermissionsStub
	fakeReturns := fake.getUserPermissionsReturns
	fake.recordInvocation("GetUserPermissions", []interface{}{arg1})
	fake.getUserPermissionsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) GetUserPermissionsCallCount() int {
	fake.getUserPermissionsMutex.RLock()
	defer fake.getUserPermissionsMutex.RUnlock()
	return len(fake.getUserPermissionsArgsForCall)
}

func (fake *FakeUserManager) GetUserPermissionsCalls(stub func(int) ([]datatypes.User_Customer_CustomerPermission_Permission, error)) {
	fake.getUserPermissionsMutex.Lock()
	defer fake.getUserPermissionsMutex.Unlock()
	fake.GetUserPermissionsStub = stub
}

func (fake *FakeUserManager) GetUserPermissionsArgsForCall(i int) int {
	fake.getUserPermissionsMutex.RLock()
	defer fake.getUserPermissionsMutex.RUnlock()
	argsForCall := fake.getUserPermissionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserManager) GetUserPermissionsReturns(result1 []datatypes.User_Customer_CustomerPermission_Permission, result2 error) {
	fake.getUserPermissionsMutex.Lock()
	defer fake.getUserPermissionsMutex.Unlock()
	fake.GetUserPermissionsStub = nil
	fake.getUserPermissionsReturns = struct {
		result1 []datatypes.User_Customer_CustomerPermission_Permission
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetUserPermissionsReturnsOnCall(i int, result1 []datatypes.User_Customer_CustomerPermission_Permission, result2 error) {
	fake.getUserPermissionsMutex.Lock()
	defer fake.getUserPermissionsMutex.Unlock()
	fake.GetUserPermissionsStub = nil
	if fake.getUserPermissionsReturnsOnCall == nil {
		fake.getUserPermissionsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.User_Customer_CustomerPermission_Permission
			result2 error
		})
	}
	fake.getUserPermissionsReturnsOnCall[i] = struct {
		result1 []datatypes.User_Customer_CustomerPermission_Permission
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetVirtualGuests(arg1 int, arg2 string) ([]datatypes.Virtual_Guest, error) {
	fake.getVirtualGuestsMutex.Lock()
	ret, specificReturn := fake.getVirtualGuestsReturnsOnCall[len(fake.getVirtualGuestsArgsForCall)]
	fake.getVirtualGuestsArgsForCall = append(fake.getVirtualGuestsArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.GetVirtualGuestsStub
	fakeReturns := fake.getVirtualGuestsReturns
	fake.recordInvocation("GetVirtualGuests", []interface{}{arg1, arg2})
	fake.getVirtualGuestsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) GetVirtualGuestsCallCount() int {
	fake.getVirtualGuestsMutex.RLock()
	defer fake.getVirtualGuestsMutex.RUnlock()
	return len(fake.getVirtualGuestsArgsForCall)
}

func (fake *FakeUserManager) GetVirtualGuestsCalls(stub func(int, string) ([]datatypes.Virtual_Guest, error)) {
	fake.getVirtualGuestsMutex.Lock()
	defer fake.getVirtualGuestsMutex.Unlock()
	fake.GetVirtualGuestsStub = stub
}

func (fake *FakeUserManager) GetVirtualGuestsArgsForCall(i int) (int, string) {
	fake.getVirtualGuestsMutex.RLock()
	defer fake.getVirtualGuestsMutex.RUnlock()
	argsForCall := fake.getVirtualGuestsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserManager) GetVirtualGuestsReturns(result1 []datatypes.Virtual_Guest, result2 error) {
	fake.getVirtualGuestsMutex.Lock()
	defer fake.getVirtualGuestsMutex.Unlock()
	fake.GetVirtualGuestsStub = nil
	fake.getVirtualGuestsReturns = struct {
		result1 []datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetVirtualGuestsReturnsOnCall(i int, result1 []datatypes.Virtual_Guest, result2 error) {
	fake.getVirtualGuestsMutex.Lock()
	defer fake.getVirtualGuestsMutex.Unlock()
	fake.GetVirtualGuestsStub = nil
	if fake.getVirtualGuestsReturnsOnCall == nil {
		fake.getVirtualGuestsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Virtual_Guest
			result2 error
		})
	}
	fake.getVirtualGuestsReturnsOnCall[i] = struct {
		result1 []datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) ListUsers(arg1 string) ([]datatypes.User_Customer, error) {
	fake.listUsersMutex.Lock()
	ret, specificReturn := fake.listUsersReturnsOnCall[len(fake.listUsersArgsForCall)]
	fake.listUsersArgsForCall = append(fake.listUsersArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ListUsersStub
	fakeReturns := fake.listUsersReturns
	fake.recordInvocation("ListUsers", []interface{}{arg1})
	fake.listUsersMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) ListUsersCallCount() int {
	fake.listUsersMutex.RLock()
	defer fake.listUsersMutex.RUnlock()
	return len(fake.listUsersArgsForCall)
}

func (fake *FakeUserManager) ListUsersCalls(stub func(string) ([]datatypes.User_Customer, error)) {
	fake.listUsersMutex.Lock()
	defer fake.listUsersMutex.Unlock()
	fake.ListUsersStub = stub
}

func (fake *FakeUserManager) ListUsersArgsForCall(i int) string {
	fake.listUsersMutex.RLock()
	defer fake.listUsersMutex.RUnlock()
	argsForCall := fake.listUsersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserManager) ListUsersReturns(result1 []datatypes.User_Customer, result2 error) {
	fake.listUsersMutex.Lock()
	defer fake.listUsersMutex.Unlock()
	fake.ListUsersStub = nil
	fake.listUsersReturns = struct {
		result1 []datatypes.User_Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) ListUsersReturnsOnCall(i int, result1 []datatypes.User_Customer, result2 error) {
	fake.listUsersMutex.Lock()
	defer fake.listUsersMutex.Unlock()
	fake.ListUsersStub = nil
	if fake.listUsersReturnsOnCall == nil {
		fake.listUsersReturnsOnCall = make(map[int]struct {
			result1 []datatypes.User_Customer
			result2 error
		})
	}
	fake.listUsersReturnsOnCall[i] = struct {
		result1 []datatypes.User_Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) PermissionFromUser(arg1 int, arg2 int) error {
	fake.permissionFromUserMutex.Lock()
	ret, specificReturn := fake.permissionFromUserReturnsOnCall[len(fake.permissionFromUserArgsForCall)]
	fake.permissionFromUserArgsForCall = append(fake.permissionFromUserArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.PermissionFromUserStub
	fakeReturns := fake.permissionFromUserReturns
	fake.recordInvocation("PermissionFromUser", []interface{}{arg1, arg2})
	fake.permissionFromUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUserManager) PermissionFromUserCallCount() int {
	fake.permissionFromUserMutex.RLock()
	defer fake.permissionFromUserMutex.RUnlock()
	return len(fake.permissionFromUserArgsForCall)
}

func (fake *FakeUserManager) PermissionFromUserCalls(stub func(int, int) error) {
	fake.permissionFromUserMutex.Lock()
	defer fake.permissionFromUserMutex.Unlock()
	fake.PermissionFromUserStub = stub
}

func (fake *FakeUserManager) PermissionFromUserArgsForCall(i int) (int, int) {
	fake.permissionFromUserMutex.RLock()
	defer fake.permissionFromUserMutex.RUnlock()
	argsForCall := fake.permissionFromUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserManager) PermissionFromUserReturns(result1 error) {
	fake.permissionFromUserMutex.Lock()
	defer fake.permissionFromUserMutex.Unlock()
	fake.PermissionFromUserStub = nil
	fake.permissionFromUserReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserManager) PermissionFromUserReturnsOnCall(i int, result1 error) {
	fake.permissionFromUserMutex.Lock()
	defer fake.permissionFromUserMutex.Unlock()
	fake.PermissionFromUserStub = nil
	if fake.permissionFromUserReturnsOnCall == nil {
		fake.permissionFromUserReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.permissionFromUserReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserManager) RemoveDedicatedHostAccess(arg1 int, arg2 int) (bool, error) {
	fake.removeDedicatedHostAccessMutex.Lock()
	ret, specificReturn := fake.removeDedicatedHostAccessReturnsOnCall[len(fake.removeDedicatedHostAccessArgsForCall)]
	fake.removeDedicatedHostAccessArgsForCall = append(fake.removeDedicatedHostAccessArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.RemoveDedicatedHostAccessStub
	fakeReturns := fake.removeDedicatedHostAccessReturns
	fake.recordInvocation("RemoveDedicatedHostAccess", []interface{}{arg1, arg2})
	fake.removeDedicatedHostAccessMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) RemoveDedicatedHostAccessCallCount() int {
	fake.removeDedicatedHostAccessMutex.RLock()
	defer fake.removeDedicatedHostAccessMutex.RUnlock()
	return len(fake.removeDedicatedHostAccessArgsForCall)
}

func (fake *FakeUserManager) RemoveDedicatedHostAccessCalls(stub func(int, int) (bool, error)) {
	fake.removeDedicatedHostAccessMutex.Lock()
	defer fake.removeDedicatedHostAccessMutex.Unlock()
	fake.RemoveDedicatedHostAccessStub = stub
}

func (fake *FakeUserManager) RemoveDedicatedHostAccessArgsForCall(i int) (int, int) {
	fake.removeDedicatedHostAccessMutex.RLock()
	defer fake.removeDedicatedHostAccessMutex.RUnlock()
	argsForCall := fake.removeDedicatedHostAccessArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserManager) RemoveDedicatedHostAccessReturns(result1 bool, result2 error) {
	fake.removeDedicatedHostAccessMutex.Lock()
	defer fake.removeDedicatedHostAccessMutex.Unlock()
	fake.RemoveDedicatedHostAccessStub = nil
	fake.removeDedicatedHostAccessReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) RemoveDedicatedHostAccessReturnsOnCall(i int, result1 bool, result2 error) {
	fake.removeDedicatedHostAccessMutex.Lock()
	defer fake.removeDedicatedHostAccessMutex.Unlock()
	fake.RemoveDedicatedHostAccessStub = nil
	if fake.removeDedicatedHostAccessReturnsOnCall == nil {
		fake.removeDedicatedHostAccessReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.removeDedicatedHostAccessReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) RemoveHardwareAccess(arg1 int, arg2 int) (bool, error) {
	fake.removeHardwareAccessMutex.Lock()
	ret, specificReturn := fake.removeHardwareAccessReturnsOnCall[len(fake.removeHardwareAccessArgsForCall)]
	fake.removeHardwareAccessArgsForCall = append(fake.removeHardwareAccessArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.RemoveHardwareAccessStub
	fakeReturns := fake.removeHardwareAccessReturns
	fake.recordInvocation("RemoveHardwareAccess", []interface{}{arg1, arg2})
	fake.removeHardwareAccessMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) RemoveHardwareAccessCallCount() int {
	fake.removeHardwareAccessMutex.RLock()
	defer fake.removeHardwareAccessMutex.RUnlock()
	return len(fake.removeHardwareAccessArgsForCall)
}

func (fake *FakeUserManager) RemoveHardwareAccessCalls(stub func(int, int) (bool, error)) {
	fake.removeHardwareAccessMutex.Lock()
	defer fake.removeHardwareAccessMutex.Unlock()
	fake.RemoveHardwareAccessStub = stub
}

func (fake *FakeUserManager) RemoveHardwareAccessArgsForCall(i int) (int, int) {
	fake.removeHardwareAccessMutex.RLock()
	defer fake.removeHardwareAccessMutex.RUnlock()
	argsForCall := fake.removeHardwareAccessArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserManager) RemoveHardwareAccessReturns(result1 bool, result2 error) {
	fake.removeHardwareAccessMutex.Lock()
	defer fake.removeHardwareAccessMutex.Unlock()
	fake.RemoveHardwareAccessStub = nil
	fake.removeHardwareAccessReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) RemoveHardwareAccessReturnsOnCall(i int, result1 bool, result2 error) {
	fake.removeHardwareAccessMutex.Lock()
	defer fake.removeHardwareAccessMutex.Unlock()
	fake.RemoveHardwareAccessStub = nil
	if fake.removeHardwareAccessReturnsOnCall == nil {
		fake.removeHardwareAccessReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.removeHardwareAccessReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) RemovePermission(arg1 int, arg2 []datatypes.User_Customer_CustomerPermission_Permission) (bool, error) {
	var arg2Copy []datatypes.User_Customer_CustomerPermission_Permission
	if arg2 != nil {
		arg2Copy = make([]datatypes.User_Customer_CustomerPermission_Permission, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.removePermissionMutex.Lock()
	ret, specificReturn := fake.removePermissionReturnsOnCall[len(fake.removePermissionArgsForCall)]
	fake.removePermissionArgsForCall = append(fake.removePermissionArgsForCall, struct {
		arg1 int
		arg2 []datatypes.User_Customer_CustomerPermission_Permission
	}{arg1, arg2Copy})
	stub := fake.RemovePermissionStub
	fakeReturns := fake.removePermissionReturns
	fake.recordInvocation("RemovePermission", []interface{}{arg1, arg2Copy})
	fake.removePermissionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) RemovePermissionCallCount() int {
	fake.removePermissionMutex.RLock()
	defer fake.removePermissionMutex.RUnlock()
	return len(fake.removePermissionArgsForCall)
}

func (fake *FakeUserManager) RemovePermissionCalls(stub func(int, []datatypes.User_Customer_CustomerPermission_Permission) (bool, error)) {
	fake.removePermissionMutex.Lock()
	defer fake.removePermissionMutex.Unlock()
	fake.RemovePermissionStub = stub
}

func (fake *FakeUserManager) RemovePermissionArgsForCall(i int) (int, []datatypes.User_Customer_CustomerPermission_Permission) {
	fake.removePermissionMutex.RLock()
	defer fake.removePermissionMutex.RUnlock()
	argsForCall := fake.removePermissionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserManager) RemovePermissionReturns(result1 bool, result2 error) {
	fake.removePermissionMutex.Lock()
	defer fake.removePermissionMutex.Unlock()
	fake.RemovePermissionStub = nil
	fake.removePermissionReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) RemovePermissionReturnsOnCall(i int, result1 bool, result2 error) {
	fake.removePermissionMutex.Lock()
	defer fake.removePermissionMutex.Unlock()
	fake.RemovePermissionStub = nil
	if fake.removePermissionReturnsOnCall == nil {
		fake.removePermissionReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.removePermissionReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) RemoveVirtualGuestAccess(arg1 int, arg2 int) (bool, error) {
	fake.removeVirtualGuestAccessMutex.Lock()
	ret, specificReturn := fake.removeVirtualGuestAccessReturnsOnCall[len(fake.removeVirtualGuestAccessArgsForCall)]
	fake.removeVirtualGuestAccessArgsForCall = append(fake.removeVirtualGuestAccessArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.RemoveVirtualGuestAccessStub
	fakeReturns := fake.removeVirtualGuestAccessReturns
	fake.recordInvocation("RemoveVirtualGuestAccess", []interface{}{arg1, arg2})
	fake.removeVirtualGuestAccessMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) RemoveVirtualGuestAccessCallCount() int {
	fake.removeVirtualGuestAccessMutex.RLock()
	defer fake.removeVirtualGuestAccessMutex.RUnlock()
	return len(fake.removeVirtualGuestAccessArgsForCall)
}

func (fake *FakeUserManager) RemoveVirtualGuestAccessCalls(stub func(int, int) (bool, error)) {
	fake.removeVirtualGuestAccessMutex.Lock()
	defer fake.removeVirtualGuestAccessMutex.Unlock()
	fake.RemoveVirtualGuestAccessStub = stub
}

func (fake *FakeUserManager) RemoveVirtualGuestAccessArgsForCall(i int) (int, int) {
	fake.removeVirtualGuestAccessMutex.RLock()
	defer fake.removeVirtualGuestAccessMutex.RUnlock()
	argsForCall := fake.removeVirtualGuestAccessArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserManager) RemoveVirtualGuestAccessReturns(result1 bool, result2 error) {
	fake.removeVirtualGuestAccessMutex.Lock()
	defer fake.removeVirtualGuestAccessMutex.Unlock()
	fake.RemoveVirtualGuestAccessStub = nil
	fake.removeVirtualGuestAccessReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) RemoveVirtualGuestAccessReturnsOnCall(i int, result1 bool, result2 error) {
	fake.removeVirtualGuestAccessMutex.Lock()
	defer fake.removeVirtualGuestAccessMutex.Unlock()
	fake.RemoveVirtualGuestAccessStub = nil
	if fake.removeVirtualGuestAccessReturnsOnCall == nil {
		fake.removeVirtualGuestAccessReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.removeVirtualGuestAccessReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) UpdateVpnUser(arg1 int) (bool, error) {
	fake.updateVpnUserMutex.Lock()
	ret, specificReturn := fake.updateVpnUserReturnsOnCall[len(fake.updateVpnUserArgsForCall)]
	fake.updateVpnUserArgsForCall = append(fake.updateVpnUserArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.UpdateVpnUserStub
	fakeReturns := fake.updateVpnUserReturns
	fake.recordInvocation("UpdateVpnUser", []interface{}{arg1})
	fake.updateVpnUserMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) UpdateVpnUserCallCount() int {
	fake.updateVpnUserMutex.RLock()
	defer fake.updateVpnUserMutex.RUnlock()
	return len(fake.updateVpnUserArgsForCall)
}

func (fake *FakeUserManager) UpdateVpnUserCalls(stub func(int) (bool, error)) {
	fake.updateVpnUserMutex.Lock()
	defer fake.updateVpnUserMutex.Unlock()
	fake.UpdateVpnUserStub = stub
}

func (fake *FakeUserManager) UpdateVpnUserArgsForCall(i int) int {
	fake.updateVpnUserMutex.RLock()
	defer fake.updateVpnUserMutex.RUnlock()
	argsForCall := fake.updateVpnUserArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserManager) UpdateVpnUserReturns(result1 bool, result2 error) {
	fake.updateVpnUserMutex.Lock()
	defer fake.updateVpnUserMutex.Unlock()
	fake.UpdateVpnUserStub = nil
	fake.updateVpnUserReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) UpdateVpnUserReturnsOnCall(i int, result1 bool, result2 error) {
	fake.updateVpnUserMutex.Lock()
	defer fake.updateVpnUserMutex.Unlock()
	fake.UpdateVpnUserStub = nil
	if fake.updateVpnUserReturnsOnCall == nil {
		fake.updateVpnUserReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.updateVpnUserReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addApiAuthenticationKeyMutex.RLock()
	defer fake.addApiAuthenticationKeyMutex.RUnlock()
	fake.addDedicatedHostAccessMutex.RLock()
	defer fake.addDedicatedHostAccessMutex.RUnlock()
	fake.addHardwareAccessMutex.RLock()
	defer fake.addHardwareAccessMutex.RUnlock()
	fake.addPermissionMutex.RLock()
	defer fake.addPermissionMutex.RUnlock()
	fake.addVirtualGuestAccessMutex.RLock()
	defer fake.addVirtualGuestAccessMutex.RUnlock()
	fake.createUserMutex.RLock()
	defer fake.createUserMutex.RUnlock()
	fake.createUserVpnOverrideMutex.RLock()
	defer fake.createUserVpnOverrideMutex.RUnlock()
	fake.deleteUserVpnOverrideMutex.RLock()
	defer fake.deleteUserVpnOverrideMutex.RUnlock()
	fake.disableEmailSubscriptionNotificationMutex.RLock()
	defer fake.disableEmailSubscriptionNotificationMutex.RUnlock()
	fake.editUserMutex.RLock()
	defer fake.editUserMutex.RUnlock()
	fake.enableEmailSubscriptionNotificationMutex.RLock()
	defer fake.enableEmailSubscriptionNotificationMutex.RUnlock()
	fake.formatPermissionObjectMutex.RLock()
	defer fake.formatPermissionObjectMutex.RUnlock()
	fake.getAllNotificationsMutex.RLock()
	defer fake.getAllNotificationsMutex.RUnlock()
	fake.getAllPermissionMutex.RLock()
	defer fake.getAllPermissionMutex.RUnlock()
	fake.getCurrentUserMutex.RLock()
	defer fake.getCurrentUserMutex.RUnlock()
	fake.getDedicatedHostsMutex.RLock()
	defer fake.getDedicatedHostsMutex.RUnlock()
	fake.getEventsMutex.RLock()
	defer fake.getEventsMutex.RUnlock()
	fake.getHardwareMutex.RLock()
	defer fake.getHardwareMutex.RUnlock()
	fake.getIdFromUsernameMutex.RLock()
	defer fake.getIdFromUsernameMutex.RUnlock()
	fake.getLoginsMutex.RLock()
	defer fake.getLoginsMutex.RUnlock()
	fake.getOverridesMutex.RLock()
	defer fake.getOverridesMutex.RUnlock()
	fake.getUserMutex.RLock()
	defer fake.getUserMutex.RUnlock()
	fake.getUserAllowDevicesPermissionsMutex.RLock()
	defer fake.getUserAllowDevicesPermissionsMutex.RUnlock()
	fake.getUserPermissionsMutex.RLock()
	defer fake.getUserPermissionsMutex.RUnlock()
	fake.getVirtualGuestsMutex.RLock()
	defer fake.getVirtualGuestsMutex.RUnlock()
	fake.listUsersMutex.RLock()
	defer fake.listUsersMutex.RUnlock()
	fake.permissionFromUserMutex.RLock()
	defer fake.permissionFromUserMutex.RUnlock()
	fake.removeDedicatedHostAccessMutex.RLock()
	defer fake.removeDedicatedHostAccessMutex.RUnlock()
	fake.removeHardwareAccessMutex.RLock()
	defer fake.removeHardwareAccessMutex.RUnlock()
	fake.removePermissionMutex.RLock()
	defer fake.removePermissionMutex.RUnlock()
	fake.removeVirtualGuestAccessMutex.RLock()
	defer fake.removeVirtualGuestAccessMutex.RUnlock()
	fake.updateVpnUserMutex.RLock()
	defer fake.updateVpnUserMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeUserManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ managers.UserManager = new(FakeUserManager)
