// Code generated by counterfeiter. DO NOT EDIT.
package testhelpers

import (
	"sync"
	"time"

	"github.com/softlayer/softlayer-go/datatypes"
	"github.ibm.com/SoftLayer/softlayer-cli/plugin/managers"
)

type FakeUserManager struct {
	AddApiAuthenticationKeyStub        func(int) (string, error)
	addApiAuthenticationKeyMutex       sync.RWMutex
	addApiAuthenticationKeyArgsForCall []struct {
		arg1 int
	}
	addApiAuthenticationKeyReturns struct {
		result1 string
		result2 error
	}
	addApiAuthenticationKeyReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	AddPermissionStub        func(int, []datatypes.User_Customer_CustomerPermission_Permission) (bool, error)
	addPermissionMutex       sync.RWMutex
	addPermissionArgsForCall []struct {
		arg1 int
		arg2 []datatypes.User_Customer_CustomerPermission_Permission
	}
	addPermissionReturns struct {
		result1 bool
		result2 error
	}
	addPermissionReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CreateUserStub        func(datatypes.User_Customer, string, string) (datatypes.User_Customer, error)
	createUserMutex       sync.RWMutex
	createUserArgsForCall []struct {
		arg1 datatypes.User_Customer
		arg2 string
		arg3 string
	}
	createUserReturns struct {
		result1 datatypes.User_Customer
		result2 error
	}
	createUserReturnsOnCall map[int]struct {
		result1 datatypes.User_Customer
		result2 error
	}
	EditUserStub        func(datatypes.User_Customer, int) (bool, error)
	editUserMutex       sync.RWMutex
	editUserArgsForCall []struct {
		arg1 datatypes.User_Customer
		arg2 int
	}
	editUserReturns struct {
		result1 bool
		result2 error
	}
	editUserReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	FormatPermissionObjectStub        func([]string) ([]datatypes.User_Customer_CustomerPermission_Permission, error)
	formatPermissionObjectMutex       sync.RWMutex
	formatPermissionObjectArgsForCall []struct {
		arg1 []string
	}
	formatPermissionObjectReturns struct {
		result1 []datatypes.User_Customer_CustomerPermission_Permission
		result2 error
	}
	formatPermissionObjectReturnsOnCall map[int]struct {
		result1 []datatypes.User_Customer_CustomerPermission_Permission
		result2 error
	}
	GetAllNotificationsStub        func(string) ([]datatypes.Email_Subscription, error)
	getAllNotificationsMutex       sync.RWMutex
	getAllNotificationsArgsForCall []struct {
		arg1 string
	}
	getAllNotificationsReturns struct {
		result1 []datatypes.Email_Subscription
		result2 error
	}
	getAllNotificationsReturnsOnCall map[int]struct {
		result1 []datatypes.Email_Subscription
		result2 error
	}
	GetAllPermissionStub        func() ([]datatypes.User_Customer_CustomerPermission_Permission, error)
	getAllPermissionMutex       sync.RWMutex
	getAllPermissionArgsForCall []struct {
	}
	getAllPermissionReturns struct {
		result1 []datatypes.User_Customer_CustomerPermission_Permission
		result2 error
	}
	getAllPermissionReturnsOnCall map[int]struct {
		result1 []datatypes.User_Customer_CustomerPermission_Permission
		result2 error
	}
	GetCurrentUserStub        func() (datatypes.User_Customer, error)
	getCurrentUserMutex       sync.RWMutex
	getCurrentUserArgsForCall []struct {
	}
	getCurrentUserReturns struct {
		result1 datatypes.User_Customer
		result2 error
	}
	getCurrentUserReturnsOnCall map[int]struct {
		result1 datatypes.User_Customer
		result2 error
	}
	GetEventsStub        func(int, time.Time) ([]datatypes.Event_Log, error)
	getEventsMutex       sync.RWMutex
	getEventsArgsForCall []struct {
		arg1 int
		arg2 time.Time
	}
	getEventsReturns struct {
		result1 []datatypes.Event_Log
		result2 error
	}
	getEventsReturnsOnCall map[int]struct {
		result1 []datatypes.Event_Log
		result2 error
	}
	GetIdFromUsernameStub        func(string) (int, error)
	getIdFromUsernameMutex       sync.RWMutex
	getIdFromUsernameArgsForCall []struct {
		arg1 string
	}
	getIdFromUsernameReturns struct {
		result1 int
		result2 error
	}
	getIdFromUsernameReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	GetLoginsStub        func(int, time.Time) ([]datatypes.User_Customer_Access_Authentication, error)
	getLoginsMutex       sync.RWMutex
	getLoginsArgsForCall []struct {
		arg1 int
		arg2 time.Time
	}
	getLoginsReturns struct {
		result1 []datatypes.User_Customer_Access_Authentication
		result2 error
	}
	getLoginsReturnsOnCall map[int]struct {
		result1 []datatypes.User_Customer_Access_Authentication
		result2 error
	}
	GetUserStub        func(int, string) (datatypes.User_Customer, error)
	getUserMutex       sync.RWMutex
	getUserArgsForCall []struct {
		arg1 int
		arg2 string
	}
	getUserReturns struct {
		result1 datatypes.User_Customer
		result2 error
	}
	getUserReturnsOnCall map[int]struct {
		result1 datatypes.User_Customer
		result2 error
	}
	GetUserPermissionsStub        func(int) ([]datatypes.User_Customer_CustomerPermission_Permission, error)
	getUserPermissionsMutex       sync.RWMutex
	getUserPermissionsArgsForCall []struct {
		arg1 int
	}
	getUserPermissionsReturns struct {
		result1 []datatypes.User_Customer_CustomerPermission_Permission
		result2 error
	}
	getUserPermissionsReturnsOnCall map[int]struct {
		result1 []datatypes.User_Customer_CustomerPermission_Permission
		result2 error
	}
	ListUsersStub        func(string) ([]datatypes.User_Customer, error)
	listUsersMutex       sync.RWMutex
	listUsersArgsForCall []struct {
		arg1 string
	}
	listUsersReturns struct {
		result1 []datatypes.User_Customer
		result2 error
	}
	listUsersReturnsOnCall map[int]struct {
		result1 []datatypes.User_Customer
		result2 error
	}
	PermissionFromUserStub        func(int, int) error
	permissionFromUserMutex       sync.RWMutex
	permissionFromUserArgsForCall []struct {
		arg1 int
		arg2 int
	}
	permissionFromUserReturns struct {
		result1 error
	}
	permissionFromUserReturnsOnCall map[int]struct {
		result1 error
	}
	RemovePermissionStub        func(int, []datatypes.User_Customer_CustomerPermission_Permission) (bool, error)
	removePermissionMutex       sync.RWMutex
	removePermissionArgsForCall []struct {
		arg1 int
		arg2 []datatypes.User_Customer_CustomerPermission_Permission
	}
	removePermissionReturns struct {
		result1 bool
		result2 error
	}
	removePermissionReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeUserManager) AddApiAuthenticationKey(arg1 int) (string, error) {
	fake.addApiAuthenticationKeyMutex.Lock()
	ret, specificReturn := fake.addApiAuthenticationKeyReturnsOnCall[len(fake.addApiAuthenticationKeyArgsForCall)]
	fake.addApiAuthenticationKeyArgsForCall = append(fake.addApiAuthenticationKeyArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.AddApiAuthenticationKeyStub
	fakeReturns := fake.addApiAuthenticationKeyReturns
	fake.recordInvocation("AddApiAuthenticationKey", []interface{}{arg1})
	fake.addApiAuthenticationKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) AddApiAuthenticationKeyCallCount() int {
	fake.addApiAuthenticationKeyMutex.RLock()
	defer fake.addApiAuthenticationKeyMutex.RUnlock()
	return len(fake.addApiAuthenticationKeyArgsForCall)
}

func (fake *FakeUserManager) AddApiAuthenticationKeyCalls(stub func(int) (string, error)) {
	fake.addApiAuthenticationKeyMutex.Lock()
	defer fake.addApiAuthenticationKeyMutex.Unlock()
	fake.AddApiAuthenticationKeyStub = stub
}

func (fake *FakeUserManager) AddApiAuthenticationKeyArgsForCall(i int) int {
	fake.addApiAuthenticationKeyMutex.RLock()
	defer fake.addApiAuthenticationKeyMutex.RUnlock()
	argsForCall := fake.addApiAuthenticationKeyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserManager) AddApiAuthenticationKeyReturns(result1 string, result2 error) {
	fake.addApiAuthenticationKeyMutex.Lock()
	defer fake.addApiAuthenticationKeyMutex.Unlock()
	fake.AddApiAuthenticationKeyStub = nil
	fake.addApiAuthenticationKeyReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) AddApiAuthenticationKeyReturnsOnCall(i int, result1 string, result2 error) {
	fake.addApiAuthenticationKeyMutex.Lock()
	defer fake.addApiAuthenticationKeyMutex.Unlock()
	fake.AddApiAuthenticationKeyStub = nil
	if fake.addApiAuthenticationKeyReturnsOnCall == nil {
		fake.addApiAuthenticationKeyReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.addApiAuthenticationKeyReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) AddPermission(arg1 int, arg2 []datatypes.User_Customer_CustomerPermission_Permission) (bool, error) {
	var arg2Copy []datatypes.User_Customer_CustomerPermission_Permission
	if arg2 != nil {
		arg2Copy = make([]datatypes.User_Customer_CustomerPermission_Permission, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.addPermissionMutex.Lock()
	ret, specificReturn := fake.addPermissionReturnsOnCall[len(fake.addPermissionArgsForCall)]
	fake.addPermissionArgsForCall = append(fake.addPermissionArgsForCall, struct {
		arg1 int
		arg2 []datatypes.User_Customer_CustomerPermission_Permission
	}{arg1, arg2Copy})
	stub := fake.AddPermissionStub
	fakeReturns := fake.addPermissionReturns
	fake.recordInvocation("AddPermission", []interface{}{arg1, arg2Copy})
	fake.addPermissionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) AddPermissionCallCount() int {
	fake.addPermissionMutex.RLock()
	defer fake.addPermissionMutex.RUnlock()
	return len(fake.addPermissionArgsForCall)
}

func (fake *FakeUserManager) AddPermissionCalls(stub func(int, []datatypes.User_Customer_CustomerPermission_Permission) (bool, error)) {
	fake.addPermissionMutex.Lock()
	defer fake.addPermissionMutex.Unlock()
	fake.AddPermissionStub = stub
}

func (fake *FakeUserManager) AddPermissionArgsForCall(i int) (int, []datatypes.User_Customer_CustomerPermission_Permission) {
	fake.addPermissionMutex.RLock()
	defer fake.addPermissionMutex.RUnlock()
	argsForCall := fake.addPermissionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserManager) AddPermissionReturns(result1 bool, result2 error) {
	fake.addPermissionMutex.Lock()
	defer fake.addPermissionMutex.Unlock()
	fake.AddPermissionStub = nil
	fake.addPermissionReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) AddPermissionReturnsOnCall(i int, result1 bool, result2 error) {
	fake.addPermissionMutex.Lock()
	defer fake.addPermissionMutex.Unlock()
	fake.AddPermissionStub = nil
	if fake.addPermissionReturnsOnCall == nil {
		fake.addPermissionReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.addPermissionReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) CreateUser(arg1 datatypes.User_Customer, arg2 string, arg3 string) (datatypes.User_Customer, error) {
	fake.createUserMutex.Lock()
	ret, specificReturn := fake.createUserReturnsOnCall[len(fake.createUserArgsForCall)]
	fake.createUserArgsForCall = append(fake.createUserArgsForCall, struct {
		arg1 datatypes.User_Customer
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.CreateUserStub
	fakeReturns := fake.createUserReturns
	fake.recordInvocation("CreateUser", []interface{}{arg1, arg2, arg3})
	fake.createUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) CreateUserCallCount() int {
	fake.createUserMutex.RLock()
	defer fake.createUserMutex.RUnlock()
	return len(fake.createUserArgsForCall)
}

func (fake *FakeUserManager) CreateUserCalls(stub func(datatypes.User_Customer, string, string) (datatypes.User_Customer, error)) {
	fake.createUserMutex.Lock()
	defer fake.createUserMutex.Unlock()
	fake.CreateUserStub = stub
}

func (fake *FakeUserManager) CreateUserArgsForCall(i int) (datatypes.User_Customer, string, string) {
	fake.createUserMutex.RLock()
	defer fake.createUserMutex.RUnlock()
	argsForCall := fake.createUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUserManager) CreateUserReturns(result1 datatypes.User_Customer, result2 error) {
	fake.createUserMutex.Lock()
	defer fake.createUserMutex.Unlock()
	fake.CreateUserStub = nil
	fake.createUserReturns = struct {
		result1 datatypes.User_Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) CreateUserReturnsOnCall(i int, result1 datatypes.User_Customer, result2 error) {
	fake.createUserMutex.Lock()
	defer fake.createUserMutex.Unlock()
	fake.CreateUserStub = nil
	if fake.createUserReturnsOnCall == nil {
		fake.createUserReturnsOnCall = make(map[int]struct {
			result1 datatypes.User_Customer
			result2 error
		})
	}
	fake.createUserReturnsOnCall[i] = struct {
		result1 datatypes.User_Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) EditUser(arg1 datatypes.User_Customer, arg2 int) (bool, error) {
	fake.editUserMutex.Lock()
	ret, specificReturn := fake.editUserReturnsOnCall[len(fake.editUserArgsForCall)]
	fake.editUserArgsForCall = append(fake.editUserArgsForCall, struct {
		arg1 datatypes.User_Customer
		arg2 int
	}{arg1, arg2})
	stub := fake.EditUserStub
	fakeReturns := fake.editUserReturns
	fake.recordInvocation("EditUser", []interface{}{arg1, arg2})
	fake.editUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) EditUserCallCount() int {
	fake.editUserMutex.RLock()
	defer fake.editUserMutex.RUnlock()
	return len(fake.editUserArgsForCall)
}

func (fake *FakeUserManager) EditUserCalls(stub func(datatypes.User_Customer, int) (bool, error)) {
	fake.editUserMutex.Lock()
	defer fake.editUserMutex.Unlock()
	fake.EditUserStub = stub
}

func (fake *FakeUserManager) EditUserArgsForCall(i int) (datatypes.User_Customer, int) {
	fake.editUserMutex.RLock()
	defer fake.editUserMutex.RUnlock()
	argsForCall := fake.editUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserManager) EditUserReturns(result1 bool, result2 error) {
	fake.editUserMutex.Lock()
	defer fake.editUserMutex.Unlock()
	fake.EditUserStub = nil
	fake.editUserReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) EditUserReturnsOnCall(i int, result1 bool, result2 error) {
	fake.editUserMutex.Lock()
	defer fake.editUserMutex.Unlock()
	fake.EditUserStub = nil
	if fake.editUserReturnsOnCall == nil {
		fake.editUserReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.editUserReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) FormatPermissionObject(arg1 []string) ([]datatypes.User_Customer_CustomerPermission_Permission, error) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.formatPermissionObjectMutex.Lock()
	ret, specificReturn := fake.formatPermissionObjectReturnsOnCall[len(fake.formatPermissionObjectArgsForCall)]
	fake.formatPermissionObjectArgsForCall = append(fake.formatPermissionObjectArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	stub := fake.FormatPermissionObjectStub
	fakeReturns := fake.formatPermissionObjectReturns
	fake.recordInvocation("FormatPermissionObject", []interface{}{arg1Copy})
	fake.formatPermissionObjectMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) FormatPermissionObjectCallCount() int {
	fake.formatPermissionObjectMutex.RLock()
	defer fake.formatPermissionObjectMutex.RUnlock()
	return len(fake.formatPermissionObjectArgsForCall)
}

func (fake *FakeUserManager) FormatPermissionObjectCalls(stub func([]string) ([]datatypes.User_Customer_CustomerPermission_Permission, error)) {
	fake.formatPermissionObjectMutex.Lock()
	defer fake.formatPermissionObjectMutex.Unlock()
	fake.FormatPermissionObjectStub = stub
}

func (fake *FakeUserManager) FormatPermissionObjectArgsForCall(i int) []string {
	fake.formatPermissionObjectMutex.RLock()
	defer fake.formatPermissionObjectMutex.RUnlock()
	argsForCall := fake.formatPermissionObjectArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserManager) FormatPermissionObjectReturns(result1 []datatypes.User_Customer_CustomerPermission_Permission, result2 error) {
	fake.formatPermissionObjectMutex.Lock()
	defer fake.formatPermissionObjectMutex.Unlock()
	fake.FormatPermissionObjectStub = nil
	fake.formatPermissionObjectReturns = struct {
		result1 []datatypes.User_Customer_CustomerPermission_Permission
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) FormatPermissionObjectReturnsOnCall(i int, result1 []datatypes.User_Customer_CustomerPermission_Permission, result2 error) {
	fake.formatPermissionObjectMutex.Lock()
	defer fake.formatPermissionObjectMutex.Unlock()
	fake.FormatPermissionObjectStub = nil
	if fake.formatPermissionObjectReturnsOnCall == nil {
		fake.formatPermissionObjectReturnsOnCall = make(map[int]struct {
			result1 []datatypes.User_Customer_CustomerPermission_Permission
			result2 error
		})
	}
	fake.formatPermissionObjectReturnsOnCall[i] = struct {
		result1 []datatypes.User_Customer_CustomerPermission_Permission
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetAllNotifications(arg1 string) ([]datatypes.Email_Subscription, error) {
	fake.getAllNotificationsMutex.Lock()
	ret, specificReturn := fake.getAllNotificationsReturnsOnCall[len(fake.getAllNotificationsArgsForCall)]
	fake.getAllNotificationsArgsForCall = append(fake.getAllNotificationsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetAllNotificationsStub
	fakeReturns := fake.getAllNotificationsReturns
	fake.recordInvocation("GetAllNotifications", []interface{}{arg1})
	fake.getAllNotificationsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) GetAllNotificationsCallCount() int {
	fake.getAllNotificationsMutex.RLock()
	defer fake.getAllNotificationsMutex.RUnlock()
	return len(fake.getAllNotificationsArgsForCall)
}

func (fake *FakeUserManager) GetAllNotificationsCalls(stub func(string) ([]datatypes.Email_Subscription, error)) {
	fake.getAllNotificationsMutex.Lock()
	defer fake.getAllNotificationsMutex.Unlock()
	fake.GetAllNotificationsStub = stub
}

func (fake *FakeUserManager) GetAllNotificationsArgsForCall(i int) string {
	fake.getAllNotificationsMutex.RLock()
	defer fake.getAllNotificationsMutex.RUnlock()
	argsForCall := fake.getAllNotificationsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserManager) GetAllNotificationsReturns(result1 []datatypes.Email_Subscription, result2 error) {
	fake.getAllNotificationsMutex.Lock()
	defer fake.getAllNotificationsMutex.Unlock()
	fake.GetAllNotificationsStub = nil
	fake.getAllNotificationsReturns = struct {
		result1 []datatypes.Email_Subscription
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetAllNotificationsReturnsOnCall(i int, result1 []datatypes.Email_Subscription, result2 error) {
	fake.getAllNotificationsMutex.Lock()
	defer fake.getAllNotificationsMutex.Unlock()
	fake.GetAllNotificationsStub = nil
	if fake.getAllNotificationsReturnsOnCall == nil {
		fake.getAllNotificationsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Email_Subscription
			result2 error
		})
	}
	fake.getAllNotificationsReturnsOnCall[i] = struct {
		result1 []datatypes.Email_Subscription
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetAllPermission() ([]datatypes.User_Customer_CustomerPermission_Permission, error) {
	fake.getAllPermissionMutex.Lock()
	ret, specificReturn := fake.getAllPermissionReturnsOnCall[len(fake.getAllPermissionArgsForCall)]
	fake.getAllPermissionArgsForCall = append(fake.getAllPermissionArgsForCall, struct {
	}{})
	stub := fake.GetAllPermissionStub
	fakeReturns := fake.getAllPermissionReturns
	fake.recordInvocation("GetAllPermission", []interface{}{})
	fake.getAllPermissionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) GetAllPermissionCallCount() int {
	fake.getAllPermissionMutex.RLock()
	defer fake.getAllPermissionMutex.RUnlock()
	return len(fake.getAllPermissionArgsForCall)
}

func (fake *FakeUserManager) GetAllPermissionCalls(stub func() ([]datatypes.User_Customer_CustomerPermission_Permission, error)) {
	fake.getAllPermissionMutex.Lock()
	defer fake.getAllPermissionMutex.Unlock()
	fake.GetAllPermissionStub = stub
}

func (fake *FakeUserManager) GetAllPermissionReturns(result1 []datatypes.User_Customer_CustomerPermission_Permission, result2 error) {
	fake.getAllPermissionMutex.Lock()
	defer fake.getAllPermissionMutex.Unlock()
	fake.GetAllPermissionStub = nil
	fake.getAllPermissionReturns = struct {
		result1 []datatypes.User_Customer_CustomerPermission_Permission
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetAllPermissionReturnsOnCall(i int, result1 []datatypes.User_Customer_CustomerPermission_Permission, result2 error) {
	fake.getAllPermissionMutex.Lock()
	defer fake.getAllPermissionMutex.Unlock()
	fake.GetAllPermissionStub = nil
	if fake.getAllPermissionReturnsOnCall == nil {
		fake.getAllPermissionReturnsOnCall = make(map[int]struct {
			result1 []datatypes.User_Customer_CustomerPermission_Permission
			result2 error
		})
	}
	fake.getAllPermissionReturnsOnCall[i] = struct {
		result1 []datatypes.User_Customer_CustomerPermission_Permission
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetCurrentUser() (datatypes.User_Customer, error) {
	fake.getCurrentUserMutex.Lock()
	ret, specificReturn := fake.getCurrentUserReturnsOnCall[len(fake.getCurrentUserArgsForCall)]
	fake.getCurrentUserArgsForCall = append(fake.getCurrentUserArgsForCall, struct {
	}{})
	stub := fake.GetCurrentUserStub
	fakeReturns := fake.getCurrentUserReturns
	fake.recordInvocation("GetCurrentUser", []interface{}{})
	fake.getCurrentUserMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) GetCurrentUserCallCount() int {
	fake.getCurrentUserMutex.RLock()
	defer fake.getCurrentUserMutex.RUnlock()
	return len(fake.getCurrentUserArgsForCall)
}

func (fake *FakeUserManager) GetCurrentUserCalls(stub func() (datatypes.User_Customer, error)) {
	fake.getCurrentUserMutex.Lock()
	defer fake.getCurrentUserMutex.Unlock()
	fake.GetCurrentUserStub = stub
}

func (fake *FakeUserManager) GetCurrentUserReturns(result1 datatypes.User_Customer, result2 error) {
	fake.getCurrentUserMutex.Lock()
	defer fake.getCurrentUserMutex.Unlock()
	fake.GetCurrentUserStub = nil
	fake.getCurrentUserReturns = struct {
		result1 datatypes.User_Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetCurrentUserReturnsOnCall(i int, result1 datatypes.User_Customer, result2 error) {
	fake.getCurrentUserMutex.Lock()
	defer fake.getCurrentUserMutex.Unlock()
	fake.GetCurrentUserStub = nil
	if fake.getCurrentUserReturnsOnCall == nil {
		fake.getCurrentUserReturnsOnCall = make(map[int]struct {
			result1 datatypes.User_Customer
			result2 error
		})
	}
	fake.getCurrentUserReturnsOnCall[i] = struct {
		result1 datatypes.User_Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetEvents(arg1 int, arg2 time.Time) ([]datatypes.Event_Log, error) {
	fake.getEventsMutex.Lock()
	ret, specificReturn := fake.getEventsReturnsOnCall[len(fake.getEventsArgsForCall)]
	fake.getEventsArgsForCall = append(fake.getEventsArgsForCall, struct {
		arg1 int
		arg2 time.Time
	}{arg1, arg2})
	stub := fake.GetEventsStub
	fakeReturns := fake.getEventsReturns
	fake.recordInvocation("GetEvents", []interface{}{arg1, arg2})
	fake.getEventsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) GetEventsCallCount() int {
	fake.getEventsMutex.RLock()
	defer fake.getEventsMutex.RUnlock()
	return len(fake.getEventsArgsForCall)
}

func (fake *FakeUserManager) GetEventsCalls(stub func(int, time.Time) ([]datatypes.Event_Log, error)) {
	fake.getEventsMutex.Lock()
	defer fake.getEventsMutex.Unlock()
	fake.GetEventsStub = stub
}

func (fake *FakeUserManager) GetEventsArgsForCall(i int) (int, time.Time) {
	fake.getEventsMutex.RLock()
	defer fake.getEventsMutex.RUnlock()
	argsForCall := fake.getEventsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserManager) GetEventsReturns(result1 []datatypes.Event_Log, result2 error) {
	fake.getEventsMutex.Lock()
	defer fake.getEventsMutex.Unlock()
	fake.GetEventsStub = nil
	fake.getEventsReturns = struct {
		result1 []datatypes.Event_Log
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetEventsReturnsOnCall(i int, result1 []datatypes.Event_Log, result2 error) {
	fake.getEventsMutex.Lock()
	defer fake.getEventsMutex.Unlock()
	fake.GetEventsStub = nil
	if fake.getEventsReturnsOnCall == nil {
		fake.getEventsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Event_Log
			result2 error
		})
	}
	fake.getEventsReturnsOnCall[i] = struct {
		result1 []datatypes.Event_Log
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetIdFromUsername(arg1 string) (int, error) {
	fake.getIdFromUsernameMutex.Lock()
	ret, specificReturn := fake.getIdFromUsernameReturnsOnCall[len(fake.getIdFromUsernameArgsForCall)]
	fake.getIdFromUsernameArgsForCall = append(fake.getIdFromUsernameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetIdFromUsernameStub
	fakeReturns := fake.getIdFromUsernameReturns
	fake.recordInvocation("GetIdFromUsername", []interface{}{arg1})
	fake.getIdFromUsernameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) GetIdFromUsernameCallCount() int {
	fake.getIdFromUsernameMutex.RLock()
	defer fake.getIdFromUsernameMutex.RUnlock()
	return len(fake.getIdFromUsernameArgsForCall)
}

func (fake *FakeUserManager) GetIdFromUsernameCalls(stub func(string) (int, error)) {
	fake.getIdFromUsernameMutex.Lock()
	defer fake.getIdFromUsernameMutex.Unlock()
	fake.GetIdFromUsernameStub = stub
}

func (fake *FakeUserManager) GetIdFromUsernameArgsForCall(i int) string {
	fake.getIdFromUsernameMutex.RLock()
	defer fake.getIdFromUsernameMutex.RUnlock()
	argsForCall := fake.getIdFromUsernameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserManager) GetIdFromUsernameReturns(result1 int, result2 error) {
	fake.getIdFromUsernameMutex.Lock()
	defer fake.getIdFromUsernameMutex.Unlock()
	fake.GetIdFromUsernameStub = nil
	fake.getIdFromUsernameReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetIdFromUsernameReturnsOnCall(i int, result1 int, result2 error) {
	fake.getIdFromUsernameMutex.Lock()
	defer fake.getIdFromUsernameMutex.Unlock()
	fake.GetIdFromUsernameStub = nil
	if fake.getIdFromUsernameReturnsOnCall == nil {
		fake.getIdFromUsernameReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.getIdFromUsernameReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetLogins(arg1 int, arg2 time.Time) ([]datatypes.User_Customer_Access_Authentication, error) {
	fake.getLoginsMutex.Lock()
	ret, specificReturn := fake.getLoginsReturnsOnCall[len(fake.getLoginsArgsForCall)]
	fake.getLoginsArgsForCall = append(fake.getLoginsArgsForCall, struct {
		arg1 int
		arg2 time.Time
	}{arg1, arg2})
	stub := fake.GetLoginsStub
	fakeReturns := fake.getLoginsReturns
	fake.recordInvocation("GetLogins", []interface{}{arg1, arg2})
	fake.getLoginsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) GetLoginsCallCount() int {
	fake.getLoginsMutex.RLock()
	defer fake.getLoginsMutex.RUnlock()
	return len(fake.getLoginsArgsForCall)
}

func (fake *FakeUserManager) GetLoginsCalls(stub func(int, time.Time) ([]datatypes.User_Customer_Access_Authentication, error)) {
	fake.getLoginsMutex.Lock()
	defer fake.getLoginsMutex.Unlock()
	fake.GetLoginsStub = stub
}

func (fake *FakeUserManager) GetLoginsArgsForCall(i int) (int, time.Time) {
	fake.getLoginsMutex.RLock()
	defer fake.getLoginsMutex.RUnlock()
	argsForCall := fake.getLoginsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserManager) GetLoginsReturns(result1 []datatypes.User_Customer_Access_Authentication, result2 error) {
	fake.getLoginsMutex.Lock()
	defer fake.getLoginsMutex.Unlock()
	fake.GetLoginsStub = nil
	fake.getLoginsReturns = struct {
		result1 []datatypes.User_Customer_Access_Authentication
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetLoginsReturnsOnCall(i int, result1 []datatypes.User_Customer_Access_Authentication, result2 error) {
	fake.getLoginsMutex.Lock()
	defer fake.getLoginsMutex.Unlock()
	fake.GetLoginsStub = nil
	if fake.getLoginsReturnsOnCall == nil {
		fake.getLoginsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.User_Customer_Access_Authentication
			result2 error
		})
	}
	fake.getLoginsReturnsOnCall[i] = struct {
		result1 []datatypes.User_Customer_Access_Authentication
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetUser(arg1 int, arg2 string) (datatypes.User_Customer, error) {
	fake.getUserMutex.Lock()
	ret, specificReturn := fake.getUserReturnsOnCall[len(fake.getUserArgsForCall)]
	fake.getUserArgsForCall = append(fake.getUserArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.GetUserStub
	fakeReturns := fake.getUserReturns
	fake.recordInvocation("GetUser", []interface{}{arg1, arg2})
	fake.getUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) GetUserCallCount() int {
	fake.getUserMutex.RLock()
	defer fake.getUserMutex.RUnlock()
	return len(fake.getUserArgsForCall)
}

func (fake *FakeUserManager) GetUserCalls(stub func(int, string) (datatypes.User_Customer, error)) {
	fake.getUserMutex.Lock()
	defer fake.getUserMutex.Unlock()
	fake.GetUserStub = stub
}

func (fake *FakeUserManager) GetUserArgsForCall(i int) (int, string) {
	fake.getUserMutex.RLock()
	defer fake.getUserMutex.RUnlock()
	argsForCall := fake.getUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserManager) GetUserReturns(result1 datatypes.User_Customer, result2 error) {
	fake.getUserMutex.Lock()
	defer fake.getUserMutex.Unlock()
	fake.GetUserStub = nil
	fake.getUserReturns = struct {
		result1 datatypes.User_Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetUserReturnsOnCall(i int, result1 datatypes.User_Customer, result2 error) {
	fake.getUserMutex.Lock()
	defer fake.getUserMutex.Unlock()
	fake.GetUserStub = nil
	if fake.getUserReturnsOnCall == nil {
		fake.getUserReturnsOnCall = make(map[int]struct {
			result1 datatypes.User_Customer
			result2 error
		})
	}
	fake.getUserReturnsOnCall[i] = struct {
		result1 datatypes.User_Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetUserPermissions(arg1 int) ([]datatypes.User_Customer_CustomerPermission_Permission, error) {
	fake.getUserPermissionsMutex.Lock()
	ret, specificReturn := fake.getUserPermissionsReturnsOnCall[len(fake.getUserPermissionsArgsForCall)]
	fake.getUserPermissionsArgsForCall = append(fake.getUserPermissionsArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.GetUserPermissionsStub
	fakeReturns := fake.getUserPermissionsReturns
	fake.recordInvocation("GetUserPermissions", []interface{}{arg1})
	fake.getUserPermissionsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) GetUserPermissionsCallCount() int {
	fake.getUserPermissionsMutex.RLock()
	defer fake.getUserPermissionsMutex.RUnlock()
	return len(fake.getUserPermissionsArgsForCall)
}

func (fake *FakeUserManager) GetUserPermissionsCalls(stub func(int) ([]datatypes.User_Customer_CustomerPermission_Permission, error)) {
	fake.getUserPermissionsMutex.Lock()
	defer fake.getUserPermissionsMutex.Unlock()
	fake.GetUserPermissionsStub = stub
}

func (fake *FakeUserManager) GetUserPermissionsArgsForCall(i int) int {
	fake.getUserPermissionsMutex.RLock()
	defer fake.getUserPermissionsMutex.RUnlock()
	argsForCall := fake.getUserPermissionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserManager) GetUserPermissionsReturns(result1 []datatypes.User_Customer_CustomerPermission_Permission, result2 error) {
	fake.getUserPermissionsMutex.Lock()
	defer fake.getUserPermissionsMutex.Unlock()
	fake.GetUserPermissionsStub = nil
	fake.getUserPermissionsReturns = struct {
		result1 []datatypes.User_Customer_CustomerPermission_Permission
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) GetUserPermissionsReturnsOnCall(i int, result1 []datatypes.User_Customer_CustomerPermission_Permission, result2 error) {
	fake.getUserPermissionsMutex.Lock()
	defer fake.getUserPermissionsMutex.Unlock()
	fake.GetUserPermissionsStub = nil
	if fake.getUserPermissionsReturnsOnCall == nil {
		fake.getUserPermissionsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.User_Customer_CustomerPermission_Permission
			result2 error
		})
	}
	fake.getUserPermissionsReturnsOnCall[i] = struct {
		result1 []datatypes.User_Customer_CustomerPermission_Permission
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) ListUsers(arg1 string) ([]datatypes.User_Customer, error) {
	fake.listUsersMutex.Lock()
	ret, specificReturn := fake.listUsersReturnsOnCall[len(fake.listUsersArgsForCall)]
	fake.listUsersArgsForCall = append(fake.listUsersArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ListUsersStub
	fakeReturns := fake.listUsersReturns
	fake.recordInvocation("ListUsers", []interface{}{arg1})
	fake.listUsersMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) ListUsersCallCount() int {
	fake.listUsersMutex.RLock()
	defer fake.listUsersMutex.RUnlock()
	return len(fake.listUsersArgsForCall)
}

func (fake *FakeUserManager) ListUsersCalls(stub func(string) ([]datatypes.User_Customer, error)) {
	fake.listUsersMutex.Lock()
	defer fake.listUsersMutex.Unlock()
	fake.ListUsersStub = stub
}

func (fake *FakeUserManager) ListUsersArgsForCall(i int) string {
	fake.listUsersMutex.RLock()
	defer fake.listUsersMutex.RUnlock()
	argsForCall := fake.listUsersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserManager) ListUsersReturns(result1 []datatypes.User_Customer, result2 error) {
	fake.listUsersMutex.Lock()
	defer fake.listUsersMutex.Unlock()
	fake.ListUsersStub = nil
	fake.listUsersReturns = struct {
		result1 []datatypes.User_Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) ListUsersReturnsOnCall(i int, result1 []datatypes.User_Customer, result2 error) {
	fake.listUsersMutex.Lock()
	defer fake.listUsersMutex.Unlock()
	fake.ListUsersStub = nil
	if fake.listUsersReturnsOnCall == nil {
		fake.listUsersReturnsOnCall = make(map[int]struct {
			result1 []datatypes.User_Customer
			result2 error
		})
	}
	fake.listUsersReturnsOnCall[i] = struct {
		result1 []datatypes.User_Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) PermissionFromUser(arg1 int, arg2 int) error {
	fake.permissionFromUserMutex.Lock()
	ret, specificReturn := fake.permissionFromUserReturnsOnCall[len(fake.permissionFromUserArgsForCall)]
	fake.permissionFromUserArgsForCall = append(fake.permissionFromUserArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.PermissionFromUserStub
	fakeReturns := fake.permissionFromUserReturns
	fake.recordInvocation("PermissionFromUser", []interface{}{arg1, arg2})
	fake.permissionFromUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUserManager) PermissionFromUserCallCount() int {
	fake.permissionFromUserMutex.RLock()
	defer fake.permissionFromUserMutex.RUnlock()
	return len(fake.permissionFromUserArgsForCall)
}

func (fake *FakeUserManager) PermissionFromUserCalls(stub func(int, int) error) {
	fake.permissionFromUserMutex.Lock()
	defer fake.permissionFromUserMutex.Unlock()
	fake.PermissionFromUserStub = stub
}

func (fake *FakeUserManager) PermissionFromUserArgsForCall(i int) (int, int) {
	fake.permissionFromUserMutex.RLock()
	defer fake.permissionFromUserMutex.RUnlock()
	argsForCall := fake.permissionFromUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserManager) PermissionFromUserReturns(result1 error) {
	fake.permissionFromUserMutex.Lock()
	defer fake.permissionFromUserMutex.Unlock()
	fake.PermissionFromUserStub = nil
	fake.permissionFromUserReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserManager) PermissionFromUserReturnsOnCall(i int, result1 error) {
	fake.permissionFromUserMutex.Lock()
	defer fake.permissionFromUserMutex.Unlock()
	fake.PermissionFromUserStub = nil
	if fake.permissionFromUserReturnsOnCall == nil {
		fake.permissionFromUserReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.permissionFromUserReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserManager) RemovePermission(arg1 int, arg2 []datatypes.User_Customer_CustomerPermission_Permission) (bool, error) {
	var arg2Copy []datatypes.User_Customer_CustomerPermission_Permission
	if arg2 != nil {
		arg2Copy = make([]datatypes.User_Customer_CustomerPermission_Permission, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.removePermissionMutex.Lock()
	ret, specificReturn := fake.removePermissionReturnsOnCall[len(fake.removePermissionArgsForCall)]
	fake.removePermissionArgsForCall = append(fake.removePermissionArgsForCall, struct {
		arg1 int
		arg2 []datatypes.User_Customer_CustomerPermission_Permission
	}{arg1, arg2Copy})
	stub := fake.RemovePermissionStub
	fakeReturns := fake.removePermissionReturns
	fake.recordInvocation("RemovePermission", []interface{}{arg1, arg2Copy})
	fake.removePermissionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserManager) RemovePermissionCallCount() int {
	fake.removePermissionMutex.RLock()
	defer fake.removePermissionMutex.RUnlock()
	return len(fake.removePermissionArgsForCall)
}

func (fake *FakeUserManager) RemovePermissionCalls(stub func(int, []datatypes.User_Customer_CustomerPermission_Permission) (bool, error)) {
	fake.removePermissionMutex.Lock()
	defer fake.removePermissionMutex.Unlock()
	fake.RemovePermissionStub = stub
}

func (fake *FakeUserManager) RemovePermissionArgsForCall(i int) (int, []datatypes.User_Customer_CustomerPermission_Permission) {
	fake.removePermissionMutex.RLock()
	defer fake.removePermissionMutex.RUnlock()
	argsForCall := fake.removePermissionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserManager) RemovePermissionReturns(result1 bool, result2 error) {
	fake.removePermissionMutex.Lock()
	defer fake.removePermissionMutex.Unlock()
	fake.RemovePermissionStub = nil
	fake.removePermissionReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) RemovePermissionReturnsOnCall(i int, result1 bool, result2 error) {
	fake.removePermissionMutex.Lock()
	defer fake.removePermissionMutex.Unlock()
	fake.RemovePermissionStub = nil
	if fake.removePermissionReturnsOnCall == nil {
		fake.removePermissionReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.removePermissionReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addApiAuthenticationKeyMutex.RLock()
	defer fake.addApiAuthenticationKeyMutex.RUnlock()
	fake.addPermissionMutex.RLock()
	defer fake.addPermissionMutex.RUnlock()
	fake.createUserMutex.RLock()
	defer fake.createUserMutex.RUnlock()
	fake.editUserMutex.RLock()
	defer fake.editUserMutex.RUnlock()
	fake.formatPermissionObjectMutex.RLock()
	defer fake.formatPermissionObjectMutex.RUnlock()
	fake.getAllNotificationsMutex.RLock()
	defer fake.getAllNotificationsMutex.RUnlock()
	fake.getAllPermissionMutex.RLock()
	defer fake.getAllPermissionMutex.RUnlock()
	fake.getCurrentUserMutex.RLock()
	defer fake.getCurrentUserMutex.RUnlock()
	fake.getEventsMutex.RLock()
	defer fake.getEventsMutex.RUnlock()
	fake.getIdFromUsernameMutex.RLock()
	defer fake.getIdFromUsernameMutex.RUnlock()
	fake.getLoginsMutex.RLock()
	defer fake.getLoginsMutex.RUnlock()
	fake.getUserMutex.RLock()
	defer fake.getUserMutex.RUnlock()
	fake.getUserPermissionsMutex.RLock()
	defer fake.getUserPermissionsMutex.RUnlock()
	fake.listUsersMutex.RLock()
	defer fake.listUsersMutex.RUnlock()
	fake.permissionFromUserMutex.RLock()
	defer fake.permissionFromUserMutex.RUnlock()
	fake.removePermissionMutex.RLock()
	defer fake.removePermissionMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeUserManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ managers.UserManager = new(FakeUserManager)
