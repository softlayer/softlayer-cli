// Code generated by counterfeiter. DO NOT EDIT.
package testhelpers

import (
	"sync"

	"github.com/softlayer/softlayer-go/datatypes"
	"github.ibm.com/SoftLayer/softlayer-cli/plugin/managers"
)

type FakePlaceGroupManager struct {
	CreateStub        func(*datatypes.Virtual_PlacementGroup) (datatypes.Virtual_PlacementGroup, error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 *datatypes.Virtual_PlacementGroup
	}
	createReturns struct {
		result1 datatypes.Virtual_PlacementGroup
		result2 error
	}
	createReturnsOnCall map[int]struct {
		result1 datatypes.Virtual_PlacementGroup
		result2 error
	}
	DeleteStub        func(int) (bool, error)
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 int
	}
	deleteReturns struct {
		result1 bool
		result2 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	GetBackendRouterFromHostNameStub        func() ([]datatypes.Network_Pod, error)
	getBackendRouterFromHostNameMutex       sync.RWMutex
	getBackendRouterFromHostNameArgsForCall []struct {
	}
	getBackendRouterFromHostNameReturns struct {
		result1 []datatypes.Network_Pod
		result2 error
	}
	getBackendRouterFromHostNameReturnsOnCall map[int]struct {
		result1 []datatypes.Network_Pod
		result2 error
	}
	GetObjectStub        func(int, string) (datatypes.Virtual_PlacementGroup, error)
	getObjectMutex       sync.RWMutex
	getObjectArgsForCall []struct {
		arg1 int
		arg2 string
	}
	getObjectReturns struct {
		result1 datatypes.Virtual_PlacementGroup
		result2 error
	}
	getObjectReturnsOnCall map[int]struct {
		result1 datatypes.Virtual_PlacementGroup
		result2 error
	}
	GetRouterStub        func(*int, string) ([]datatypes.Hardware, error)
	getRouterMutex       sync.RWMutex
	getRouterArgsForCall []struct {
		arg1 *int
		arg2 string
	}
	getRouterReturns struct {
		result1 []datatypes.Hardware
		result2 error
	}
	getRouterReturnsOnCall map[int]struct {
		result1 []datatypes.Hardware
		result2 error
	}
	GetRulesStub        func() ([]datatypes.Virtual_PlacementGroup_Rule, error)
	getRulesMutex       sync.RWMutex
	getRulesArgsForCall []struct {
	}
	getRulesReturns struct {
		result1 []datatypes.Virtual_PlacementGroup_Rule
		result2 error
	}
	getRulesReturnsOnCall map[int]struct {
		result1 []datatypes.Virtual_PlacementGroup_Rule
		result2 error
	}
	ListStub        func(string) ([]datatypes.Virtual_PlacementGroup, error)
	listMutex       sync.RWMutex
	listArgsForCall []struct {
		arg1 string
	}
	listReturns struct {
		result1 []datatypes.Virtual_PlacementGroup
		result2 error
	}
	listReturnsOnCall map[int]struct {
		result1 []datatypes.Virtual_PlacementGroup
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePlaceGroupManager) Create(arg1 *datatypes.Virtual_PlacementGroup) (datatypes.Virtual_PlacementGroup, error) {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 *datatypes.Virtual_PlacementGroup
	}{arg1})
	stub := fake.CreateStub
	fakeReturns := fake.createReturns
	fake.recordInvocation("Create", []interface{}{arg1})
	fake.createMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePlaceGroupManager) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakePlaceGroupManager) CreateCalls(stub func(*datatypes.Virtual_PlacementGroup) (datatypes.Virtual_PlacementGroup, error)) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = stub
}

func (fake *FakePlaceGroupManager) CreateArgsForCall(i int) *datatypes.Virtual_PlacementGroup {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	argsForCall := fake.createArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlaceGroupManager) CreateReturns(result1 datatypes.Virtual_PlacementGroup, result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 datatypes.Virtual_PlacementGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePlaceGroupManager) CreateReturnsOnCall(i int, result1 datatypes.Virtual_PlacementGroup, result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 datatypes.Virtual_PlacementGroup
			result2 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 datatypes.Virtual_PlacementGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePlaceGroupManager) Delete(arg1 int) (bool, error) {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.DeleteStub
	fakeReturns := fake.deleteReturns
	fake.recordInvocation("Delete", []interface{}{arg1})
	fake.deleteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePlaceGroupManager) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakePlaceGroupManager) DeleteCalls(stub func(int) (bool, error)) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakePlaceGroupManager) DeleteArgsForCall(i int) int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlaceGroupManager) DeleteReturns(result1 bool, result2 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePlaceGroupManager) DeleteReturnsOnCall(i int, result1 bool, result2 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePlaceGroupManager) GetBackendRouterFromHostName() ([]datatypes.Network_Pod, error) {
	fake.getBackendRouterFromHostNameMutex.Lock()
	ret, specificReturn := fake.getBackendRouterFromHostNameReturnsOnCall[len(fake.getBackendRouterFromHostNameArgsForCall)]
	fake.getBackendRouterFromHostNameArgsForCall = append(fake.getBackendRouterFromHostNameArgsForCall, struct {
	}{})
	stub := fake.GetBackendRouterFromHostNameStub
	fakeReturns := fake.getBackendRouterFromHostNameReturns
	fake.recordInvocation("GetBackendRouterFromHostName", []interface{}{})
	fake.getBackendRouterFromHostNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePlaceGroupManager) GetBackendRouterFromHostNameCallCount() int {
	fake.getBackendRouterFromHostNameMutex.RLock()
	defer fake.getBackendRouterFromHostNameMutex.RUnlock()
	return len(fake.getBackendRouterFromHostNameArgsForCall)
}

func (fake *FakePlaceGroupManager) GetBackendRouterFromHostNameCalls(stub func() ([]datatypes.Network_Pod, error)) {
	fake.getBackendRouterFromHostNameMutex.Lock()
	defer fake.getBackendRouterFromHostNameMutex.Unlock()
	fake.GetBackendRouterFromHostNameStub = stub
}

func (fake *FakePlaceGroupManager) GetBackendRouterFromHostNameReturns(result1 []datatypes.Network_Pod, result2 error) {
	fake.getBackendRouterFromHostNameMutex.Lock()
	defer fake.getBackendRouterFromHostNameMutex.Unlock()
	fake.GetBackendRouterFromHostNameStub = nil
	fake.getBackendRouterFromHostNameReturns = struct {
		result1 []datatypes.Network_Pod
		result2 error
	}{result1, result2}
}

func (fake *FakePlaceGroupManager) GetBackendRouterFromHostNameReturnsOnCall(i int, result1 []datatypes.Network_Pod, result2 error) {
	fake.getBackendRouterFromHostNameMutex.Lock()
	defer fake.getBackendRouterFromHostNameMutex.Unlock()
	fake.GetBackendRouterFromHostNameStub = nil
	if fake.getBackendRouterFromHostNameReturnsOnCall == nil {
		fake.getBackendRouterFromHostNameReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Network_Pod
			result2 error
		})
	}
	fake.getBackendRouterFromHostNameReturnsOnCall[i] = struct {
		result1 []datatypes.Network_Pod
		result2 error
	}{result1, result2}
}

func (fake *FakePlaceGroupManager) GetObject(arg1 int, arg2 string) (datatypes.Virtual_PlacementGroup, error) {
	fake.getObjectMutex.Lock()
	ret, specificReturn := fake.getObjectReturnsOnCall[len(fake.getObjectArgsForCall)]
	fake.getObjectArgsForCall = append(fake.getObjectArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.GetObjectStub
	fakeReturns := fake.getObjectReturns
	fake.recordInvocation("GetObject", []interface{}{arg1, arg2})
	fake.getObjectMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePlaceGroupManager) GetObjectCallCount() int {
	fake.getObjectMutex.RLock()
	defer fake.getObjectMutex.RUnlock()
	return len(fake.getObjectArgsForCall)
}

func (fake *FakePlaceGroupManager) GetObjectCalls(stub func(int, string) (datatypes.Virtual_PlacementGroup, error)) {
	fake.getObjectMutex.Lock()
	defer fake.getObjectMutex.Unlock()
	fake.GetObjectStub = stub
}

func (fake *FakePlaceGroupManager) GetObjectArgsForCall(i int) (int, string) {
	fake.getObjectMutex.RLock()
	defer fake.getObjectMutex.RUnlock()
	argsForCall := fake.getObjectArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePlaceGroupManager) GetObjectReturns(result1 datatypes.Virtual_PlacementGroup, result2 error) {
	fake.getObjectMutex.Lock()
	defer fake.getObjectMutex.Unlock()
	fake.GetObjectStub = nil
	fake.getObjectReturns = struct {
		result1 datatypes.Virtual_PlacementGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePlaceGroupManager) GetObjectReturnsOnCall(i int, result1 datatypes.Virtual_PlacementGroup, result2 error) {
	fake.getObjectMutex.Lock()
	defer fake.getObjectMutex.Unlock()
	fake.GetObjectStub = nil
	if fake.getObjectReturnsOnCall == nil {
		fake.getObjectReturnsOnCall = make(map[int]struct {
			result1 datatypes.Virtual_PlacementGroup
			result2 error
		})
	}
	fake.getObjectReturnsOnCall[i] = struct {
		result1 datatypes.Virtual_PlacementGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePlaceGroupManager) GetRouter(arg1 *int, arg2 string) ([]datatypes.Hardware, error) {
	fake.getRouterMutex.Lock()
	ret, specificReturn := fake.getRouterReturnsOnCall[len(fake.getRouterArgsForCall)]
	fake.getRouterArgsForCall = append(fake.getRouterArgsForCall, struct {
		arg1 *int
		arg2 string
	}{arg1, arg2})
	stub := fake.GetRouterStub
	fakeReturns := fake.getRouterReturns
	fake.recordInvocation("GetRouter", []interface{}{arg1, arg2})
	fake.getRouterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePlaceGroupManager) GetRouterCallCount() int {
	fake.getRouterMutex.RLock()
	defer fake.getRouterMutex.RUnlock()
	return len(fake.getRouterArgsForCall)
}

func (fake *FakePlaceGroupManager) GetRouterCalls(stub func(*int, string) ([]datatypes.Hardware, error)) {
	fake.getRouterMutex.Lock()
	defer fake.getRouterMutex.Unlock()
	fake.GetRouterStub = stub
}

func (fake *FakePlaceGroupManager) GetRouterArgsForCall(i int) (*int, string) {
	fake.getRouterMutex.RLock()
	defer fake.getRouterMutex.RUnlock()
	argsForCall := fake.getRouterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePlaceGroupManager) GetRouterReturns(result1 []datatypes.Hardware, result2 error) {
	fake.getRouterMutex.Lock()
	defer fake.getRouterMutex.Unlock()
	fake.GetRouterStub = nil
	fake.getRouterReturns = struct {
		result1 []datatypes.Hardware
		result2 error
	}{result1, result2}
}

func (fake *FakePlaceGroupManager) GetRouterReturnsOnCall(i int, result1 []datatypes.Hardware, result2 error) {
	fake.getRouterMutex.Lock()
	defer fake.getRouterMutex.Unlock()
	fake.GetRouterStub = nil
	if fake.getRouterReturnsOnCall == nil {
		fake.getRouterReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Hardware
			result2 error
		})
	}
	fake.getRouterReturnsOnCall[i] = struct {
		result1 []datatypes.Hardware
		result2 error
	}{result1, result2}
}

func (fake *FakePlaceGroupManager) GetRules() ([]datatypes.Virtual_PlacementGroup_Rule, error) {
	fake.getRulesMutex.Lock()
	ret, specificReturn := fake.getRulesReturnsOnCall[len(fake.getRulesArgsForCall)]
	fake.getRulesArgsForCall = append(fake.getRulesArgsForCall, struct {
	}{})
	stub := fake.GetRulesStub
	fakeReturns := fake.getRulesReturns
	fake.recordInvocation("GetRules", []interface{}{})
	fake.getRulesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePlaceGroupManager) GetRulesCallCount() int {
	fake.getRulesMutex.RLock()
	defer fake.getRulesMutex.RUnlock()
	return len(fake.getRulesArgsForCall)
}

func (fake *FakePlaceGroupManager) GetRulesCalls(stub func() ([]datatypes.Virtual_PlacementGroup_Rule, error)) {
	fake.getRulesMutex.Lock()
	defer fake.getRulesMutex.Unlock()
	fake.GetRulesStub = stub
}

func (fake *FakePlaceGroupManager) GetRulesReturns(result1 []datatypes.Virtual_PlacementGroup_Rule, result2 error) {
	fake.getRulesMutex.Lock()
	defer fake.getRulesMutex.Unlock()
	fake.GetRulesStub = nil
	fake.getRulesReturns = struct {
		result1 []datatypes.Virtual_PlacementGroup_Rule
		result2 error
	}{result1, result2}
}

func (fake *FakePlaceGroupManager) GetRulesReturnsOnCall(i int, result1 []datatypes.Virtual_PlacementGroup_Rule, result2 error) {
	fake.getRulesMutex.Lock()
	defer fake.getRulesMutex.Unlock()
	fake.GetRulesStub = nil
	if fake.getRulesReturnsOnCall == nil {
		fake.getRulesReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Virtual_PlacementGroup_Rule
			result2 error
		})
	}
	fake.getRulesReturnsOnCall[i] = struct {
		result1 []datatypes.Virtual_PlacementGroup_Rule
		result2 error
	}{result1, result2}
}

func (fake *FakePlaceGroupManager) List(arg1 string) ([]datatypes.Virtual_PlacementGroup, error) {
	fake.listMutex.Lock()
	ret, specificReturn := fake.listReturnsOnCall[len(fake.listArgsForCall)]
	fake.listArgsForCall = append(fake.listArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ListStub
	fakeReturns := fake.listReturns
	fake.recordInvocation("List", []interface{}{arg1})
	fake.listMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePlaceGroupManager) ListCallCount() int {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return len(fake.listArgsForCall)
}

func (fake *FakePlaceGroupManager) ListCalls(stub func(string) ([]datatypes.Virtual_PlacementGroup, error)) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = stub
}

func (fake *FakePlaceGroupManager) ListArgsForCall(i int) string {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	argsForCall := fake.listArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlaceGroupManager) ListReturns(result1 []datatypes.Virtual_PlacementGroup, result2 error) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = nil
	fake.listReturns = struct {
		result1 []datatypes.Virtual_PlacementGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePlaceGroupManager) ListReturnsOnCall(i int, result1 []datatypes.Virtual_PlacementGroup, result2 error) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = nil
	if fake.listReturnsOnCall == nil {
		fake.listReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Virtual_PlacementGroup
			result2 error
		})
	}
	fake.listReturnsOnCall[i] = struct {
		result1 []datatypes.Virtual_PlacementGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePlaceGroupManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.getBackendRouterFromHostNameMutex.RLock()
	defer fake.getBackendRouterFromHostNameMutex.RUnlock()
	fake.getObjectMutex.RLock()
	defer fake.getObjectMutex.RUnlock()
	fake.getRouterMutex.RLock()
	defer fake.getRouterMutex.RUnlock()
	fake.getRulesMutex.RLock()
	defer fake.getRulesMutex.RUnlock()
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePlaceGroupManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ managers.PlaceGroupManager = new(FakePlaceGroupManager)
