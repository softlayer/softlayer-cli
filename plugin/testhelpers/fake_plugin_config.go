// This file was generated by counterfeiter
package testhelpers

import (
	"sync"

	"github.com/IBM-Cloud/ibm-cloud-cli-sdk/plugin"
)

type FakePluginConfig struct {
	GetStub        func(key string) interface{}
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		key string
	}
	getReturns struct {
		result1 interface{}
	}
	getReturnsOnCall map[int]struct {
		result1 interface{}
	}
	GetWithDefaultStub        func(key string, defaultVal interface{}) interface{}
	getWithDefaultMutex       sync.RWMutex
	getWithDefaultArgsForCall []struct {
		key        string
		defaultVal interface{}
	}
	getWithDefaultReturns struct {
		result1 interface{}
	}
	getWithDefaultReturnsOnCall map[int]struct {
		result1 interface{}
	}
	GetStringStub        func(key string) (string, error)
	getStringMutex       sync.RWMutex
	getStringArgsForCall []struct {
		key string
	}
	getStringReturns struct {
		result1 string
		result2 error
	}
	getStringReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetStringWithDefaultStub        func(key string, defaultVal string) (string, error)
	getStringWithDefaultMutex       sync.RWMutex
	getStringWithDefaultArgsForCall []struct {
		key        string
		defaultVal string
	}
	getStringWithDefaultReturns struct {
		result1 string
		result2 error
	}
	getStringWithDefaultReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetBoolStub        func(key string) (bool, error)
	getBoolMutex       sync.RWMutex
	getBoolArgsForCall []struct {
		key string
	}
	getBoolReturns struct {
		result1 bool
		result2 error
	}
	getBoolReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	GetBoolWithDefaultStub        func(key string, defaultVal bool) (bool, error)
	getBoolWithDefaultMutex       sync.RWMutex
	getBoolWithDefaultArgsForCall []struct {
		key        string
		defaultVal bool
	}
	getBoolWithDefaultReturns struct {
		result1 bool
		result2 error
	}
	getBoolWithDefaultReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	GetIntStub        func(key string) (int, error)
	getIntMutex       sync.RWMutex
	getIntArgsForCall []struct {
		key string
	}
	getIntReturns struct {
		result1 int
		result2 error
	}
	getIntReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	GetIntWithDefaultStub        func(key string, defaultVal int) (int, error)
	getIntWithDefaultMutex       sync.RWMutex
	getIntWithDefaultArgsForCall []struct {
		key        string
		defaultVal int
	}
	getIntWithDefaultReturns struct {
		result1 int
		result2 error
	}
	getIntWithDefaultReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	GetFloatStub        func(key string) (float64, error)
	getFloatMutex       sync.RWMutex
	getFloatArgsForCall []struct {
		key string
	}
	getFloatReturns struct {
		result1 float64
		result2 error
	}
	getFloatReturnsOnCall map[int]struct {
		result1 float64
		result2 error
	}
	GetFloatWithDefaultStub        func(key string, defaultVal float64) (float64, error)
	getFloatWithDefaultMutex       sync.RWMutex
	getFloatWithDefaultArgsForCall []struct {
		key        string
		defaultVal float64
	}
	getFloatWithDefaultReturns struct {
		result1 float64
		result2 error
	}
	getFloatWithDefaultReturnsOnCall map[int]struct {
		result1 float64
		result2 error
	}
	GetStringSliceStub        func(key string) ([]string, error)
	getStringSliceMutex       sync.RWMutex
	getStringSliceArgsForCall []struct {
		key string
	}
	getStringSliceReturns struct {
		result1 []string
		result2 error
	}
	getStringSliceReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	GetIntSliceStub        func(key string) ([]int, error)
	getIntSliceMutex       sync.RWMutex
	getIntSliceArgsForCall []struct {
		key string
	}
	getIntSliceReturns struct {
		result1 []int
		result2 error
	}
	getIntSliceReturnsOnCall map[int]struct {
		result1 []int
		result2 error
	}
	GetFloatSliceStub        func(key string) ([]float64, error)
	getFloatSliceMutex       sync.RWMutex
	getFloatSliceArgsForCall []struct {
		key string
	}
	getFloatSliceReturns struct {
		result1 []float64
		result2 error
	}
	getFloatSliceReturnsOnCall map[int]struct {
		result1 []float64
		result2 error
	}
	GetStringMapStub        func(key string) (map[string]interface{}, error)
	getStringMapMutex       sync.RWMutex
	getStringMapArgsForCall []struct {
		key string
	}
	getStringMapReturns struct {
		result1 map[string]interface{}
		result2 error
	}
	getStringMapReturnsOnCall map[int]struct {
		result1 map[string]interface{}
		result2 error
	}
	GetStringMapStringStub        func(key string) (map[string]string, error)
	getStringMapStringMutex       sync.RWMutex
	getStringMapStringArgsForCall []struct {
		key string
	}
	getStringMapStringReturns struct {
		result1 map[string]string
		result2 error
	}
	getStringMapStringReturnsOnCall map[int]struct {
		result1 map[string]string
		result2 error
	}
	ExistsStub        func(key string) bool
	existsMutex       sync.RWMutex
	existsArgsForCall []struct {
		key string
	}
	existsReturns struct {
		result1 bool
	}
	existsReturnsOnCall map[int]struct {
		result1 bool
	}
	SetStub        func(string, interface{}) error
	setMutex       sync.RWMutex
	setArgsForCall []struct {
		arg1 string
		arg2 interface{}
	}
	setReturns struct {
		result1 error
	}
	setReturnsOnCall map[int]struct {
		result1 error
	}
	EraseStub        func(key string) error
	eraseMutex       sync.RWMutex
	eraseArgsForCall []struct {
		key string
	}
	eraseReturns struct {
		result1 error
	}
	eraseReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePluginConfig) Get(key string) interface{} {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		key string
	}{key})
	fake.recordInvocation("Get", []interface{}{key})
	fake.getMutex.Unlock()
	if fake.GetStub != nil {
		return fake.GetStub(key)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getReturns.result1
}

func (fake *FakePluginConfig) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakePluginConfig) GetArgsForCall(i int) string {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return fake.getArgsForCall[i].key
}

func (fake *FakePluginConfig) GetReturns(result1 interface{}) {
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 interface{}
	}{result1}
}

func (fake *FakePluginConfig) GetReturnsOnCall(i int, result1 interface{}) {
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 interface{}
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 interface{}
	}{result1}
}

func (fake *FakePluginConfig) GetWithDefault(key string, defaultVal interface{}) interface{} {
	fake.getWithDefaultMutex.Lock()
	ret, specificReturn := fake.getWithDefaultReturnsOnCall[len(fake.getWithDefaultArgsForCall)]
	fake.getWithDefaultArgsForCall = append(fake.getWithDefaultArgsForCall, struct {
		key        string
		defaultVal interface{}
	}{key, defaultVal})
	fake.recordInvocation("GetWithDefault", []interface{}{key, defaultVal})
	fake.getWithDefaultMutex.Unlock()
	if fake.GetWithDefaultStub != nil {
		return fake.GetWithDefaultStub(key, defaultVal)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getWithDefaultReturns.result1
}

func (fake *FakePluginConfig) GetWithDefaultCallCount() int {
	fake.getWithDefaultMutex.RLock()
	defer fake.getWithDefaultMutex.RUnlock()
	return len(fake.getWithDefaultArgsForCall)
}

func (fake *FakePluginConfig) GetWithDefaultArgsForCall(i int) (string, interface{}) {
	fake.getWithDefaultMutex.RLock()
	defer fake.getWithDefaultMutex.RUnlock()
	return fake.getWithDefaultArgsForCall[i].key, fake.getWithDefaultArgsForCall[i].defaultVal
}

func (fake *FakePluginConfig) GetWithDefaultReturns(result1 interface{}) {
	fake.GetWithDefaultStub = nil
	fake.getWithDefaultReturns = struct {
		result1 interface{}
	}{result1}
}

func (fake *FakePluginConfig) GetWithDefaultReturnsOnCall(i int, result1 interface{}) {
	fake.GetWithDefaultStub = nil
	if fake.getWithDefaultReturnsOnCall == nil {
		fake.getWithDefaultReturnsOnCall = make(map[int]struct {
			result1 interface{}
		})
	}
	fake.getWithDefaultReturnsOnCall[i] = struct {
		result1 interface{}
	}{result1}
}

func (fake *FakePluginConfig) GetString(key string) (string, error) {
	fake.getStringMutex.Lock()
	ret, specificReturn := fake.getStringReturnsOnCall[len(fake.getStringArgsForCall)]
	fake.getStringArgsForCall = append(fake.getStringArgsForCall, struct {
		key string
	}{key})
	fake.recordInvocation("GetString", []interface{}{key})
	fake.getStringMutex.Unlock()
	if fake.GetStringStub != nil {
		return fake.GetStringStub(key)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getStringReturns.result1, fake.getStringReturns.result2
}

func (fake *FakePluginConfig) GetStringCallCount() int {
	fake.getStringMutex.RLock()
	defer fake.getStringMutex.RUnlock()
	return len(fake.getStringArgsForCall)
}

func (fake *FakePluginConfig) GetStringArgsForCall(i int) string {
	fake.getStringMutex.RLock()
	defer fake.getStringMutex.RUnlock()
	return fake.getStringArgsForCall[i].key
}

func (fake *FakePluginConfig) GetStringReturns(result1 string, result2 error) {
	fake.GetStringStub = nil
	fake.getStringReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetStringReturnsOnCall(i int, result1 string, result2 error) {
	fake.GetStringStub = nil
	if fake.getStringReturnsOnCall == nil {
		fake.getStringReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getStringReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetStringWithDefault(key string, defaultVal string) (string, error) {
	fake.getStringWithDefaultMutex.Lock()
	ret, specificReturn := fake.getStringWithDefaultReturnsOnCall[len(fake.getStringWithDefaultArgsForCall)]
	fake.getStringWithDefaultArgsForCall = append(fake.getStringWithDefaultArgsForCall, struct {
		key        string
		defaultVal string
	}{key, defaultVal})
	fake.recordInvocation("GetStringWithDefault", []interface{}{key, defaultVal})
	fake.getStringWithDefaultMutex.Unlock()
	if fake.GetStringWithDefaultStub != nil {
		return fake.GetStringWithDefaultStub(key, defaultVal)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getStringWithDefaultReturns.result1, fake.getStringWithDefaultReturns.result2
}

func (fake *FakePluginConfig) GetStringWithDefaultCallCount() int {
	fake.getStringWithDefaultMutex.RLock()
	defer fake.getStringWithDefaultMutex.RUnlock()
	return len(fake.getStringWithDefaultArgsForCall)
}

func (fake *FakePluginConfig) GetStringWithDefaultArgsForCall(i int) (string, string) {
	fake.getStringWithDefaultMutex.RLock()
	defer fake.getStringWithDefaultMutex.RUnlock()
	return fake.getStringWithDefaultArgsForCall[i].key, fake.getStringWithDefaultArgsForCall[i].defaultVal
}

func (fake *FakePluginConfig) GetStringWithDefaultReturns(result1 string, result2 error) {
	fake.GetStringWithDefaultStub = nil
	fake.getStringWithDefaultReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetStringWithDefaultReturnsOnCall(i int, result1 string, result2 error) {
	fake.GetStringWithDefaultStub = nil
	if fake.getStringWithDefaultReturnsOnCall == nil {
		fake.getStringWithDefaultReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getStringWithDefaultReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetBool(key string) (bool, error) {
	fake.getBoolMutex.Lock()
	ret, specificReturn := fake.getBoolReturnsOnCall[len(fake.getBoolArgsForCall)]
	fake.getBoolArgsForCall = append(fake.getBoolArgsForCall, struct {
		key string
	}{key})
	fake.recordInvocation("GetBool", []interface{}{key})
	fake.getBoolMutex.Unlock()
	if fake.GetBoolStub != nil {
		return fake.GetBoolStub(key)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getBoolReturns.result1, fake.getBoolReturns.result2
}

func (fake *FakePluginConfig) GetBoolCallCount() int {
	fake.getBoolMutex.RLock()
	defer fake.getBoolMutex.RUnlock()
	return len(fake.getBoolArgsForCall)
}

func (fake *FakePluginConfig) GetBoolArgsForCall(i int) string {
	fake.getBoolMutex.RLock()
	defer fake.getBoolMutex.RUnlock()
	return fake.getBoolArgsForCall[i].key
}

func (fake *FakePluginConfig) GetBoolReturns(result1 bool, result2 error) {
	fake.GetBoolStub = nil
	fake.getBoolReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetBoolReturnsOnCall(i int, result1 bool, result2 error) {
	fake.GetBoolStub = nil
	if fake.getBoolReturnsOnCall == nil {
		fake.getBoolReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.getBoolReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetBoolWithDefault(key string, defaultVal bool) (bool, error) {
	fake.getBoolWithDefaultMutex.Lock()
	ret, specificReturn := fake.getBoolWithDefaultReturnsOnCall[len(fake.getBoolWithDefaultArgsForCall)]
	fake.getBoolWithDefaultArgsForCall = append(fake.getBoolWithDefaultArgsForCall, struct {
		key        string
		defaultVal bool
	}{key, defaultVal})
	fake.recordInvocation("GetBoolWithDefault", []interface{}{key, defaultVal})
	fake.getBoolWithDefaultMutex.Unlock()
	if fake.GetBoolWithDefaultStub != nil {
		return fake.GetBoolWithDefaultStub(key, defaultVal)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getBoolWithDefaultReturns.result1, fake.getBoolWithDefaultReturns.result2
}

func (fake *FakePluginConfig) GetBoolWithDefaultCallCount() int {
	fake.getBoolWithDefaultMutex.RLock()
	defer fake.getBoolWithDefaultMutex.RUnlock()
	return len(fake.getBoolWithDefaultArgsForCall)
}

func (fake *FakePluginConfig) GetBoolWithDefaultArgsForCall(i int) (string, bool) {
	fake.getBoolWithDefaultMutex.RLock()
	defer fake.getBoolWithDefaultMutex.RUnlock()
	return fake.getBoolWithDefaultArgsForCall[i].key, fake.getBoolWithDefaultArgsForCall[i].defaultVal
}

func (fake *FakePluginConfig) GetBoolWithDefaultReturns(result1 bool, result2 error) {
	fake.GetBoolWithDefaultStub = nil
	fake.getBoolWithDefaultReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetBoolWithDefaultReturnsOnCall(i int, result1 bool, result2 error) {
	fake.GetBoolWithDefaultStub = nil
	if fake.getBoolWithDefaultReturnsOnCall == nil {
		fake.getBoolWithDefaultReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.getBoolWithDefaultReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetInt(key string) (int, error) {
	fake.getIntMutex.Lock()
	ret, specificReturn := fake.getIntReturnsOnCall[len(fake.getIntArgsForCall)]
	fake.getIntArgsForCall = append(fake.getIntArgsForCall, struct {
		key string
	}{key})
	fake.recordInvocation("GetInt", []interface{}{key})
	fake.getIntMutex.Unlock()
	if fake.GetIntStub != nil {
		return fake.GetIntStub(key)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getIntReturns.result1, fake.getIntReturns.result2
}

func (fake *FakePluginConfig) GetIntCallCount() int {
	fake.getIntMutex.RLock()
	defer fake.getIntMutex.RUnlock()
	return len(fake.getIntArgsForCall)
}

func (fake *FakePluginConfig) GetIntArgsForCall(i int) string {
	fake.getIntMutex.RLock()
	defer fake.getIntMutex.RUnlock()
	return fake.getIntArgsForCall[i].key
}

func (fake *FakePluginConfig) GetIntReturns(result1 int, result2 error) {
	fake.GetIntStub = nil
	fake.getIntReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetIntReturnsOnCall(i int, result1 int, result2 error) {
	fake.GetIntStub = nil
	if fake.getIntReturnsOnCall == nil {
		fake.getIntReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.getIntReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetIntWithDefault(key string, defaultVal int) (int, error) {
	fake.getIntWithDefaultMutex.Lock()
	ret, specificReturn := fake.getIntWithDefaultReturnsOnCall[len(fake.getIntWithDefaultArgsForCall)]
	fake.getIntWithDefaultArgsForCall = append(fake.getIntWithDefaultArgsForCall, struct {
		key        string
		defaultVal int
	}{key, defaultVal})
	fake.recordInvocation("GetIntWithDefault", []interface{}{key, defaultVal})
	fake.getIntWithDefaultMutex.Unlock()
	if fake.GetIntWithDefaultStub != nil {
		return fake.GetIntWithDefaultStub(key, defaultVal)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getIntWithDefaultReturns.result1, fake.getIntWithDefaultReturns.result2
}

func (fake *FakePluginConfig) GetIntWithDefaultCallCount() int {
	fake.getIntWithDefaultMutex.RLock()
	defer fake.getIntWithDefaultMutex.RUnlock()
	return len(fake.getIntWithDefaultArgsForCall)
}

func (fake *FakePluginConfig) GetIntWithDefaultArgsForCall(i int) (string, int) {
	fake.getIntWithDefaultMutex.RLock()
	defer fake.getIntWithDefaultMutex.RUnlock()
	return fake.getIntWithDefaultArgsForCall[i].key, fake.getIntWithDefaultArgsForCall[i].defaultVal
}

func (fake *FakePluginConfig) GetIntWithDefaultReturns(result1 int, result2 error) {
	fake.GetIntWithDefaultStub = nil
	fake.getIntWithDefaultReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetIntWithDefaultReturnsOnCall(i int, result1 int, result2 error) {
	fake.GetIntWithDefaultStub = nil
	if fake.getIntWithDefaultReturnsOnCall == nil {
		fake.getIntWithDefaultReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.getIntWithDefaultReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetFloat(key string) (float64, error) {
	fake.getFloatMutex.Lock()
	ret, specificReturn := fake.getFloatReturnsOnCall[len(fake.getFloatArgsForCall)]
	fake.getFloatArgsForCall = append(fake.getFloatArgsForCall, struct {
		key string
	}{key})
	fake.recordInvocation("GetFloat", []interface{}{key})
	fake.getFloatMutex.Unlock()
	if fake.GetFloatStub != nil {
		return fake.GetFloatStub(key)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getFloatReturns.result1, fake.getFloatReturns.result2
}

func (fake *FakePluginConfig) GetFloatCallCount() int {
	fake.getFloatMutex.RLock()
	defer fake.getFloatMutex.RUnlock()
	return len(fake.getFloatArgsForCall)
}

func (fake *FakePluginConfig) GetFloatArgsForCall(i int) string {
	fake.getFloatMutex.RLock()
	defer fake.getFloatMutex.RUnlock()
	return fake.getFloatArgsForCall[i].key
}

func (fake *FakePluginConfig) GetFloatReturns(result1 float64, result2 error) {
	fake.GetFloatStub = nil
	fake.getFloatReturns = struct {
		result1 float64
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetFloatReturnsOnCall(i int, result1 float64, result2 error) {
	fake.GetFloatStub = nil
	if fake.getFloatReturnsOnCall == nil {
		fake.getFloatReturnsOnCall = make(map[int]struct {
			result1 float64
			result2 error
		})
	}
	fake.getFloatReturnsOnCall[i] = struct {
		result1 float64
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetFloatWithDefault(key string, defaultVal float64) (float64, error) {
	fake.getFloatWithDefaultMutex.Lock()
	ret, specificReturn := fake.getFloatWithDefaultReturnsOnCall[len(fake.getFloatWithDefaultArgsForCall)]
	fake.getFloatWithDefaultArgsForCall = append(fake.getFloatWithDefaultArgsForCall, struct {
		key        string
		defaultVal float64
	}{key, defaultVal})
	fake.recordInvocation("GetFloatWithDefault", []interface{}{key, defaultVal})
	fake.getFloatWithDefaultMutex.Unlock()
	if fake.GetFloatWithDefaultStub != nil {
		return fake.GetFloatWithDefaultStub(key, defaultVal)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getFloatWithDefaultReturns.result1, fake.getFloatWithDefaultReturns.result2
}

func (fake *FakePluginConfig) GetFloatWithDefaultCallCount() int {
	fake.getFloatWithDefaultMutex.RLock()
	defer fake.getFloatWithDefaultMutex.RUnlock()
	return len(fake.getFloatWithDefaultArgsForCall)
}

func (fake *FakePluginConfig) GetFloatWithDefaultArgsForCall(i int) (string, float64) {
	fake.getFloatWithDefaultMutex.RLock()
	defer fake.getFloatWithDefaultMutex.RUnlock()
	return fake.getFloatWithDefaultArgsForCall[i].key, fake.getFloatWithDefaultArgsForCall[i].defaultVal
}

func (fake *FakePluginConfig) GetFloatWithDefaultReturns(result1 float64, result2 error) {
	fake.GetFloatWithDefaultStub = nil
	fake.getFloatWithDefaultReturns = struct {
		result1 float64
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetFloatWithDefaultReturnsOnCall(i int, result1 float64, result2 error) {
	fake.GetFloatWithDefaultStub = nil
	if fake.getFloatWithDefaultReturnsOnCall == nil {
		fake.getFloatWithDefaultReturnsOnCall = make(map[int]struct {
			result1 float64
			result2 error
		})
	}
	fake.getFloatWithDefaultReturnsOnCall[i] = struct {
		result1 float64
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetStringSlice(key string) ([]string, error) {
	fake.getStringSliceMutex.Lock()
	ret, specificReturn := fake.getStringSliceReturnsOnCall[len(fake.getStringSliceArgsForCall)]
	fake.getStringSliceArgsForCall = append(fake.getStringSliceArgsForCall, struct {
		key string
	}{key})
	fake.recordInvocation("GetStringSlice", []interface{}{key})
	fake.getStringSliceMutex.Unlock()
	if fake.GetStringSliceStub != nil {
		return fake.GetStringSliceStub(key)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getStringSliceReturns.result1, fake.getStringSliceReturns.result2
}

func (fake *FakePluginConfig) GetStringSliceCallCount() int {
	fake.getStringSliceMutex.RLock()
	defer fake.getStringSliceMutex.RUnlock()
	return len(fake.getStringSliceArgsForCall)
}

func (fake *FakePluginConfig) GetStringSliceArgsForCall(i int) string {
	fake.getStringSliceMutex.RLock()
	defer fake.getStringSliceMutex.RUnlock()
	return fake.getStringSliceArgsForCall[i].key
}

func (fake *FakePluginConfig) GetStringSliceReturns(result1 []string, result2 error) {
	fake.GetStringSliceStub = nil
	fake.getStringSliceReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetStringSliceReturnsOnCall(i int, result1 []string, result2 error) {
	fake.GetStringSliceStub = nil
	if fake.getStringSliceReturnsOnCall == nil {
		fake.getStringSliceReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.getStringSliceReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetIntSlice(key string) ([]int, error) {
	fake.getIntSliceMutex.Lock()
	ret, specificReturn := fake.getIntSliceReturnsOnCall[len(fake.getIntSliceArgsForCall)]
	fake.getIntSliceArgsForCall = append(fake.getIntSliceArgsForCall, struct {
		key string
	}{key})
	fake.recordInvocation("GetIntSlice", []interface{}{key})
	fake.getIntSliceMutex.Unlock()
	if fake.GetIntSliceStub != nil {
		return fake.GetIntSliceStub(key)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getIntSliceReturns.result1, fake.getIntSliceReturns.result2
}

func (fake *FakePluginConfig) GetIntSliceCallCount() int {
	fake.getIntSliceMutex.RLock()
	defer fake.getIntSliceMutex.RUnlock()
	return len(fake.getIntSliceArgsForCall)
}

func (fake *FakePluginConfig) GetIntSliceArgsForCall(i int) string {
	fake.getIntSliceMutex.RLock()
	defer fake.getIntSliceMutex.RUnlock()
	return fake.getIntSliceArgsForCall[i].key
}

func (fake *FakePluginConfig) GetIntSliceReturns(result1 []int, result2 error) {
	fake.GetIntSliceStub = nil
	fake.getIntSliceReturns = struct {
		result1 []int
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetIntSliceReturnsOnCall(i int, result1 []int, result2 error) {
	fake.GetIntSliceStub = nil
	if fake.getIntSliceReturnsOnCall == nil {
		fake.getIntSliceReturnsOnCall = make(map[int]struct {
			result1 []int
			result2 error
		})
	}
	fake.getIntSliceReturnsOnCall[i] = struct {
		result1 []int
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetFloatSlice(key string) ([]float64, error) {
	fake.getFloatSliceMutex.Lock()
	ret, specificReturn := fake.getFloatSliceReturnsOnCall[len(fake.getFloatSliceArgsForCall)]
	fake.getFloatSliceArgsForCall = append(fake.getFloatSliceArgsForCall, struct {
		key string
	}{key})
	fake.recordInvocation("GetFloatSlice", []interface{}{key})
	fake.getFloatSliceMutex.Unlock()
	if fake.GetFloatSliceStub != nil {
		return fake.GetFloatSliceStub(key)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getFloatSliceReturns.result1, fake.getFloatSliceReturns.result2
}

func (fake *FakePluginConfig) GetFloatSliceCallCount() int {
	fake.getFloatSliceMutex.RLock()
	defer fake.getFloatSliceMutex.RUnlock()
	return len(fake.getFloatSliceArgsForCall)
}

func (fake *FakePluginConfig) GetFloatSliceArgsForCall(i int) string {
	fake.getFloatSliceMutex.RLock()
	defer fake.getFloatSliceMutex.RUnlock()
	return fake.getFloatSliceArgsForCall[i].key
}

func (fake *FakePluginConfig) GetFloatSliceReturns(result1 []float64, result2 error) {
	fake.GetFloatSliceStub = nil
	fake.getFloatSliceReturns = struct {
		result1 []float64
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetFloatSliceReturnsOnCall(i int, result1 []float64, result2 error) {
	fake.GetFloatSliceStub = nil
	if fake.getFloatSliceReturnsOnCall == nil {
		fake.getFloatSliceReturnsOnCall = make(map[int]struct {
			result1 []float64
			result2 error
		})
	}
	fake.getFloatSliceReturnsOnCall[i] = struct {
		result1 []float64
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetStringMap(key string) (map[string]interface{}, error) {
	fake.getStringMapMutex.Lock()
	ret, specificReturn := fake.getStringMapReturnsOnCall[len(fake.getStringMapArgsForCall)]
	fake.getStringMapArgsForCall = append(fake.getStringMapArgsForCall, struct {
		key string
	}{key})
	fake.recordInvocation("GetStringMap", []interface{}{key})
	fake.getStringMapMutex.Unlock()
	if fake.GetStringMapStub != nil {
		return fake.GetStringMapStub(key)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getStringMapReturns.result1, fake.getStringMapReturns.result2
}

func (fake *FakePluginConfig) GetStringMapCallCount() int {
	fake.getStringMapMutex.RLock()
	defer fake.getStringMapMutex.RUnlock()
	return len(fake.getStringMapArgsForCall)
}

func (fake *FakePluginConfig) GetStringMapArgsForCall(i int) string {
	fake.getStringMapMutex.RLock()
	defer fake.getStringMapMutex.RUnlock()
	return fake.getStringMapArgsForCall[i].key
}

func (fake *FakePluginConfig) GetStringMapReturns(result1 map[string]interface{}, result2 error) {
	fake.GetStringMapStub = nil
	fake.getStringMapReturns = struct {
		result1 map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetStringMapReturnsOnCall(i int, result1 map[string]interface{}, result2 error) {
	fake.GetStringMapStub = nil
	if fake.getStringMapReturnsOnCall == nil {
		fake.getStringMapReturnsOnCall = make(map[int]struct {
			result1 map[string]interface{}
			result2 error
		})
	}
	fake.getStringMapReturnsOnCall[i] = struct {
		result1 map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetStringMapString(key string) (map[string]string, error) {
	fake.getStringMapStringMutex.Lock()
	ret, specificReturn := fake.getStringMapStringReturnsOnCall[len(fake.getStringMapStringArgsForCall)]
	fake.getStringMapStringArgsForCall = append(fake.getStringMapStringArgsForCall, struct {
		key string
	}{key})
	fake.recordInvocation("GetStringMapString", []interface{}{key})
	fake.getStringMapStringMutex.Unlock()
	if fake.GetStringMapStringStub != nil {
		return fake.GetStringMapStringStub(key)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getStringMapStringReturns.result1, fake.getStringMapStringReturns.result2
}

func (fake *FakePluginConfig) GetStringMapStringCallCount() int {
	fake.getStringMapStringMutex.RLock()
	defer fake.getStringMapStringMutex.RUnlock()
	return len(fake.getStringMapStringArgsForCall)
}

func (fake *FakePluginConfig) GetStringMapStringArgsForCall(i int) string {
	fake.getStringMapStringMutex.RLock()
	defer fake.getStringMapStringMutex.RUnlock()
	return fake.getStringMapStringArgsForCall[i].key
}

func (fake *FakePluginConfig) GetStringMapStringReturns(result1 map[string]string, result2 error) {
	fake.GetStringMapStringStub = nil
	fake.getStringMapStringReturns = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetStringMapStringReturnsOnCall(i int, result1 map[string]string, result2 error) {
	fake.GetStringMapStringStub = nil
	if fake.getStringMapStringReturnsOnCall == nil {
		fake.getStringMapStringReturnsOnCall = make(map[int]struct {
			result1 map[string]string
			result2 error
		})
	}
	fake.getStringMapStringReturnsOnCall[i] = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) Exists(key string) bool {
	fake.existsMutex.Lock()
	ret, specificReturn := fake.existsReturnsOnCall[len(fake.existsArgsForCall)]
	fake.existsArgsForCall = append(fake.existsArgsForCall, struct {
		key string
	}{key})
	fake.recordInvocation("Exists", []interface{}{key})
	fake.existsMutex.Unlock()
	if fake.ExistsStub != nil {
		return fake.ExistsStub(key)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.existsReturns.result1
}

func (fake *FakePluginConfig) ExistsCallCount() int {
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	return len(fake.existsArgsForCall)
}

func (fake *FakePluginConfig) ExistsArgsForCall(i int) string {
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	return fake.existsArgsForCall[i].key
}

func (fake *FakePluginConfig) ExistsReturns(result1 bool) {
	fake.ExistsStub = nil
	fake.existsReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginConfig) ExistsReturnsOnCall(i int, result1 bool) {
	fake.ExistsStub = nil
	if fake.existsReturnsOnCall == nil {
		fake.existsReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.existsReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginConfig) Set(arg1 string, arg2 interface{}) error {
	fake.setMutex.Lock()
	ret, specificReturn := fake.setReturnsOnCall[len(fake.setArgsForCall)]
	fake.setArgsForCall = append(fake.setArgsForCall, struct {
		arg1 string
		arg2 interface{}
	}{arg1, arg2})
	fake.recordInvocation("Set", []interface{}{arg1, arg2})
	fake.setMutex.Unlock()
	if fake.SetStub != nil {
		return fake.SetStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setReturns.result1
}

func (fake *FakePluginConfig) SetCallCount() int {
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	return len(fake.setArgsForCall)
}

func (fake *FakePluginConfig) SetArgsForCall(i int) (string, interface{}) {
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	return fake.setArgsForCall[i].arg1, fake.setArgsForCall[i].arg2
}

func (fake *FakePluginConfig) SetReturns(result1 error) {
	fake.SetStub = nil
	fake.setReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePluginConfig) SetReturnsOnCall(i int, result1 error) {
	fake.SetStub = nil
	if fake.setReturnsOnCall == nil {
		fake.setReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePluginConfig) Erase(key string) error {
	fake.eraseMutex.Lock()
	ret, specificReturn := fake.eraseReturnsOnCall[len(fake.eraseArgsForCall)]
	fake.eraseArgsForCall = append(fake.eraseArgsForCall, struct {
		key string
	}{key})
	fake.recordInvocation("Erase", []interface{}{key})
	fake.eraseMutex.Unlock()
	if fake.EraseStub != nil {
		return fake.EraseStub(key)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.eraseReturns.result1
}

func (fake *FakePluginConfig) EraseCallCount() int {
	fake.eraseMutex.RLock()
	defer fake.eraseMutex.RUnlock()
	return len(fake.eraseArgsForCall)
}

func (fake *FakePluginConfig) EraseArgsForCall(i int) string {
	fake.eraseMutex.RLock()
	defer fake.eraseMutex.RUnlock()
	return fake.eraseArgsForCall[i].key
}

func (fake *FakePluginConfig) EraseReturns(result1 error) {
	fake.EraseStub = nil
	fake.eraseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePluginConfig) EraseReturnsOnCall(i int, result1 error) {
	fake.EraseStub = nil
	if fake.eraseReturnsOnCall == nil {
		fake.eraseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.eraseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePluginConfig) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.getWithDefaultMutex.RLock()
	defer fake.getWithDefaultMutex.RUnlock()
	fake.getStringMutex.RLock()
	defer fake.getStringMutex.RUnlock()
	fake.getStringWithDefaultMutex.RLock()
	defer fake.getStringWithDefaultMutex.RUnlock()
	fake.getBoolMutex.RLock()
	defer fake.getBoolMutex.RUnlock()
	fake.getBoolWithDefaultMutex.RLock()
	defer fake.getBoolWithDefaultMutex.RUnlock()
	fake.getIntMutex.RLock()
	defer fake.getIntMutex.RUnlock()
	fake.getIntWithDefaultMutex.RLock()
	defer fake.getIntWithDefaultMutex.RUnlock()
	fake.getFloatMutex.RLock()
	defer fake.getFloatMutex.RUnlock()
	fake.getFloatWithDefaultMutex.RLock()
	defer fake.getFloatWithDefaultMutex.RUnlock()
	fake.getStringSliceMutex.RLock()
	defer fake.getStringSliceMutex.RUnlock()
	fake.getIntSliceMutex.RLock()
	defer fake.getIntSliceMutex.RUnlock()
	fake.getFloatSliceMutex.RLock()
	defer fake.getFloatSliceMutex.RUnlock()
	fake.getStringMapMutex.RLock()
	defer fake.getStringMapMutex.RUnlock()
	fake.getStringMapStringMutex.RLock()
	defer fake.getStringMapStringMutex.RUnlock()
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	fake.eraseMutex.RLock()
	defer fake.eraseMutex.RUnlock()
	return fake.invocations
}

func (fake *FakePluginConfig) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ plugin.PluginConfig = new(FakePluginConfig)
