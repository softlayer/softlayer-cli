// Code generated by counterfeiter. DO NOT EDIT.
package testhelpers

import (
	"sync"

	"github.com/softlayer/softlayer-go/datatypes"
	"github.ibm.com/SoftLayer/softlayer-cli/plugin/managers"
)

type FakeAccountManager struct {
	AckEventStub        func(int) (bool, error)
	ackEventMutex       sync.RWMutex
	ackEventArgsForCall []struct {
		arg1 int
	}
	ackEventReturns struct {
		result1 bool
		result2 error
	}
	ackEventReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CancelItemStub        func(int) error
	cancelItemMutex       sync.RWMutex
	cancelItemArgsForCall []struct {
		arg1 int
	}
	cancelItemReturns struct {
		result1 error
	}
	cancelItemReturnsOnCall map[int]struct {
		result1 error
	}
	CreateProvisioningScriptStub        func(datatypes.Provisioning_Hook) (datatypes.Provisioning_Hook, error)
	createProvisioningScriptMutex       sync.RWMutex
	createProvisioningScriptArgsForCall []struct {
		arg1 datatypes.Provisioning_Hook
	}
	createProvisioningScriptReturns struct {
		result1 datatypes.Provisioning_Hook
		result2 error
	}
	createProvisioningScriptReturnsOnCall map[int]struct {
		result1 datatypes.Provisioning_Hook
		result2 error
	}
	DeleteProvisioningScriptStub        func(int) (bool, error)
	deleteProvisioningScriptMutex       sync.RWMutex
	deleteProvisioningScriptArgsForCall []struct {
		arg1 int
	}
	deleteProvisioningScriptReturns struct {
		result1 bool
		result2 error
	}
	deleteProvisioningScriptReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	GetAccountAllBillingOrdersStub        func(string, int) ([]datatypes.Billing_Order, error)
	getAccountAllBillingOrdersMutex       sync.RWMutex
	getAccountAllBillingOrdersArgsForCall []struct {
		arg1 string
		arg2 int
	}
	getAccountAllBillingOrdersReturns struct {
		result1 []datatypes.Billing_Order
		result2 error
	}
	getAccountAllBillingOrdersReturnsOnCall map[int]struct {
		result1 []datatypes.Billing_Order
		result2 error
	}
	GetActiveAccountLicensesStub        func(string) ([]datatypes.Software_AccountLicense, error)
	getActiveAccountLicensesMutex       sync.RWMutex
	getActiveAccountLicensesArgsForCall []struct {
		arg1 string
	}
	getActiveAccountLicensesReturns struct {
		result1 []datatypes.Software_AccountLicense
		result2 error
	}
	getActiveAccountLicensesReturnsOnCall map[int]struct {
		result1 []datatypes.Software_AccountLicense
		result2 error
	}
	GetActiveVirtualLicensesStub        func(string) ([]datatypes.Software_VirtualLicense, error)
	getActiveVirtualLicensesMutex       sync.RWMutex
	getActiveVirtualLicensesArgsForCall []struct {
		arg1 string
	}
	getActiveVirtualLicensesReturns struct {
		result1 []datatypes.Software_VirtualLicense
		result2 error
	}
	getActiveVirtualLicensesReturnsOnCall map[int]struct {
		result1 []datatypes.Software_VirtualLicense
		result2 error
	}
	GetBandwidthPoolDetailStub        func(int, string) (datatypes.Network_Bandwidth_Version1_Allotment, error)
	getBandwidthPoolDetailMutex       sync.RWMutex
	getBandwidthPoolDetailArgsForCall []struct {
		arg1 int
		arg2 string
	}
	getBandwidthPoolDetailReturns struct {
		result1 datatypes.Network_Bandwidth_Version1_Allotment
		result2 error
	}
	getBandwidthPoolDetailReturnsOnCall map[int]struct {
		result1 datatypes.Network_Bandwidth_Version1_Allotment
		result2 error
	}
	GetBandwidthPoolServersStub        func(int) (uint, error)
	getBandwidthPoolServersMutex       sync.RWMutex
	getBandwidthPoolServersArgsForCall []struct {
		arg1 int
	}
	getBandwidthPoolServersReturns struct {
		result1 uint
		result2 error
	}
	getBandwidthPoolServersReturnsOnCall map[int]struct {
		result1 uint
		result2 error
	}
	GetBandwidthPoolsStub        func() ([]datatypes.Network_Bandwidth_Version1_Allotment, error)
	getBandwidthPoolsMutex       sync.RWMutex
	getBandwidthPoolsArgsForCall []struct {
	}
	getBandwidthPoolsReturns struct {
		result1 []datatypes.Network_Bandwidth_Version1_Allotment
		result2 error
	}
	getBandwidthPoolsReturnsOnCall map[int]struct {
		result1 []datatypes.Network_Bandwidth_Version1_Allotment
		result2 error
	}
	GetBillingItemsStub        func(string, string) ([]datatypes.Billing_Item, error)
	getBillingItemsMutex       sync.RWMutex
	getBillingItemsArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getBillingItemsReturns struct {
		result1 []datatypes.Billing_Item
		result2 error
	}
	getBillingItemsReturnsOnCall map[int]struct {
		result1 []datatypes.Billing_Item
		result2 error
	}
	GetEventDetailStub        func(int, string) (datatypes.Notification_Occurrence_Event, error)
	getEventDetailMutex       sync.RWMutex
	getEventDetailArgsForCall []struct {
		arg1 int
		arg2 string
	}
	getEventDetailReturns struct {
		result1 datatypes.Notification_Occurrence_Event
		result2 error
	}
	getEventDetailReturnsOnCall map[int]struct {
		result1 datatypes.Notification_Occurrence_Event
		result2 error
	}
	GetEventsStub        func(string, string, string) ([]datatypes.Notification_Occurrence_Event, error)
	getEventsMutex       sync.RWMutex
	getEventsArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	getEventsReturns struct {
		result1 []datatypes.Notification_Occurrence_Event
		result2 error
	}
	getEventsReturnsOnCall map[int]struct {
		result1 []datatypes.Notification_Occurrence_Event
		result2 error
	}
	GetInvoiceDetailStub        func(int, string) ([]datatypes.Billing_Invoice_Item, error)
	getInvoiceDetailMutex       sync.RWMutex
	getInvoiceDetailArgsForCall []struct {
		arg1 int
		arg2 string
	}
	getInvoiceDetailReturns struct {
		result1 []datatypes.Billing_Invoice_Item
		result2 error
	}
	getInvoiceDetailReturnsOnCall map[int]struct {
		result1 []datatypes.Billing_Invoice_Item
		result2 error
	}
	GetInvoicesStub        func(int, bool, bool) ([]datatypes.Billing_Invoice, error)
	getInvoicesMutex       sync.RWMutex
	getInvoicesArgsForCall []struct {
		arg1 int
		arg2 bool
		arg3 bool
	}
	getInvoicesReturns struct {
		result1 []datatypes.Billing_Invoice
		result2 error
	}
	getInvoicesReturnsOnCall map[int]struct {
		result1 []datatypes.Billing_Invoice
		result2 error
	}
	GetItemDetailStub        func(int, string) (datatypes.Billing_Item, error)
	getItemDetailMutex       sync.RWMutex
	getItemDetailArgsForCall []struct {
		arg1 int
		arg2 string
	}
	getItemDetailReturns struct {
		result1 datatypes.Billing_Item
		result2 error
	}
	getItemDetailReturnsOnCall map[int]struct {
		result1 datatypes.Billing_Item
		result2 error
	}
	GetPostProvisioningHooksStub        func(string) ([]datatypes.Provisioning_Hook, error)
	getPostProvisioningHooksMutex       sync.RWMutex
	getPostProvisioningHooksArgsForCall []struct {
		arg1 string
	}
	getPostProvisioningHooksReturns struct {
		result1 []datatypes.Provisioning_Hook
		result2 error
	}
	getPostProvisioningHooksReturnsOnCall map[int]struct {
		result1 []datatypes.Provisioning_Hook
		result2 error
	}
	GetSummaryStub        func(string) (datatypes.Account, error)
	getSummaryMutex       sync.RWMutex
	getSummaryArgsForCall []struct {
		arg1 string
	}
	getSummaryReturns struct {
		result1 datatypes.Account
		result2 error
	}
	getSummaryReturnsOnCall map[int]struct {
		result1 datatypes.Account
		result2 error
	}
	GetUpgradeRequestsStub        func(string, int) ([]datatypes.Product_Upgrade_Request, error)
	getUpgradeRequestsMutex       sync.RWMutex
	getUpgradeRequestsArgsForCall []struct {
		arg1 string
		arg2 int
	}
	getUpgradeRequestsReturns struct {
		result1 []datatypes.Product_Upgrade_Request
		result2 error
	}
	getUpgradeRequestsReturnsOnCall map[int]struct {
		result1 []datatypes.Product_Upgrade_Request
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeAccountManager) AckEvent(arg1 int) (bool, error) {
	fake.ackEventMutex.Lock()
	ret, specificReturn := fake.ackEventReturnsOnCall[len(fake.ackEventArgsForCall)]
	fake.ackEventArgsForCall = append(fake.ackEventArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.AckEventStub
	fakeReturns := fake.ackEventReturns
	fake.recordInvocation("AckEvent", []interface{}{arg1})
	fake.ackEventMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountManager) AckEventCallCount() int {
	fake.ackEventMutex.RLock()
	defer fake.ackEventMutex.RUnlock()
	return len(fake.ackEventArgsForCall)
}

func (fake *FakeAccountManager) AckEventCalls(stub func(int) (bool, error)) {
	fake.ackEventMutex.Lock()
	defer fake.ackEventMutex.Unlock()
	fake.AckEventStub = stub
}

func (fake *FakeAccountManager) AckEventArgsForCall(i int) int {
	fake.ackEventMutex.RLock()
	defer fake.ackEventMutex.RUnlock()
	argsForCall := fake.ackEventArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAccountManager) AckEventReturns(result1 bool, result2 error) {
	fake.ackEventMutex.Lock()
	defer fake.ackEventMutex.Unlock()
	fake.AckEventStub = nil
	fake.ackEventReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) AckEventReturnsOnCall(i int, result1 bool, result2 error) {
	fake.ackEventMutex.Lock()
	defer fake.ackEventMutex.Unlock()
	fake.AckEventStub = nil
	if fake.ackEventReturnsOnCall == nil {
		fake.ackEventReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.ackEventReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) CancelItem(arg1 int) error {
	fake.cancelItemMutex.Lock()
	ret, specificReturn := fake.cancelItemReturnsOnCall[len(fake.cancelItemArgsForCall)]
	fake.cancelItemArgsForCall = append(fake.cancelItemArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.CancelItemStub
	fakeReturns := fake.cancelItemReturns
	fake.recordInvocation("CancelItem", []interface{}{arg1})
	fake.cancelItemMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAccountManager) CancelItemCallCount() int {
	fake.cancelItemMutex.RLock()
	defer fake.cancelItemMutex.RUnlock()
	return len(fake.cancelItemArgsForCall)
}

func (fake *FakeAccountManager) CancelItemCalls(stub func(int) error) {
	fake.cancelItemMutex.Lock()
	defer fake.cancelItemMutex.Unlock()
	fake.CancelItemStub = stub
}

func (fake *FakeAccountManager) CancelItemArgsForCall(i int) int {
	fake.cancelItemMutex.RLock()
	defer fake.cancelItemMutex.RUnlock()
	argsForCall := fake.cancelItemArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAccountManager) CancelItemReturns(result1 error) {
	fake.cancelItemMutex.Lock()
	defer fake.cancelItemMutex.Unlock()
	fake.CancelItemStub = nil
	fake.cancelItemReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAccountManager) CancelItemReturnsOnCall(i int, result1 error) {
	fake.cancelItemMutex.Lock()
	defer fake.cancelItemMutex.Unlock()
	fake.CancelItemStub = nil
	if fake.cancelItemReturnsOnCall == nil {
		fake.cancelItemReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelItemReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAccountManager) CreateProvisioningScript(arg1 datatypes.Provisioning_Hook) (datatypes.Provisioning_Hook, error) {
	fake.createProvisioningScriptMutex.Lock()
	ret, specificReturn := fake.createProvisioningScriptReturnsOnCall[len(fake.createProvisioningScriptArgsForCall)]
	fake.createProvisioningScriptArgsForCall = append(fake.createProvisioningScriptArgsForCall, struct {
		arg1 datatypes.Provisioning_Hook
	}{arg1})
	stub := fake.CreateProvisioningScriptStub
	fakeReturns := fake.createProvisioningScriptReturns
	fake.recordInvocation("CreateProvisioningScript", []interface{}{arg1})
	fake.createProvisioningScriptMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountManager) CreateProvisioningScriptCallCount() int {
	fake.createProvisioningScriptMutex.RLock()
	defer fake.createProvisioningScriptMutex.RUnlock()
	return len(fake.createProvisioningScriptArgsForCall)
}

func (fake *FakeAccountManager) CreateProvisioningScriptCalls(stub func(datatypes.Provisioning_Hook) (datatypes.Provisioning_Hook, error)) {
	fake.createProvisioningScriptMutex.Lock()
	defer fake.createProvisioningScriptMutex.Unlock()
	fake.CreateProvisioningScriptStub = stub
}

func (fake *FakeAccountManager) CreateProvisioningScriptArgsForCall(i int) datatypes.Provisioning_Hook {
	fake.createProvisioningScriptMutex.RLock()
	defer fake.createProvisioningScriptMutex.RUnlock()
	argsForCall := fake.createProvisioningScriptArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAccountManager) CreateProvisioningScriptReturns(result1 datatypes.Provisioning_Hook, result2 error) {
	fake.createProvisioningScriptMutex.Lock()
	defer fake.createProvisioningScriptMutex.Unlock()
	fake.CreateProvisioningScriptStub = nil
	fake.createProvisioningScriptReturns = struct {
		result1 datatypes.Provisioning_Hook
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) CreateProvisioningScriptReturnsOnCall(i int, result1 datatypes.Provisioning_Hook, result2 error) {
	fake.createProvisioningScriptMutex.Lock()
	defer fake.createProvisioningScriptMutex.Unlock()
	fake.CreateProvisioningScriptStub = nil
	if fake.createProvisioningScriptReturnsOnCall == nil {
		fake.createProvisioningScriptReturnsOnCall = make(map[int]struct {
			result1 datatypes.Provisioning_Hook
			result2 error
		})
	}
	fake.createProvisioningScriptReturnsOnCall[i] = struct {
		result1 datatypes.Provisioning_Hook
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) DeleteProvisioningScript(arg1 int) (bool, error) {
	fake.deleteProvisioningScriptMutex.Lock()
	ret, specificReturn := fake.deleteProvisioningScriptReturnsOnCall[len(fake.deleteProvisioningScriptArgsForCall)]
	fake.deleteProvisioningScriptArgsForCall = append(fake.deleteProvisioningScriptArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.DeleteProvisioningScriptStub
	fakeReturns := fake.deleteProvisioningScriptReturns
	fake.recordInvocation("DeleteProvisioningScript", []interface{}{arg1})
	fake.deleteProvisioningScriptMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountManager) DeleteProvisioningScriptCallCount() int {
	fake.deleteProvisioningScriptMutex.RLock()
	defer fake.deleteProvisioningScriptMutex.RUnlock()
	return len(fake.deleteProvisioningScriptArgsForCall)
}

func (fake *FakeAccountManager) DeleteProvisioningScriptCalls(stub func(int) (bool, error)) {
	fake.deleteProvisioningScriptMutex.Lock()
	defer fake.deleteProvisioningScriptMutex.Unlock()
	fake.DeleteProvisioningScriptStub = stub
}

func (fake *FakeAccountManager) DeleteProvisioningScriptArgsForCall(i int) int {
	fake.deleteProvisioningScriptMutex.RLock()
	defer fake.deleteProvisioningScriptMutex.RUnlock()
	argsForCall := fake.deleteProvisioningScriptArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAccountManager) DeleteProvisioningScriptReturns(result1 bool, result2 error) {
	fake.deleteProvisioningScriptMutex.Lock()
	defer fake.deleteProvisioningScriptMutex.Unlock()
	fake.DeleteProvisioningScriptStub = nil
	fake.deleteProvisioningScriptReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) DeleteProvisioningScriptReturnsOnCall(i int, result1 bool, result2 error) {
	fake.deleteProvisioningScriptMutex.Lock()
	defer fake.deleteProvisioningScriptMutex.Unlock()
	fake.DeleteProvisioningScriptStub = nil
	if fake.deleteProvisioningScriptReturnsOnCall == nil {
		fake.deleteProvisioningScriptReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.deleteProvisioningScriptReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetAccountAllBillingOrders(arg1 string, arg2 int) ([]datatypes.Billing_Order, error) {
	fake.getAccountAllBillingOrdersMutex.Lock()
	ret, specificReturn := fake.getAccountAllBillingOrdersReturnsOnCall[len(fake.getAccountAllBillingOrdersArgsForCall)]
	fake.getAccountAllBillingOrdersArgsForCall = append(fake.getAccountAllBillingOrdersArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	stub := fake.GetAccountAllBillingOrdersStub
	fakeReturns := fake.getAccountAllBillingOrdersReturns
	fake.recordInvocation("GetAccountAllBillingOrders", []interface{}{arg1, arg2})
	fake.getAccountAllBillingOrdersMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountManager) GetAccountAllBillingOrdersCallCount() int {
	fake.getAccountAllBillingOrdersMutex.RLock()
	defer fake.getAccountAllBillingOrdersMutex.RUnlock()
	return len(fake.getAccountAllBillingOrdersArgsForCall)
}

func (fake *FakeAccountManager) GetAccountAllBillingOrdersCalls(stub func(string, int) ([]datatypes.Billing_Order, error)) {
	fake.getAccountAllBillingOrdersMutex.Lock()
	defer fake.getAccountAllBillingOrdersMutex.Unlock()
	fake.GetAccountAllBillingOrdersStub = stub
}

func (fake *FakeAccountManager) GetAccountAllBillingOrdersArgsForCall(i int) (string, int) {
	fake.getAccountAllBillingOrdersMutex.RLock()
	defer fake.getAccountAllBillingOrdersMutex.RUnlock()
	argsForCall := fake.getAccountAllBillingOrdersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAccountManager) GetAccountAllBillingOrdersReturns(result1 []datatypes.Billing_Order, result2 error) {
	fake.getAccountAllBillingOrdersMutex.Lock()
	defer fake.getAccountAllBillingOrdersMutex.Unlock()
	fake.GetAccountAllBillingOrdersStub = nil
	fake.getAccountAllBillingOrdersReturns = struct {
		result1 []datatypes.Billing_Order
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetAccountAllBillingOrdersReturnsOnCall(i int, result1 []datatypes.Billing_Order, result2 error) {
	fake.getAccountAllBillingOrdersMutex.Lock()
	defer fake.getAccountAllBillingOrdersMutex.Unlock()
	fake.GetAccountAllBillingOrdersStub = nil
	if fake.getAccountAllBillingOrdersReturnsOnCall == nil {
		fake.getAccountAllBillingOrdersReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Billing_Order
			result2 error
		})
	}
	fake.getAccountAllBillingOrdersReturnsOnCall[i] = struct {
		result1 []datatypes.Billing_Order
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetActiveAccountLicenses(arg1 string) ([]datatypes.Software_AccountLicense, error) {
	fake.getActiveAccountLicensesMutex.Lock()
	ret, specificReturn := fake.getActiveAccountLicensesReturnsOnCall[len(fake.getActiveAccountLicensesArgsForCall)]
	fake.getActiveAccountLicensesArgsForCall = append(fake.getActiveAccountLicensesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetActiveAccountLicensesStub
	fakeReturns := fake.getActiveAccountLicensesReturns
	fake.recordInvocation("GetActiveAccountLicenses", []interface{}{arg1})
	fake.getActiveAccountLicensesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountManager) GetActiveAccountLicensesCallCount() int {
	fake.getActiveAccountLicensesMutex.RLock()
	defer fake.getActiveAccountLicensesMutex.RUnlock()
	return len(fake.getActiveAccountLicensesArgsForCall)
}

func (fake *FakeAccountManager) GetActiveAccountLicensesCalls(stub func(string) ([]datatypes.Software_AccountLicense, error)) {
	fake.getActiveAccountLicensesMutex.Lock()
	defer fake.getActiveAccountLicensesMutex.Unlock()
	fake.GetActiveAccountLicensesStub = stub
}

func (fake *FakeAccountManager) GetActiveAccountLicensesArgsForCall(i int) string {
	fake.getActiveAccountLicensesMutex.RLock()
	defer fake.getActiveAccountLicensesMutex.RUnlock()
	argsForCall := fake.getActiveAccountLicensesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAccountManager) GetActiveAccountLicensesReturns(result1 []datatypes.Software_AccountLicense, result2 error) {
	fake.getActiveAccountLicensesMutex.Lock()
	defer fake.getActiveAccountLicensesMutex.Unlock()
	fake.GetActiveAccountLicensesStub = nil
	fake.getActiveAccountLicensesReturns = struct {
		result1 []datatypes.Software_AccountLicense
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetActiveAccountLicensesReturnsOnCall(i int, result1 []datatypes.Software_AccountLicense, result2 error) {
	fake.getActiveAccountLicensesMutex.Lock()
	defer fake.getActiveAccountLicensesMutex.Unlock()
	fake.GetActiveAccountLicensesStub = nil
	if fake.getActiveAccountLicensesReturnsOnCall == nil {
		fake.getActiveAccountLicensesReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Software_AccountLicense
			result2 error
		})
	}
	fake.getActiveAccountLicensesReturnsOnCall[i] = struct {
		result1 []datatypes.Software_AccountLicense
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetActiveVirtualLicenses(arg1 string) ([]datatypes.Software_VirtualLicense, error) {
	fake.getActiveVirtualLicensesMutex.Lock()
	ret, specificReturn := fake.getActiveVirtualLicensesReturnsOnCall[len(fake.getActiveVirtualLicensesArgsForCall)]
	fake.getActiveVirtualLicensesArgsForCall = append(fake.getActiveVirtualLicensesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetActiveVirtualLicensesStub
	fakeReturns := fake.getActiveVirtualLicensesReturns
	fake.recordInvocation("GetActiveVirtualLicenses", []interface{}{arg1})
	fake.getActiveVirtualLicensesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountManager) GetActiveVirtualLicensesCallCount() int {
	fake.getActiveVirtualLicensesMutex.RLock()
	defer fake.getActiveVirtualLicensesMutex.RUnlock()
	return len(fake.getActiveVirtualLicensesArgsForCall)
}

func (fake *FakeAccountManager) GetActiveVirtualLicensesCalls(stub func(string) ([]datatypes.Software_VirtualLicense, error)) {
	fake.getActiveVirtualLicensesMutex.Lock()
	defer fake.getActiveVirtualLicensesMutex.Unlock()
	fake.GetActiveVirtualLicensesStub = stub
}

func (fake *FakeAccountManager) GetActiveVirtualLicensesArgsForCall(i int) string {
	fake.getActiveVirtualLicensesMutex.RLock()
	defer fake.getActiveVirtualLicensesMutex.RUnlock()
	argsForCall := fake.getActiveVirtualLicensesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAccountManager) GetActiveVirtualLicensesReturns(result1 []datatypes.Software_VirtualLicense, result2 error) {
	fake.getActiveVirtualLicensesMutex.Lock()
	defer fake.getActiveVirtualLicensesMutex.Unlock()
	fake.GetActiveVirtualLicensesStub = nil
	fake.getActiveVirtualLicensesReturns = struct {
		result1 []datatypes.Software_VirtualLicense
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetActiveVirtualLicensesReturnsOnCall(i int, result1 []datatypes.Software_VirtualLicense, result2 error) {
	fake.getActiveVirtualLicensesMutex.Lock()
	defer fake.getActiveVirtualLicensesMutex.Unlock()
	fake.GetActiveVirtualLicensesStub = nil
	if fake.getActiveVirtualLicensesReturnsOnCall == nil {
		fake.getActiveVirtualLicensesReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Software_VirtualLicense
			result2 error
		})
	}
	fake.getActiveVirtualLicensesReturnsOnCall[i] = struct {
		result1 []datatypes.Software_VirtualLicense
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetBandwidthPoolDetail(arg1 int, arg2 string) (datatypes.Network_Bandwidth_Version1_Allotment, error) {
	fake.getBandwidthPoolDetailMutex.Lock()
	ret, specificReturn := fake.getBandwidthPoolDetailReturnsOnCall[len(fake.getBandwidthPoolDetailArgsForCall)]
	fake.getBandwidthPoolDetailArgsForCall = append(fake.getBandwidthPoolDetailArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.GetBandwidthPoolDetailStub
	fakeReturns := fake.getBandwidthPoolDetailReturns
	fake.recordInvocation("GetBandwidthPoolDetail", []interface{}{arg1, arg2})
	fake.getBandwidthPoolDetailMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountManager) GetBandwidthPoolDetailCallCount() int {
	fake.getBandwidthPoolDetailMutex.RLock()
	defer fake.getBandwidthPoolDetailMutex.RUnlock()
	return len(fake.getBandwidthPoolDetailArgsForCall)
}

func (fake *FakeAccountManager) GetBandwidthPoolDetailCalls(stub func(int, string) (datatypes.Network_Bandwidth_Version1_Allotment, error)) {
	fake.getBandwidthPoolDetailMutex.Lock()
	defer fake.getBandwidthPoolDetailMutex.Unlock()
	fake.GetBandwidthPoolDetailStub = stub
}

func (fake *FakeAccountManager) GetBandwidthPoolDetailArgsForCall(i int) (int, string) {
	fake.getBandwidthPoolDetailMutex.RLock()
	defer fake.getBandwidthPoolDetailMutex.RUnlock()
	argsForCall := fake.getBandwidthPoolDetailArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAccountManager) GetBandwidthPoolDetailReturns(result1 datatypes.Network_Bandwidth_Version1_Allotment, result2 error) {
	fake.getBandwidthPoolDetailMutex.Lock()
	defer fake.getBandwidthPoolDetailMutex.Unlock()
	fake.GetBandwidthPoolDetailStub = nil
	fake.getBandwidthPoolDetailReturns = struct {
		result1 datatypes.Network_Bandwidth_Version1_Allotment
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetBandwidthPoolDetailReturnsOnCall(i int, result1 datatypes.Network_Bandwidth_Version1_Allotment, result2 error) {
	fake.getBandwidthPoolDetailMutex.Lock()
	defer fake.getBandwidthPoolDetailMutex.Unlock()
	fake.GetBandwidthPoolDetailStub = nil
	if fake.getBandwidthPoolDetailReturnsOnCall == nil {
		fake.getBandwidthPoolDetailReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_Bandwidth_Version1_Allotment
			result2 error
		})
	}
	fake.getBandwidthPoolDetailReturnsOnCall[i] = struct {
		result1 datatypes.Network_Bandwidth_Version1_Allotment
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetBandwidthPoolServers(arg1 int) (uint, error) {
	fake.getBandwidthPoolServersMutex.Lock()
	ret, specificReturn := fake.getBandwidthPoolServersReturnsOnCall[len(fake.getBandwidthPoolServersArgsForCall)]
	fake.getBandwidthPoolServersArgsForCall = append(fake.getBandwidthPoolServersArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.GetBandwidthPoolServersStub
	fakeReturns := fake.getBandwidthPoolServersReturns
	fake.recordInvocation("GetBandwidthPoolServers", []interface{}{arg1})
	fake.getBandwidthPoolServersMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountManager) GetBandwidthPoolServersCallCount() int {
	fake.getBandwidthPoolServersMutex.RLock()
	defer fake.getBandwidthPoolServersMutex.RUnlock()
	return len(fake.getBandwidthPoolServersArgsForCall)
}

func (fake *FakeAccountManager) GetBandwidthPoolServersCalls(stub func(int) (uint, error)) {
	fake.getBandwidthPoolServersMutex.Lock()
	defer fake.getBandwidthPoolServersMutex.Unlock()
	fake.GetBandwidthPoolServersStub = stub
}

func (fake *FakeAccountManager) GetBandwidthPoolServersArgsForCall(i int) int {
	fake.getBandwidthPoolServersMutex.RLock()
	defer fake.getBandwidthPoolServersMutex.RUnlock()
	argsForCall := fake.getBandwidthPoolServersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAccountManager) GetBandwidthPoolServersReturns(result1 uint, result2 error) {
	fake.getBandwidthPoolServersMutex.Lock()
	defer fake.getBandwidthPoolServersMutex.Unlock()
	fake.GetBandwidthPoolServersStub = nil
	fake.getBandwidthPoolServersReturns = struct {
		result1 uint
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetBandwidthPoolServersReturnsOnCall(i int, result1 uint, result2 error) {
	fake.getBandwidthPoolServersMutex.Lock()
	defer fake.getBandwidthPoolServersMutex.Unlock()
	fake.GetBandwidthPoolServersStub = nil
	if fake.getBandwidthPoolServersReturnsOnCall == nil {
		fake.getBandwidthPoolServersReturnsOnCall = make(map[int]struct {
			result1 uint
			result2 error
		})
	}
	fake.getBandwidthPoolServersReturnsOnCall[i] = struct {
		result1 uint
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetBandwidthPools() ([]datatypes.Network_Bandwidth_Version1_Allotment, error) {
	fake.getBandwidthPoolsMutex.Lock()
	ret, specificReturn := fake.getBandwidthPoolsReturnsOnCall[len(fake.getBandwidthPoolsArgsForCall)]
	fake.getBandwidthPoolsArgsForCall = append(fake.getBandwidthPoolsArgsForCall, struct {
	}{})
	stub := fake.GetBandwidthPoolsStub
	fakeReturns := fake.getBandwidthPoolsReturns
	fake.recordInvocation("GetBandwidthPools", []interface{}{})
	fake.getBandwidthPoolsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountManager) GetBandwidthPoolsCallCount() int {
	fake.getBandwidthPoolsMutex.RLock()
	defer fake.getBandwidthPoolsMutex.RUnlock()
	return len(fake.getBandwidthPoolsArgsForCall)
}

func (fake *FakeAccountManager) GetBandwidthPoolsCalls(stub func() ([]datatypes.Network_Bandwidth_Version1_Allotment, error)) {
	fake.getBandwidthPoolsMutex.Lock()
	defer fake.getBandwidthPoolsMutex.Unlock()
	fake.GetBandwidthPoolsStub = stub
}

func (fake *FakeAccountManager) GetBandwidthPoolsReturns(result1 []datatypes.Network_Bandwidth_Version1_Allotment, result2 error) {
	fake.getBandwidthPoolsMutex.Lock()
	defer fake.getBandwidthPoolsMutex.Unlock()
	fake.GetBandwidthPoolsStub = nil
	fake.getBandwidthPoolsReturns = struct {
		result1 []datatypes.Network_Bandwidth_Version1_Allotment
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetBandwidthPoolsReturnsOnCall(i int, result1 []datatypes.Network_Bandwidth_Version1_Allotment, result2 error) {
	fake.getBandwidthPoolsMutex.Lock()
	defer fake.getBandwidthPoolsMutex.Unlock()
	fake.GetBandwidthPoolsStub = nil
	if fake.getBandwidthPoolsReturnsOnCall == nil {
		fake.getBandwidthPoolsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Network_Bandwidth_Version1_Allotment
			result2 error
		})
	}
	fake.getBandwidthPoolsReturnsOnCall[i] = struct {
		result1 []datatypes.Network_Bandwidth_Version1_Allotment
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetBillingItems(arg1 string, arg2 string) ([]datatypes.Billing_Item, error) {
	fake.getBillingItemsMutex.Lock()
	ret, specificReturn := fake.getBillingItemsReturnsOnCall[len(fake.getBillingItemsArgsForCall)]
	fake.getBillingItemsArgsForCall = append(fake.getBillingItemsArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetBillingItemsStub
	fakeReturns := fake.getBillingItemsReturns
	fake.recordInvocation("GetBillingItems", []interface{}{arg1, arg2})
	fake.getBillingItemsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountManager) GetBillingItemsCallCount() int {
	fake.getBillingItemsMutex.RLock()
	defer fake.getBillingItemsMutex.RUnlock()
	return len(fake.getBillingItemsArgsForCall)
}

func (fake *FakeAccountManager) GetBillingItemsCalls(stub func(string, string) ([]datatypes.Billing_Item, error)) {
	fake.getBillingItemsMutex.Lock()
	defer fake.getBillingItemsMutex.Unlock()
	fake.GetBillingItemsStub = stub
}

func (fake *FakeAccountManager) GetBillingItemsArgsForCall(i int) (string, string) {
	fake.getBillingItemsMutex.RLock()
	defer fake.getBillingItemsMutex.RUnlock()
	argsForCall := fake.getBillingItemsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAccountManager) GetBillingItemsReturns(result1 []datatypes.Billing_Item, result2 error) {
	fake.getBillingItemsMutex.Lock()
	defer fake.getBillingItemsMutex.Unlock()
	fake.GetBillingItemsStub = nil
	fake.getBillingItemsReturns = struct {
		result1 []datatypes.Billing_Item
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetBillingItemsReturnsOnCall(i int, result1 []datatypes.Billing_Item, result2 error) {
	fake.getBillingItemsMutex.Lock()
	defer fake.getBillingItemsMutex.Unlock()
	fake.GetBillingItemsStub = nil
	if fake.getBillingItemsReturnsOnCall == nil {
		fake.getBillingItemsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Billing_Item
			result2 error
		})
	}
	fake.getBillingItemsReturnsOnCall[i] = struct {
		result1 []datatypes.Billing_Item
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetEventDetail(arg1 int, arg2 string) (datatypes.Notification_Occurrence_Event, error) {
	fake.getEventDetailMutex.Lock()
	ret, specificReturn := fake.getEventDetailReturnsOnCall[len(fake.getEventDetailArgsForCall)]
	fake.getEventDetailArgsForCall = append(fake.getEventDetailArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.GetEventDetailStub
	fakeReturns := fake.getEventDetailReturns
	fake.recordInvocation("GetEventDetail", []interface{}{arg1, arg2})
	fake.getEventDetailMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountManager) GetEventDetailCallCount() int {
	fake.getEventDetailMutex.RLock()
	defer fake.getEventDetailMutex.RUnlock()
	return len(fake.getEventDetailArgsForCall)
}

func (fake *FakeAccountManager) GetEventDetailCalls(stub func(int, string) (datatypes.Notification_Occurrence_Event, error)) {
	fake.getEventDetailMutex.Lock()
	defer fake.getEventDetailMutex.Unlock()
	fake.GetEventDetailStub = stub
}

func (fake *FakeAccountManager) GetEventDetailArgsForCall(i int) (int, string) {
	fake.getEventDetailMutex.RLock()
	defer fake.getEventDetailMutex.RUnlock()
	argsForCall := fake.getEventDetailArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAccountManager) GetEventDetailReturns(result1 datatypes.Notification_Occurrence_Event, result2 error) {
	fake.getEventDetailMutex.Lock()
	defer fake.getEventDetailMutex.Unlock()
	fake.GetEventDetailStub = nil
	fake.getEventDetailReturns = struct {
		result1 datatypes.Notification_Occurrence_Event
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetEventDetailReturnsOnCall(i int, result1 datatypes.Notification_Occurrence_Event, result2 error) {
	fake.getEventDetailMutex.Lock()
	defer fake.getEventDetailMutex.Unlock()
	fake.GetEventDetailStub = nil
	if fake.getEventDetailReturnsOnCall == nil {
		fake.getEventDetailReturnsOnCall = make(map[int]struct {
			result1 datatypes.Notification_Occurrence_Event
			result2 error
		})
	}
	fake.getEventDetailReturnsOnCall[i] = struct {
		result1 datatypes.Notification_Occurrence_Event
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetEvents(arg1 string, arg2 string, arg3 string) ([]datatypes.Notification_Occurrence_Event, error) {
	fake.getEventsMutex.Lock()
	ret, specificReturn := fake.getEventsReturnsOnCall[len(fake.getEventsArgsForCall)]
	fake.getEventsArgsForCall = append(fake.getEventsArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetEventsStub
	fakeReturns := fake.getEventsReturns
	fake.recordInvocation("GetEvents", []interface{}{arg1, arg2, arg3})
	fake.getEventsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountManager) GetEventsCallCount() int {
	fake.getEventsMutex.RLock()
	defer fake.getEventsMutex.RUnlock()
	return len(fake.getEventsArgsForCall)
}

func (fake *FakeAccountManager) GetEventsCalls(stub func(string, string, string) ([]datatypes.Notification_Occurrence_Event, error)) {
	fake.getEventsMutex.Lock()
	defer fake.getEventsMutex.Unlock()
	fake.GetEventsStub = stub
}

func (fake *FakeAccountManager) GetEventsArgsForCall(i int) (string, string, string) {
	fake.getEventsMutex.RLock()
	defer fake.getEventsMutex.RUnlock()
	argsForCall := fake.getEventsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAccountManager) GetEventsReturns(result1 []datatypes.Notification_Occurrence_Event, result2 error) {
	fake.getEventsMutex.Lock()
	defer fake.getEventsMutex.Unlock()
	fake.GetEventsStub = nil
	fake.getEventsReturns = struct {
		result1 []datatypes.Notification_Occurrence_Event
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetEventsReturnsOnCall(i int, result1 []datatypes.Notification_Occurrence_Event, result2 error) {
	fake.getEventsMutex.Lock()
	defer fake.getEventsMutex.Unlock()
	fake.GetEventsStub = nil
	if fake.getEventsReturnsOnCall == nil {
		fake.getEventsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Notification_Occurrence_Event
			result2 error
		})
	}
	fake.getEventsReturnsOnCall[i] = struct {
		result1 []datatypes.Notification_Occurrence_Event
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetInvoiceDetail(arg1 int, arg2 string) ([]datatypes.Billing_Invoice_Item, error) {
	fake.getInvoiceDetailMutex.Lock()
	ret, specificReturn := fake.getInvoiceDetailReturnsOnCall[len(fake.getInvoiceDetailArgsForCall)]
	fake.getInvoiceDetailArgsForCall = append(fake.getInvoiceDetailArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.GetInvoiceDetailStub
	fakeReturns := fake.getInvoiceDetailReturns
	fake.recordInvocation("GetInvoiceDetail", []interface{}{arg1, arg2})
	fake.getInvoiceDetailMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountManager) GetInvoiceDetailCallCount() int {
	fake.getInvoiceDetailMutex.RLock()
	defer fake.getInvoiceDetailMutex.RUnlock()
	return len(fake.getInvoiceDetailArgsForCall)
}

func (fake *FakeAccountManager) GetInvoiceDetailCalls(stub func(int, string) ([]datatypes.Billing_Invoice_Item, error)) {
	fake.getInvoiceDetailMutex.Lock()
	defer fake.getInvoiceDetailMutex.Unlock()
	fake.GetInvoiceDetailStub = stub
}

func (fake *FakeAccountManager) GetInvoiceDetailArgsForCall(i int) (int, string) {
	fake.getInvoiceDetailMutex.RLock()
	defer fake.getInvoiceDetailMutex.RUnlock()
	argsForCall := fake.getInvoiceDetailArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAccountManager) GetInvoiceDetailReturns(result1 []datatypes.Billing_Invoice_Item, result2 error) {
	fake.getInvoiceDetailMutex.Lock()
	defer fake.getInvoiceDetailMutex.Unlock()
	fake.GetInvoiceDetailStub = nil
	fake.getInvoiceDetailReturns = struct {
		result1 []datatypes.Billing_Invoice_Item
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetInvoiceDetailReturnsOnCall(i int, result1 []datatypes.Billing_Invoice_Item, result2 error) {
	fake.getInvoiceDetailMutex.Lock()
	defer fake.getInvoiceDetailMutex.Unlock()
	fake.GetInvoiceDetailStub = nil
	if fake.getInvoiceDetailReturnsOnCall == nil {
		fake.getInvoiceDetailReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Billing_Invoice_Item
			result2 error
		})
	}
	fake.getInvoiceDetailReturnsOnCall[i] = struct {
		result1 []datatypes.Billing_Invoice_Item
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetInvoices(arg1 int, arg2 bool, arg3 bool) ([]datatypes.Billing_Invoice, error) {
	fake.getInvoicesMutex.Lock()
	ret, specificReturn := fake.getInvoicesReturnsOnCall[len(fake.getInvoicesArgsForCall)]
	fake.getInvoicesArgsForCall = append(fake.getInvoicesArgsForCall, struct {
		arg1 int
		arg2 bool
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.GetInvoicesStub
	fakeReturns := fake.getInvoicesReturns
	fake.recordInvocation("GetInvoices", []interface{}{arg1, arg2, arg3})
	fake.getInvoicesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountManager) GetInvoicesCallCount() int {
	fake.getInvoicesMutex.RLock()
	defer fake.getInvoicesMutex.RUnlock()
	return len(fake.getInvoicesArgsForCall)
}

func (fake *FakeAccountManager) GetInvoicesCalls(stub func(int, bool, bool) ([]datatypes.Billing_Invoice, error)) {
	fake.getInvoicesMutex.Lock()
	defer fake.getInvoicesMutex.Unlock()
	fake.GetInvoicesStub = stub
}

func (fake *FakeAccountManager) GetInvoicesArgsForCall(i int) (int, bool, bool) {
	fake.getInvoicesMutex.RLock()
	defer fake.getInvoicesMutex.RUnlock()
	argsForCall := fake.getInvoicesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAccountManager) GetInvoicesReturns(result1 []datatypes.Billing_Invoice, result2 error) {
	fake.getInvoicesMutex.Lock()
	defer fake.getInvoicesMutex.Unlock()
	fake.GetInvoicesStub = nil
	fake.getInvoicesReturns = struct {
		result1 []datatypes.Billing_Invoice
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetInvoicesReturnsOnCall(i int, result1 []datatypes.Billing_Invoice, result2 error) {
	fake.getInvoicesMutex.Lock()
	defer fake.getInvoicesMutex.Unlock()
	fake.GetInvoicesStub = nil
	if fake.getInvoicesReturnsOnCall == nil {
		fake.getInvoicesReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Billing_Invoice
			result2 error
		})
	}
	fake.getInvoicesReturnsOnCall[i] = struct {
		result1 []datatypes.Billing_Invoice
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetItemDetail(arg1 int, arg2 string) (datatypes.Billing_Item, error) {
	fake.getItemDetailMutex.Lock()
	ret, specificReturn := fake.getItemDetailReturnsOnCall[len(fake.getItemDetailArgsForCall)]
	fake.getItemDetailArgsForCall = append(fake.getItemDetailArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.GetItemDetailStub
	fakeReturns := fake.getItemDetailReturns
	fake.recordInvocation("GetItemDetail", []interface{}{arg1, arg2})
	fake.getItemDetailMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountManager) GetItemDetailCallCount() int {
	fake.getItemDetailMutex.RLock()
	defer fake.getItemDetailMutex.RUnlock()
	return len(fake.getItemDetailArgsForCall)
}

func (fake *FakeAccountManager) GetItemDetailCalls(stub func(int, string) (datatypes.Billing_Item, error)) {
	fake.getItemDetailMutex.Lock()
	defer fake.getItemDetailMutex.Unlock()
	fake.GetItemDetailStub = stub
}

func (fake *FakeAccountManager) GetItemDetailArgsForCall(i int) (int, string) {
	fake.getItemDetailMutex.RLock()
	defer fake.getItemDetailMutex.RUnlock()
	argsForCall := fake.getItemDetailArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAccountManager) GetItemDetailReturns(result1 datatypes.Billing_Item, result2 error) {
	fake.getItemDetailMutex.Lock()
	defer fake.getItemDetailMutex.Unlock()
	fake.GetItemDetailStub = nil
	fake.getItemDetailReturns = struct {
		result1 datatypes.Billing_Item
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetItemDetailReturnsOnCall(i int, result1 datatypes.Billing_Item, result2 error) {
	fake.getItemDetailMutex.Lock()
	defer fake.getItemDetailMutex.Unlock()
	fake.GetItemDetailStub = nil
	if fake.getItemDetailReturnsOnCall == nil {
		fake.getItemDetailReturnsOnCall = make(map[int]struct {
			result1 datatypes.Billing_Item
			result2 error
		})
	}
	fake.getItemDetailReturnsOnCall[i] = struct {
		result1 datatypes.Billing_Item
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetPostProvisioningHooks(arg1 string) ([]datatypes.Provisioning_Hook, error) {
	fake.getPostProvisioningHooksMutex.Lock()
	ret, specificReturn := fake.getPostProvisioningHooksReturnsOnCall[len(fake.getPostProvisioningHooksArgsForCall)]
	fake.getPostProvisioningHooksArgsForCall = append(fake.getPostProvisioningHooksArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetPostProvisioningHooksStub
	fakeReturns := fake.getPostProvisioningHooksReturns
	fake.recordInvocation("GetPostProvisioningHooks", []interface{}{arg1})
	fake.getPostProvisioningHooksMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountManager) GetPostProvisioningHooksCallCount() int {
	fake.getPostProvisioningHooksMutex.RLock()
	defer fake.getPostProvisioningHooksMutex.RUnlock()
	return len(fake.getPostProvisioningHooksArgsForCall)
}

func (fake *FakeAccountManager) GetPostProvisioningHooksCalls(stub func(string) ([]datatypes.Provisioning_Hook, error)) {
	fake.getPostProvisioningHooksMutex.Lock()
	defer fake.getPostProvisioningHooksMutex.Unlock()
	fake.GetPostProvisioningHooksStub = stub
}

func (fake *FakeAccountManager) GetPostProvisioningHooksArgsForCall(i int) string {
	fake.getPostProvisioningHooksMutex.RLock()
	defer fake.getPostProvisioningHooksMutex.RUnlock()
	argsForCall := fake.getPostProvisioningHooksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAccountManager) GetPostProvisioningHooksReturns(result1 []datatypes.Provisioning_Hook, result2 error) {
	fake.getPostProvisioningHooksMutex.Lock()
	defer fake.getPostProvisioningHooksMutex.Unlock()
	fake.GetPostProvisioningHooksStub = nil
	fake.getPostProvisioningHooksReturns = struct {
		result1 []datatypes.Provisioning_Hook
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetPostProvisioningHooksReturnsOnCall(i int, result1 []datatypes.Provisioning_Hook, result2 error) {
	fake.getPostProvisioningHooksMutex.Lock()
	defer fake.getPostProvisioningHooksMutex.Unlock()
	fake.GetPostProvisioningHooksStub = nil
	if fake.getPostProvisioningHooksReturnsOnCall == nil {
		fake.getPostProvisioningHooksReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Provisioning_Hook
			result2 error
		})
	}
	fake.getPostProvisioningHooksReturnsOnCall[i] = struct {
		result1 []datatypes.Provisioning_Hook
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetSummary(arg1 string) (datatypes.Account, error) {
	fake.getSummaryMutex.Lock()
	ret, specificReturn := fake.getSummaryReturnsOnCall[len(fake.getSummaryArgsForCall)]
	fake.getSummaryArgsForCall = append(fake.getSummaryArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetSummaryStub
	fakeReturns := fake.getSummaryReturns
	fake.recordInvocation("GetSummary", []interface{}{arg1})
	fake.getSummaryMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountManager) GetSummaryCallCount() int {
	fake.getSummaryMutex.RLock()
	defer fake.getSummaryMutex.RUnlock()
	return len(fake.getSummaryArgsForCall)
}

func (fake *FakeAccountManager) GetSummaryCalls(stub func(string) (datatypes.Account, error)) {
	fake.getSummaryMutex.Lock()
	defer fake.getSummaryMutex.Unlock()
	fake.GetSummaryStub = stub
}

func (fake *FakeAccountManager) GetSummaryArgsForCall(i int) string {
	fake.getSummaryMutex.RLock()
	defer fake.getSummaryMutex.RUnlock()
	argsForCall := fake.getSummaryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAccountManager) GetSummaryReturns(result1 datatypes.Account, result2 error) {
	fake.getSummaryMutex.Lock()
	defer fake.getSummaryMutex.Unlock()
	fake.GetSummaryStub = nil
	fake.getSummaryReturns = struct {
		result1 datatypes.Account
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetSummaryReturnsOnCall(i int, result1 datatypes.Account, result2 error) {
	fake.getSummaryMutex.Lock()
	defer fake.getSummaryMutex.Unlock()
	fake.GetSummaryStub = nil
	if fake.getSummaryReturnsOnCall == nil {
		fake.getSummaryReturnsOnCall = make(map[int]struct {
			result1 datatypes.Account
			result2 error
		})
	}
	fake.getSummaryReturnsOnCall[i] = struct {
		result1 datatypes.Account
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetUpgradeRequests(arg1 string, arg2 int) ([]datatypes.Product_Upgrade_Request, error) {
	fake.getUpgradeRequestsMutex.Lock()
	ret, specificReturn := fake.getUpgradeRequestsReturnsOnCall[len(fake.getUpgradeRequestsArgsForCall)]
	fake.getUpgradeRequestsArgsForCall = append(fake.getUpgradeRequestsArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	stub := fake.GetUpgradeRequestsStub
	fakeReturns := fake.getUpgradeRequestsReturns
	fake.recordInvocation("GetUpgradeRequests", []interface{}{arg1, arg2})
	fake.getUpgradeRequestsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountManager) GetUpgradeRequestsCallCount() int {
	fake.getUpgradeRequestsMutex.RLock()
	defer fake.getUpgradeRequestsMutex.RUnlock()
	return len(fake.getUpgradeRequestsArgsForCall)
}

func (fake *FakeAccountManager) GetUpgradeRequestsCalls(stub func(string, int) ([]datatypes.Product_Upgrade_Request, error)) {
	fake.getUpgradeRequestsMutex.Lock()
	defer fake.getUpgradeRequestsMutex.Unlock()
	fake.GetUpgradeRequestsStub = stub
}

func (fake *FakeAccountManager) GetUpgradeRequestsArgsForCall(i int) (string, int) {
	fake.getUpgradeRequestsMutex.RLock()
	defer fake.getUpgradeRequestsMutex.RUnlock()
	argsForCall := fake.getUpgradeRequestsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAccountManager) GetUpgradeRequestsReturns(result1 []datatypes.Product_Upgrade_Request, result2 error) {
	fake.getUpgradeRequestsMutex.Lock()
	defer fake.getUpgradeRequestsMutex.Unlock()
	fake.GetUpgradeRequestsStub = nil
	fake.getUpgradeRequestsReturns = struct {
		result1 []datatypes.Product_Upgrade_Request
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetUpgradeRequestsReturnsOnCall(i int, result1 []datatypes.Product_Upgrade_Request, result2 error) {
	fake.getUpgradeRequestsMutex.Lock()
	defer fake.getUpgradeRequestsMutex.Unlock()
	fake.GetUpgradeRequestsStub = nil
	if fake.getUpgradeRequestsReturnsOnCall == nil {
		fake.getUpgradeRequestsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Product_Upgrade_Request
			result2 error
		})
	}
	fake.getUpgradeRequestsReturnsOnCall[i] = struct {
		result1 []datatypes.Product_Upgrade_Request
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.ackEventMutex.RLock()
	defer fake.ackEventMutex.RUnlock()
	fake.cancelItemMutex.RLock()
	defer fake.cancelItemMutex.RUnlock()
	fake.createProvisioningScriptMutex.RLock()
	defer fake.createProvisioningScriptMutex.RUnlock()
	fake.deleteProvisioningScriptMutex.RLock()
	defer fake.deleteProvisioningScriptMutex.RUnlock()
	fake.getAccountAllBillingOrdersMutex.RLock()
	defer fake.getAccountAllBillingOrdersMutex.RUnlock()
	fake.getActiveAccountLicensesMutex.RLock()
	defer fake.getActiveAccountLicensesMutex.RUnlock()
	fake.getActiveVirtualLicensesMutex.RLock()
	defer fake.getActiveVirtualLicensesMutex.RUnlock()
	fake.getBandwidthPoolDetailMutex.RLock()
	defer fake.getBandwidthPoolDetailMutex.RUnlock()
	fake.getBandwidthPoolServersMutex.RLock()
	defer fake.getBandwidthPoolServersMutex.RUnlock()
	fake.getBandwidthPoolsMutex.RLock()
	defer fake.getBandwidthPoolsMutex.RUnlock()
	fake.getBillingItemsMutex.RLock()
	defer fake.getBillingItemsMutex.RUnlock()
	fake.getEventDetailMutex.RLock()
	defer fake.getEventDetailMutex.RUnlock()
	fake.getEventsMutex.RLock()
	defer fake.getEventsMutex.RUnlock()
	fake.getInvoiceDetailMutex.RLock()
	defer fake.getInvoiceDetailMutex.RUnlock()
	fake.getInvoicesMutex.RLock()
	defer fake.getInvoicesMutex.RUnlock()
	fake.getItemDetailMutex.RLock()
	defer fake.getItemDetailMutex.RUnlock()
	fake.getPostProvisioningHooksMutex.RLock()
	defer fake.getPostProvisioningHooksMutex.RUnlock()
	fake.getSummaryMutex.RLock()
	defer fake.getSummaryMutex.RUnlock()
	fake.getUpgradeRequestsMutex.RLock()
	defer fake.getUpgradeRequestsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeAccountManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ managers.AccountManager = new(FakeAccountManager)
