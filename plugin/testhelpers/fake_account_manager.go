// Code generated by counterfeiter. DO NOT EDIT.
package testhelpers

import (
	"sync"

	"github.com/softlayer/softlayer-go/datatypes"
	"github.ibm.com/SoftLayer/softlayer-cli/plugin/managers"
)

type FakeAccountManager struct {
	CancelItemStub        func(int) error
	cancelItemMutex       sync.RWMutex
	cancelItemArgsForCall []struct {
		arg1 int
	}
	cancelItemReturns struct {
		result1 error
	}
	cancelItemReturnsOnCall map[int]struct {
		result1 error
	}
	GetActiveAccountLicensesStub        func(string) ([]datatypes.Software_AccountLicense, error)
	getActiveAccountLicensesMutex       sync.RWMutex
	getActiveAccountLicensesArgsForCall []struct {
		arg1 string
	}
	getActiveAccountLicensesReturns struct {
		result1 []datatypes.Software_AccountLicense
		result2 error
	}
	getActiveAccountLicensesReturnsOnCall map[int]struct {
		result1 []datatypes.Software_AccountLicense
		result2 error
	}
	GetActiveVirtualLicensesStub        func(string) ([]datatypes.Software_VirtualLicense, error)
	getActiveVirtualLicensesMutex       sync.RWMutex
	getActiveVirtualLicensesArgsForCall []struct {
		arg1 string
	}
	getActiveVirtualLicensesReturns struct {
		result1 []datatypes.Software_VirtualLicense
		result2 error
	}
	getActiveVirtualLicensesReturnsOnCall map[int]struct {
		result1 []datatypes.Software_VirtualLicense
		result2 error
	}
	GetBandwidthPoolServersStub        func(int) (int, error)
	getBandwidthPoolServersMutex       sync.RWMutex
	getBandwidthPoolServersArgsForCall []struct {
		arg1 int
	}
	getBandwidthPoolServersReturns struct {
		result1 int
		result2 error
	}
	getBandwidthPoolServersReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	GetBandwidthPoolsStub        func() ([]datatypes.Network_Bandwidth_Version1_Allotment, error)
	getBandwidthPoolsMutex       sync.RWMutex
	getBandwidthPoolsArgsForCall []struct {
	}
	getBandwidthPoolsReturns struct {
		result1 []datatypes.Network_Bandwidth_Version1_Allotment
		result2 error
	}
	getBandwidthPoolsReturnsOnCall map[int]struct {
		result1 []datatypes.Network_Bandwidth_Version1_Allotment
		result2 error
	}
	GetBillingItemsStub        func(string) ([]datatypes.Billing_Item, error)
	getBillingItemsMutex       sync.RWMutex
	getBillingItemsArgsForCall []struct {
		arg1 string
	}
	getBillingItemsReturns struct {
		result1 []datatypes.Billing_Item
		result2 error
	}
	getBillingItemsReturnsOnCall map[int]struct {
		result1 []datatypes.Billing_Item
		result2 error
	}
	GetEventDetailStub        func(int, string) (datatypes.Notification_Occurrence_Event, error)
	getEventDetailMutex       sync.RWMutex
	getEventDetailArgsForCall []struct {
		arg1 int
		arg2 string
	}
	getEventDetailReturns struct {
		result1 datatypes.Notification_Occurrence_Event
		result2 error
	}
	getEventDetailReturnsOnCall map[int]struct {
		result1 datatypes.Notification_Occurrence_Event
		result2 error
	}
	GetEventsStub        func(string, string, string) ([]datatypes.Notification_Occurrence_Event, error)
	getEventsMutex       sync.RWMutex
	getEventsArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	getEventsReturns struct {
		result1 []datatypes.Notification_Occurrence_Event
		result2 error
	}
	getEventsReturnsOnCall map[int]struct {
		result1 []datatypes.Notification_Occurrence_Event
		result2 error
	}
	GetInvoiceDetailStub        func(int, string) ([]datatypes.Billing_Invoice_Item, error)
	getInvoiceDetailMutex       sync.RWMutex
	getInvoiceDetailArgsForCall []struct {
		arg1 int
		arg2 string
	}
	getInvoiceDetailReturns struct {
		result1 []datatypes.Billing_Invoice_Item
		result2 error
	}
	getInvoiceDetailReturnsOnCall map[int]struct {
		result1 []datatypes.Billing_Invoice_Item
		result2 error
	}
	GetInvoicesStub        func(int, bool, bool) ([]datatypes.Billing_Invoice, error)
	getInvoicesMutex       sync.RWMutex
	getInvoicesArgsForCall []struct {
		arg1 int
		arg2 bool
		arg3 bool
	}
	getInvoicesReturns struct {
		result1 []datatypes.Billing_Invoice
		result2 error
	}
	getInvoicesReturnsOnCall map[int]struct {
		result1 []datatypes.Billing_Invoice
		result2 error
	}
	GetItemDetailStub        func(int, string) (datatypes.Billing_Item, error)
	getItemDetailMutex       sync.RWMutex
	getItemDetailArgsForCall []struct {
		arg1 int
		arg2 string
	}
	getItemDetailReturns struct {
		result1 datatypes.Billing_Item
		result2 error
	}
	getItemDetailReturnsOnCall map[int]struct {
		result1 datatypes.Billing_Item
		result2 error
	}
	SummaryByDatacenterStub        func() (map[string]map[string]int, error)
	summaryByDatacenterMutex       sync.RWMutex
	summaryByDatacenterArgsForCall []struct {
	}
	summaryByDatacenterReturns struct {
		result1 map[string]map[string]int
		result2 error
	}
	summaryByDatacenterReturnsOnCall map[int]struct {
		result1 map[string]map[string]int
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeAccountManager) CancelItem(arg1 int) error {
	fake.cancelItemMutex.Lock()
	ret, specificReturn := fake.cancelItemReturnsOnCall[len(fake.cancelItemArgsForCall)]
	fake.cancelItemArgsForCall = append(fake.cancelItemArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.CancelItemStub
	fakeReturns := fake.cancelItemReturns
	fake.recordInvocation("CancelItem", []interface{}{arg1})
	fake.cancelItemMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAccountManager) CancelItemCallCount() int {
	fake.cancelItemMutex.RLock()
	defer fake.cancelItemMutex.RUnlock()
	return len(fake.cancelItemArgsForCall)
}

func (fake *FakeAccountManager) CancelItemCalls(stub func(int) error) {
	fake.cancelItemMutex.Lock()
	defer fake.cancelItemMutex.Unlock()
	fake.CancelItemStub = stub
}

func (fake *FakeAccountManager) CancelItemArgsForCall(i int) int {
	fake.cancelItemMutex.RLock()
	defer fake.cancelItemMutex.RUnlock()
	argsForCall := fake.cancelItemArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAccountManager) CancelItemReturns(result1 error) {
	fake.cancelItemMutex.Lock()
	defer fake.cancelItemMutex.Unlock()
	fake.CancelItemStub = nil
	fake.cancelItemReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAccountManager) CancelItemReturnsOnCall(i int, result1 error) {
	fake.cancelItemMutex.Lock()
	defer fake.cancelItemMutex.Unlock()
	fake.CancelItemStub = nil
	if fake.cancelItemReturnsOnCall == nil {
		fake.cancelItemReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelItemReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAccountManager) GetActiveAccountLicenses(arg1 string) ([]datatypes.Software_AccountLicense, error) {
	fake.getActiveAccountLicensesMutex.Lock()
	ret, specificReturn := fake.getActiveAccountLicensesReturnsOnCall[len(fake.getActiveAccountLicensesArgsForCall)]
	fake.getActiveAccountLicensesArgsForCall = append(fake.getActiveAccountLicensesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetActiveAccountLicensesStub
	fakeReturns := fake.getActiveAccountLicensesReturns
	fake.recordInvocation("GetActiveAccountLicenses", []interface{}{arg1})
	fake.getActiveAccountLicensesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountManager) GetActiveAccountLicensesCallCount() int {
	fake.getActiveAccountLicensesMutex.RLock()
	defer fake.getActiveAccountLicensesMutex.RUnlock()
	return len(fake.getActiveAccountLicensesArgsForCall)
}

func (fake *FakeAccountManager) GetActiveAccountLicensesCalls(stub func(string) ([]datatypes.Software_AccountLicense, error)) {
	fake.getActiveAccountLicensesMutex.Lock()
	defer fake.getActiveAccountLicensesMutex.Unlock()
	fake.GetActiveAccountLicensesStub = stub
}

func (fake *FakeAccountManager) GetActiveAccountLicensesArgsForCall(i int) string {
	fake.getActiveAccountLicensesMutex.RLock()
	defer fake.getActiveAccountLicensesMutex.RUnlock()
	argsForCall := fake.getActiveAccountLicensesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAccountManager) GetActiveAccountLicensesReturns(result1 []datatypes.Software_AccountLicense, result2 error) {
	fake.getActiveAccountLicensesMutex.Lock()
	defer fake.getActiveAccountLicensesMutex.Unlock()
	fake.GetActiveAccountLicensesStub = nil
	fake.getActiveAccountLicensesReturns = struct {
		result1 []datatypes.Software_AccountLicense
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetActiveAccountLicensesReturnsOnCall(i int, result1 []datatypes.Software_AccountLicense, result2 error) {
	fake.getActiveAccountLicensesMutex.Lock()
	defer fake.getActiveAccountLicensesMutex.Unlock()
	fake.GetActiveAccountLicensesStub = nil
	if fake.getActiveAccountLicensesReturnsOnCall == nil {
		fake.getActiveAccountLicensesReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Software_AccountLicense
			result2 error
		})
	}
	fake.getActiveAccountLicensesReturnsOnCall[i] = struct {
		result1 []datatypes.Software_AccountLicense
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetActiveVirtualLicenses(arg1 string) ([]datatypes.Software_VirtualLicense, error) {
	fake.getActiveVirtualLicensesMutex.Lock()
	ret, specificReturn := fake.getActiveVirtualLicensesReturnsOnCall[len(fake.getActiveVirtualLicensesArgsForCall)]
	fake.getActiveVirtualLicensesArgsForCall = append(fake.getActiveVirtualLicensesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetActiveVirtualLicensesStub
	fakeReturns := fake.getActiveVirtualLicensesReturns
	fake.recordInvocation("GetActiveVirtualLicenses", []interface{}{arg1})
	fake.getActiveVirtualLicensesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountManager) GetActiveVirtualLicensesCallCount() int {
	fake.getActiveVirtualLicensesMutex.RLock()
	defer fake.getActiveVirtualLicensesMutex.RUnlock()
	return len(fake.getActiveVirtualLicensesArgsForCall)
}

func (fake *FakeAccountManager) GetActiveVirtualLicensesCalls(stub func(string) ([]datatypes.Software_VirtualLicense, error)) {
	fake.getActiveVirtualLicensesMutex.Lock()
	defer fake.getActiveVirtualLicensesMutex.Unlock()
	fake.GetActiveVirtualLicensesStub = stub
}

func (fake *FakeAccountManager) GetActiveVirtualLicensesArgsForCall(i int) string {
	fake.getActiveVirtualLicensesMutex.RLock()
	defer fake.getActiveVirtualLicensesMutex.RUnlock()
	argsForCall := fake.getActiveVirtualLicensesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAccountManager) GetActiveVirtualLicensesReturns(result1 []datatypes.Software_VirtualLicense, result2 error) {
	fake.getActiveVirtualLicensesMutex.Lock()
	defer fake.getActiveVirtualLicensesMutex.Unlock()
	fake.GetActiveVirtualLicensesStub = nil
	fake.getActiveVirtualLicensesReturns = struct {
		result1 []datatypes.Software_VirtualLicense
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetActiveVirtualLicensesReturnsOnCall(i int, result1 []datatypes.Software_VirtualLicense, result2 error) {
	fake.getActiveVirtualLicensesMutex.Lock()
	defer fake.getActiveVirtualLicensesMutex.Unlock()
	fake.GetActiveVirtualLicensesStub = nil
	if fake.getActiveVirtualLicensesReturnsOnCall == nil {
		fake.getActiveVirtualLicensesReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Software_VirtualLicense
			result2 error
		})
	}
	fake.getActiveVirtualLicensesReturnsOnCall[i] = struct {
		result1 []datatypes.Software_VirtualLicense
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetBandwidthPoolServers(arg1 int) (int, error) {
	fake.getBandwidthPoolServersMutex.Lock()
	ret, specificReturn := fake.getBandwidthPoolServersReturnsOnCall[len(fake.getBandwidthPoolServersArgsForCall)]
	fake.getBandwidthPoolServersArgsForCall = append(fake.getBandwidthPoolServersArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.GetBandwidthPoolServersStub
	fakeReturns := fake.getBandwidthPoolServersReturns
	fake.recordInvocation("GetBandwidthPoolServers", []interface{}{arg1})
	fake.getBandwidthPoolServersMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountManager) GetBandwidthPoolServersCallCount() int {
	fake.getBandwidthPoolServersMutex.RLock()
	defer fake.getBandwidthPoolServersMutex.RUnlock()
	return len(fake.getBandwidthPoolServersArgsForCall)
}

func (fake *FakeAccountManager) GetBandwidthPoolServersCalls(stub func(int) (int, error)) {
	fake.getBandwidthPoolServersMutex.Lock()
	defer fake.getBandwidthPoolServersMutex.Unlock()
	fake.GetBandwidthPoolServersStub = stub
}

func (fake *FakeAccountManager) GetBandwidthPoolServersArgsForCall(i int) int {
	fake.getBandwidthPoolServersMutex.RLock()
	defer fake.getBandwidthPoolServersMutex.RUnlock()
	argsForCall := fake.getBandwidthPoolServersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAccountManager) GetBandwidthPoolServersReturns(result1 int, result2 error) {
	fake.getBandwidthPoolServersMutex.Lock()
	defer fake.getBandwidthPoolServersMutex.Unlock()
	fake.GetBandwidthPoolServersStub = nil
	fake.getBandwidthPoolServersReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetBandwidthPoolServersReturnsOnCall(i int, result1 int, result2 error) {
	fake.getBandwidthPoolServersMutex.Lock()
	defer fake.getBandwidthPoolServersMutex.Unlock()
	fake.GetBandwidthPoolServersStub = nil
	if fake.getBandwidthPoolServersReturnsOnCall == nil {
		fake.getBandwidthPoolServersReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.getBandwidthPoolServersReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetBandwidthPools() ([]datatypes.Network_Bandwidth_Version1_Allotment, error) {
	fake.getBandwidthPoolsMutex.Lock()
	ret, specificReturn := fake.getBandwidthPoolsReturnsOnCall[len(fake.getBandwidthPoolsArgsForCall)]
	fake.getBandwidthPoolsArgsForCall = append(fake.getBandwidthPoolsArgsForCall, struct {
	}{})
	stub := fake.GetBandwidthPoolsStub
	fakeReturns := fake.getBandwidthPoolsReturns
	fake.recordInvocation("GetBandwidthPools", []interface{}{})
	fake.getBandwidthPoolsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountManager) GetBandwidthPoolsCallCount() int {
	fake.getBandwidthPoolsMutex.RLock()
	defer fake.getBandwidthPoolsMutex.RUnlock()
	return len(fake.getBandwidthPoolsArgsForCall)
}

func (fake *FakeAccountManager) GetBandwidthPoolsCalls(stub func() ([]datatypes.Network_Bandwidth_Version1_Allotment, error)) {
	fake.getBandwidthPoolsMutex.Lock()
	defer fake.getBandwidthPoolsMutex.Unlock()
	fake.GetBandwidthPoolsStub = stub
}

func (fake *FakeAccountManager) GetBandwidthPoolsReturns(result1 []datatypes.Network_Bandwidth_Version1_Allotment, result2 error) {
	fake.getBandwidthPoolsMutex.Lock()
	defer fake.getBandwidthPoolsMutex.Unlock()
	fake.GetBandwidthPoolsStub = nil
	fake.getBandwidthPoolsReturns = struct {
		result1 []datatypes.Network_Bandwidth_Version1_Allotment
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetBandwidthPoolsReturnsOnCall(i int, result1 []datatypes.Network_Bandwidth_Version1_Allotment, result2 error) {
	fake.getBandwidthPoolsMutex.Lock()
	defer fake.getBandwidthPoolsMutex.Unlock()
	fake.GetBandwidthPoolsStub = nil
	if fake.getBandwidthPoolsReturnsOnCall == nil {
		fake.getBandwidthPoolsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Network_Bandwidth_Version1_Allotment
			result2 error
		})
	}
	fake.getBandwidthPoolsReturnsOnCall[i] = struct {
		result1 []datatypes.Network_Bandwidth_Version1_Allotment
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetBillingItems(arg1 string) ([]datatypes.Billing_Item, error) {
	fake.getBillingItemsMutex.Lock()
	ret, specificReturn := fake.getBillingItemsReturnsOnCall[len(fake.getBillingItemsArgsForCall)]
	fake.getBillingItemsArgsForCall = append(fake.getBillingItemsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetBillingItemsStub
	fakeReturns := fake.getBillingItemsReturns
	fake.recordInvocation("GetBillingItems", []interface{}{arg1})
	fake.getBillingItemsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountManager) GetBillingItemsCallCount() int {
	fake.getBillingItemsMutex.RLock()
	defer fake.getBillingItemsMutex.RUnlock()
	return len(fake.getBillingItemsArgsForCall)
}

func (fake *FakeAccountManager) GetBillingItemsCalls(stub func(string) ([]datatypes.Billing_Item, error)) {
	fake.getBillingItemsMutex.Lock()
	defer fake.getBillingItemsMutex.Unlock()
	fake.GetBillingItemsStub = stub
}

func (fake *FakeAccountManager) GetBillingItemsArgsForCall(i int) string {
	fake.getBillingItemsMutex.RLock()
	defer fake.getBillingItemsMutex.RUnlock()
	argsForCall := fake.getBillingItemsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAccountManager) GetBillingItemsReturns(result1 []datatypes.Billing_Item, result2 error) {
	fake.getBillingItemsMutex.Lock()
	defer fake.getBillingItemsMutex.Unlock()
	fake.GetBillingItemsStub = nil
	fake.getBillingItemsReturns = struct {
		result1 []datatypes.Billing_Item
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetBillingItemsReturnsOnCall(i int, result1 []datatypes.Billing_Item, result2 error) {
	fake.getBillingItemsMutex.Lock()
	defer fake.getBillingItemsMutex.Unlock()
	fake.GetBillingItemsStub = nil
	if fake.getBillingItemsReturnsOnCall == nil {
		fake.getBillingItemsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Billing_Item
			result2 error
		})
	}
	fake.getBillingItemsReturnsOnCall[i] = struct {
		result1 []datatypes.Billing_Item
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetEventDetail(arg1 int, arg2 string) (datatypes.Notification_Occurrence_Event, error) {
	fake.getEventDetailMutex.Lock()
	ret, specificReturn := fake.getEventDetailReturnsOnCall[len(fake.getEventDetailArgsForCall)]
	fake.getEventDetailArgsForCall = append(fake.getEventDetailArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.GetEventDetailStub
	fakeReturns := fake.getEventDetailReturns
	fake.recordInvocation("GetEventDetail", []interface{}{arg1, arg2})
	fake.getEventDetailMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountManager) GetEventDetailCallCount() int {
	fake.getEventDetailMutex.RLock()
	defer fake.getEventDetailMutex.RUnlock()
	return len(fake.getEventDetailArgsForCall)
}

func (fake *FakeAccountManager) GetEventDetailCalls(stub func(int, string) (datatypes.Notification_Occurrence_Event, error)) {
	fake.getEventDetailMutex.Lock()
	defer fake.getEventDetailMutex.Unlock()
	fake.GetEventDetailStub = stub
}

func (fake *FakeAccountManager) GetEventDetailArgsForCall(i int) (int, string) {
	fake.getEventDetailMutex.RLock()
	defer fake.getEventDetailMutex.RUnlock()
	argsForCall := fake.getEventDetailArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAccountManager) GetEventDetailReturns(result1 datatypes.Notification_Occurrence_Event, result2 error) {
	fake.getEventDetailMutex.Lock()
	defer fake.getEventDetailMutex.Unlock()
	fake.GetEventDetailStub = nil
	fake.getEventDetailReturns = struct {
		result1 datatypes.Notification_Occurrence_Event
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetEventDetailReturnsOnCall(i int, result1 datatypes.Notification_Occurrence_Event, result2 error) {
	fake.getEventDetailMutex.Lock()
	defer fake.getEventDetailMutex.Unlock()
	fake.GetEventDetailStub = nil
	if fake.getEventDetailReturnsOnCall == nil {
		fake.getEventDetailReturnsOnCall = make(map[int]struct {
			result1 datatypes.Notification_Occurrence_Event
			result2 error
		})
	}
	fake.getEventDetailReturnsOnCall[i] = struct {
		result1 datatypes.Notification_Occurrence_Event
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetEvents(arg1 string, arg2 string, arg3 string) ([]datatypes.Notification_Occurrence_Event, error) {
	fake.getEventsMutex.Lock()
	ret, specificReturn := fake.getEventsReturnsOnCall[len(fake.getEventsArgsForCall)]
	fake.getEventsArgsForCall = append(fake.getEventsArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetEventsStub
	fakeReturns := fake.getEventsReturns
	fake.recordInvocation("GetEvents", []interface{}{arg1, arg2, arg3})
	fake.getEventsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountManager) GetEventsCallCount() int {
	fake.getEventsMutex.RLock()
	defer fake.getEventsMutex.RUnlock()
	return len(fake.getEventsArgsForCall)
}

func (fake *FakeAccountManager) GetEventsCalls(stub func(string, string, string) ([]datatypes.Notification_Occurrence_Event, error)) {
	fake.getEventsMutex.Lock()
	defer fake.getEventsMutex.Unlock()
	fake.GetEventsStub = stub
}

func (fake *FakeAccountManager) GetEventsArgsForCall(i int) (string, string, string) {
	fake.getEventsMutex.RLock()
	defer fake.getEventsMutex.RUnlock()
	argsForCall := fake.getEventsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAccountManager) GetEventsReturns(result1 []datatypes.Notification_Occurrence_Event, result2 error) {
	fake.getEventsMutex.Lock()
	defer fake.getEventsMutex.Unlock()
	fake.GetEventsStub = nil
	fake.getEventsReturns = struct {
		result1 []datatypes.Notification_Occurrence_Event
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetEventsReturnsOnCall(i int, result1 []datatypes.Notification_Occurrence_Event, result2 error) {
	fake.getEventsMutex.Lock()
	defer fake.getEventsMutex.Unlock()
	fake.GetEventsStub = nil
	if fake.getEventsReturnsOnCall == nil {
		fake.getEventsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Notification_Occurrence_Event
			result2 error
		})
	}
	fake.getEventsReturnsOnCall[i] = struct {
		result1 []datatypes.Notification_Occurrence_Event
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetInvoiceDetail(arg1 int, arg2 string) ([]datatypes.Billing_Invoice_Item, error) {
	fake.getInvoiceDetailMutex.Lock()
	ret, specificReturn := fake.getInvoiceDetailReturnsOnCall[len(fake.getInvoiceDetailArgsForCall)]
	fake.getInvoiceDetailArgsForCall = append(fake.getInvoiceDetailArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.GetInvoiceDetailStub
	fakeReturns := fake.getInvoiceDetailReturns
	fake.recordInvocation("GetInvoiceDetail", []interface{}{arg1, arg2})
	fake.getInvoiceDetailMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountManager) GetInvoiceDetailCallCount() int {
	fake.getInvoiceDetailMutex.RLock()
	defer fake.getInvoiceDetailMutex.RUnlock()
	return len(fake.getInvoiceDetailArgsForCall)
}

func (fake *FakeAccountManager) GetInvoiceDetailCalls(stub func(int, string) ([]datatypes.Billing_Invoice_Item, error)) {
	fake.getInvoiceDetailMutex.Lock()
	defer fake.getInvoiceDetailMutex.Unlock()
	fake.GetInvoiceDetailStub = stub
}

func (fake *FakeAccountManager) GetInvoiceDetailArgsForCall(i int) (int, string) {
	fake.getInvoiceDetailMutex.RLock()
	defer fake.getInvoiceDetailMutex.RUnlock()
	argsForCall := fake.getInvoiceDetailArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAccountManager) GetInvoiceDetailReturns(result1 []datatypes.Billing_Invoice_Item, result2 error) {
	fake.getInvoiceDetailMutex.Lock()
	defer fake.getInvoiceDetailMutex.Unlock()
	fake.GetInvoiceDetailStub = nil
	fake.getInvoiceDetailReturns = struct {
		result1 []datatypes.Billing_Invoice_Item
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetInvoiceDetailReturnsOnCall(i int, result1 []datatypes.Billing_Invoice_Item, result2 error) {
	fake.getInvoiceDetailMutex.Lock()
	defer fake.getInvoiceDetailMutex.Unlock()
	fake.GetInvoiceDetailStub = nil
	if fake.getInvoiceDetailReturnsOnCall == nil {
		fake.getInvoiceDetailReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Billing_Invoice_Item
			result2 error
		})
	}
	fake.getInvoiceDetailReturnsOnCall[i] = struct {
		result1 []datatypes.Billing_Invoice_Item
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetInvoices(arg1 int, arg2 bool, arg3 bool) ([]datatypes.Billing_Invoice, error) {
	fake.getInvoicesMutex.Lock()
	ret, specificReturn := fake.getInvoicesReturnsOnCall[len(fake.getInvoicesArgsForCall)]
	fake.getInvoicesArgsForCall = append(fake.getInvoicesArgsForCall, struct {
		arg1 int
		arg2 bool
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.GetInvoicesStub
	fakeReturns := fake.getInvoicesReturns
	fake.recordInvocation("GetInvoices", []interface{}{arg1, arg2, arg3})
	fake.getInvoicesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountManager) GetInvoicesCallCount() int {
	fake.getInvoicesMutex.RLock()
	defer fake.getInvoicesMutex.RUnlock()
	return len(fake.getInvoicesArgsForCall)
}

func (fake *FakeAccountManager) GetInvoicesCalls(stub func(int, bool, bool) ([]datatypes.Billing_Invoice, error)) {
	fake.getInvoicesMutex.Lock()
	defer fake.getInvoicesMutex.Unlock()
	fake.GetInvoicesStub = stub
}

func (fake *FakeAccountManager) GetInvoicesArgsForCall(i int) (int, bool, bool) {
	fake.getInvoicesMutex.RLock()
	defer fake.getInvoicesMutex.RUnlock()
	argsForCall := fake.getInvoicesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAccountManager) GetInvoicesReturns(result1 []datatypes.Billing_Invoice, result2 error) {
	fake.getInvoicesMutex.Lock()
	defer fake.getInvoicesMutex.Unlock()
	fake.GetInvoicesStub = nil
	fake.getInvoicesReturns = struct {
		result1 []datatypes.Billing_Invoice
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetInvoicesReturnsOnCall(i int, result1 []datatypes.Billing_Invoice, result2 error) {
	fake.getInvoicesMutex.Lock()
	defer fake.getInvoicesMutex.Unlock()
	fake.GetInvoicesStub = nil
	if fake.getInvoicesReturnsOnCall == nil {
		fake.getInvoicesReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Billing_Invoice
			result2 error
		})
	}
	fake.getInvoicesReturnsOnCall[i] = struct {
		result1 []datatypes.Billing_Invoice
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetItemDetail(arg1 int, arg2 string) (datatypes.Billing_Item, error) {
	fake.getItemDetailMutex.Lock()
	ret, specificReturn := fake.getItemDetailReturnsOnCall[len(fake.getItemDetailArgsForCall)]
	fake.getItemDetailArgsForCall = append(fake.getItemDetailArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.GetItemDetailStub
	fakeReturns := fake.getItemDetailReturns
	fake.recordInvocation("GetItemDetail", []interface{}{arg1, arg2})
	fake.getItemDetailMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountManager) GetItemDetailCallCount() int {
	fake.getItemDetailMutex.RLock()
	defer fake.getItemDetailMutex.RUnlock()
	return len(fake.getItemDetailArgsForCall)
}

func (fake *FakeAccountManager) GetItemDetailCalls(stub func(int, string) (datatypes.Billing_Item, error)) {
	fake.getItemDetailMutex.Lock()
	defer fake.getItemDetailMutex.Unlock()
	fake.GetItemDetailStub = stub
}

func (fake *FakeAccountManager) GetItemDetailArgsForCall(i int) (int, string) {
	fake.getItemDetailMutex.RLock()
	defer fake.getItemDetailMutex.RUnlock()
	argsForCall := fake.getItemDetailArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAccountManager) GetItemDetailReturns(result1 datatypes.Billing_Item, result2 error) {
	fake.getItemDetailMutex.Lock()
	defer fake.getItemDetailMutex.Unlock()
	fake.GetItemDetailStub = nil
	fake.getItemDetailReturns = struct {
		result1 datatypes.Billing_Item
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) GetItemDetailReturnsOnCall(i int, result1 datatypes.Billing_Item, result2 error) {
	fake.getItemDetailMutex.Lock()
	defer fake.getItemDetailMutex.Unlock()
	fake.GetItemDetailStub = nil
	if fake.getItemDetailReturnsOnCall == nil {
		fake.getItemDetailReturnsOnCall = make(map[int]struct {
			result1 datatypes.Billing_Item
			result2 error
		})
	}
	fake.getItemDetailReturnsOnCall[i] = struct {
		result1 datatypes.Billing_Item
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) SummaryByDatacenter() (map[string]map[string]int, error) {
	fake.summaryByDatacenterMutex.Lock()
	ret, specificReturn := fake.summaryByDatacenterReturnsOnCall[len(fake.summaryByDatacenterArgsForCall)]
	fake.summaryByDatacenterArgsForCall = append(fake.summaryByDatacenterArgsForCall, struct {
	}{})
	stub := fake.SummaryByDatacenterStub
	fakeReturns := fake.summaryByDatacenterReturns
	fake.recordInvocation("SummaryByDatacenter", []interface{}{})
	fake.summaryByDatacenterMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountManager) SummaryByDatacenterCallCount() int {
	fake.summaryByDatacenterMutex.RLock()
	defer fake.summaryByDatacenterMutex.RUnlock()
	return len(fake.summaryByDatacenterArgsForCall)
}

func (fake *FakeAccountManager) SummaryByDatacenterCalls(stub func() (map[string]map[string]int, error)) {
	fake.summaryByDatacenterMutex.Lock()
	defer fake.summaryByDatacenterMutex.Unlock()
	fake.SummaryByDatacenterStub = stub
}

func (fake *FakeAccountManager) SummaryByDatacenterReturns(result1 map[string]map[string]int, result2 error) {
	fake.summaryByDatacenterMutex.Lock()
	defer fake.summaryByDatacenterMutex.Unlock()
	fake.SummaryByDatacenterStub = nil
	fake.summaryByDatacenterReturns = struct {
		result1 map[string]map[string]int
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) SummaryByDatacenterReturnsOnCall(i int, result1 map[string]map[string]int, result2 error) {
	fake.summaryByDatacenterMutex.Lock()
	defer fake.summaryByDatacenterMutex.Unlock()
	fake.SummaryByDatacenterStub = nil
	if fake.summaryByDatacenterReturnsOnCall == nil {
		fake.summaryByDatacenterReturnsOnCall = make(map[int]struct {
			result1 map[string]map[string]int
			result2 error
		})
	}
	fake.summaryByDatacenterReturnsOnCall[i] = struct {
		result1 map[string]map[string]int
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cancelItemMutex.RLock()
	defer fake.cancelItemMutex.RUnlock()
	fake.getActiveAccountLicensesMutex.RLock()
	defer fake.getActiveAccountLicensesMutex.RUnlock()
	fake.getActiveVirtualLicensesMutex.RLock()
	defer fake.getActiveVirtualLicensesMutex.RUnlock()
	fake.getBandwidthPoolServersMutex.RLock()
	defer fake.getBandwidthPoolServersMutex.RUnlock()
	fake.getBandwidthPoolsMutex.RLock()
	defer fake.getBandwidthPoolsMutex.RUnlock()
	fake.getBillingItemsMutex.RLock()
	defer fake.getBillingItemsMutex.RUnlock()
	fake.getEventDetailMutex.RLock()
	defer fake.getEventDetailMutex.RUnlock()
	fake.getEventsMutex.RLock()
	defer fake.getEventsMutex.RUnlock()
	fake.getInvoiceDetailMutex.RLock()
	defer fake.getInvoiceDetailMutex.RUnlock()
	fake.getInvoicesMutex.RLock()
	defer fake.getInvoicesMutex.RUnlock()
	fake.getItemDetailMutex.RLock()
	defer fake.getItemDetailMutex.RUnlock()
	fake.summaryByDatacenterMutex.RLock()
	defer fake.summaryByDatacenterMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeAccountManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ managers.AccountManager = new(FakeAccountManager)
