// Code generated by counterfeiter. DO NOT EDIT.
package testhelpers

import (
	"sync"

	"github.com/softlayer/softlayer-go/datatypes"
	"github.ibm.com/SoftLayer/softlayer-cli/plugin/managers"
)

type FakeStorageManager struct {
	AuthorizeHostToVolumeStub        func(int, []int, []int, []int, []int) ([]datatypes.Network_Storage_Allowed_Host, error)
	authorizeHostToVolumeMutex       sync.RWMutex
	authorizeHostToVolumeArgsForCall []struct {
		arg1 int
		arg2 []int
		arg3 []int
		arg4 []int
		arg5 []int
	}
	authorizeHostToVolumeReturns struct {
		result1 []datatypes.Network_Storage_Allowed_Host
		result2 error
	}
	authorizeHostToVolumeReturnsOnCall map[int]struct {
		result1 []datatypes.Network_Storage_Allowed_Host
		result2 error
	}
	CancelSnapshotSpaceStub        func(string, int, string, bool) error
	cancelSnapshotSpaceMutex       sync.RWMutex
	cancelSnapshotSpaceArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 string
		arg4 bool
	}
	cancelSnapshotSpaceReturns struct {
		result1 error
	}
	cancelSnapshotSpaceReturnsOnCall map[int]struct {
		result1 error
	}
	CancelVolumeStub        func(string, int, string, bool) error
	cancelVolumeMutex       sync.RWMutex
	cancelVolumeArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 string
		arg4 bool
	}
	cancelVolumeReturns struct {
		result1 error
	}
	cancelVolumeReturnsOnCall map[int]struct {
		result1 error
	}
	CreateSnapshotStub        func(int, string) (datatypes.Network_Storage, error)
	createSnapshotMutex       sync.RWMutex
	createSnapshotArgsForCall []struct {
		arg1 int
		arg2 string
	}
	createSnapshotReturns struct {
		result1 datatypes.Network_Storage
		result2 error
	}
	createSnapshotReturnsOnCall map[int]struct {
		result1 datatypes.Network_Storage
		result2 error
	}
	DeauthorizeHostToVolumeStub        func(int, []int, []int, []int, []int) ([]datatypes.Network_Storage_Allowed_Host, error)
	deauthorizeHostToVolumeMutex       sync.RWMutex
	deauthorizeHostToVolumeArgsForCall []struct {
		arg1 int
		arg2 []int
		arg3 []int
		arg4 []int
		arg5 []int
	}
	deauthorizeHostToVolumeReturns struct {
		result1 []datatypes.Network_Storage_Allowed_Host
		result2 error
	}
	deauthorizeHostToVolumeReturnsOnCall map[int]struct {
		result1 []datatypes.Network_Storage_Allowed_Host
		result2 error
	}
	DeleteSnapshotStub        func(int) error
	deleteSnapshotMutex       sync.RWMutex
	deleteSnapshotArgsForCall []struct {
		arg1 int
	}
	deleteSnapshotReturns struct {
		result1 error
	}
	deleteSnapshotReturnsOnCall map[int]struct {
		result1 error
	}
	DisableSnapshotsStub        func(int, string) error
	disableSnapshotsMutex       sync.RWMutex
	disableSnapshotsArgsForCall []struct {
		arg1 int
		arg2 string
	}
	disableSnapshotsReturns struct {
		result1 error
	}
	disableSnapshotsReturnsOnCall map[int]struct {
		result1 error
	}
	DisasterRecoveryFailoverStub        func(int, int) error
	disasterRecoveryFailoverMutex       sync.RWMutex
	disasterRecoveryFailoverArgsForCall []struct {
		arg1 int
		arg2 int
	}
	disasterRecoveryFailoverReturns struct {
		result1 error
	}
	disasterRecoveryFailoverReturnsOnCall map[int]struct {
		result1 error
	}
	EnableSnapshotStub        func(int, string, int, int, int, string) error
	enableSnapshotMutex       sync.RWMutex
	enableSnapshotArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 int
		arg4 int
		arg5 int
		arg6 string
	}
	enableSnapshotReturns struct {
		result1 error
	}
	enableSnapshotReturnsOnCall map[int]struct {
		result1 error
	}
	FailBackFromReplicantStub        func(int) error
	failBackFromReplicantMutex       sync.RWMutex
	failBackFromReplicantArgsForCall []struct {
		arg1 int
	}
	failBackFromReplicantReturns struct {
		result1 error
	}
	failBackFromReplicantReturnsOnCall map[int]struct {
		result1 error
	}
	FailOverToReplicantStub        func(int, int) error
	failOverToReplicantMutex       sync.RWMutex
	failOverToReplicantArgsForCall []struct {
		arg1 int
		arg2 int
	}
	failOverToReplicantReturns struct {
		result1 error
	}
	failOverToReplicantReturnsOnCall map[int]struct {
		result1 error
	}
	GetAllDatacentersStub        func() ([]string, error)
	getAllDatacentersMutex       sync.RWMutex
	getAllDatacentersArgsForCall []struct {
	}
	getAllDatacentersReturns struct {
		result1 []string
		result2 error
	}
	getAllDatacentersReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	GetReplicationLocationsStub        func(int) ([]datatypes.Location, error)
	getReplicationLocationsMutex       sync.RWMutex
	getReplicationLocationsArgsForCall []struct {
		arg1 int
	}
	getReplicationLocationsReturns struct {
		result1 []datatypes.Location
		result2 error
	}
	getReplicationLocationsReturnsOnCall map[int]struct {
		result1 []datatypes.Location
		result2 error
	}
	GetReplicationPartnersStub        func(int) ([]datatypes.Network_Storage, error)
	getReplicationPartnersMutex       sync.RWMutex
	getReplicationPartnersArgsForCall []struct {
		arg1 int
	}
	getReplicationPartnersReturns struct {
		result1 []datatypes.Network_Storage
		result2 error
	}
	getReplicationPartnersReturnsOnCall map[int]struct {
		result1 []datatypes.Network_Storage
		result2 error
	}
	GetSnapshotNotificationStatusStub        func(int) (int, error)
	getSnapshotNotificationStatusMutex       sync.RWMutex
	getSnapshotNotificationStatusArgsForCall []struct {
		arg1 int
	}
	getSnapshotNotificationStatusReturns struct {
		result1 int
		result2 error
	}
	getSnapshotNotificationStatusReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	GetVolumeAccessListStub        func(int) (datatypes.Network_Storage, error)
	getVolumeAccessListMutex       sync.RWMutex
	getVolumeAccessListArgsForCall []struct {
		arg1 int
	}
	getVolumeAccessListReturns struct {
		result1 datatypes.Network_Storage
		result2 error
	}
	getVolumeAccessListReturnsOnCall map[int]struct {
		result1 datatypes.Network_Storage
		result2 error
	}
	GetVolumeByUsernameStub        func(string) ([]datatypes.Network_Storage, error)
	getVolumeByUsernameMutex       sync.RWMutex
	getVolumeByUsernameArgsForCall []struct {
		arg1 string
	}
	getVolumeByUsernameReturns struct {
		result1 []datatypes.Network_Storage
		result2 error
	}
	getVolumeByUsernameReturnsOnCall map[int]struct {
		result1 []datatypes.Network_Storage
		result2 error
	}
	GetVolumeCountLimitsStub        func() ([]datatypes.Container_Network_Storage_DataCenterLimits_VolumeCountLimitContainer, error)
	getVolumeCountLimitsMutex       sync.RWMutex
	getVolumeCountLimitsArgsForCall []struct {
	}
	getVolumeCountLimitsReturns struct {
		result1 []datatypes.Container_Network_Storage_DataCenterLimits_VolumeCountLimitContainer
		result2 error
	}
	getVolumeCountLimitsReturnsOnCall map[int]struct {
		result1 []datatypes.Container_Network_Storage_DataCenterLimits_VolumeCountLimitContainer
		result2 error
	}
	GetVolumeDetailsStub        func(string, int, string) (datatypes.Network_Storage, error)
	getVolumeDetailsMutex       sync.RWMutex
	getVolumeDetailsArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 string
	}
	getVolumeDetailsReturns struct {
		result1 datatypes.Network_Storage
		result2 error
	}
	getVolumeDetailsReturnsOnCall map[int]struct {
		result1 datatypes.Network_Storage
		result2 error
	}
	GetVolumeSnapshotListStub        func(int) ([]datatypes.Network_Storage, error)
	getVolumeSnapshotListMutex       sync.RWMutex
	getVolumeSnapshotListArgsForCall []struct {
		arg1 int
	}
	getVolumeSnapshotListReturns struct {
		result1 []datatypes.Network_Storage
		result2 error
	}
	getVolumeSnapshotListReturnsOnCall map[int]struct {
		result1 []datatypes.Network_Storage
		result2 error
	}
	GetVolumeSnapshotSchedulesStub        func(int) (datatypes.Network_Storage, error)
	getVolumeSnapshotSchedulesMutex       sync.RWMutex
	getVolumeSnapshotSchedulesArgsForCall []struct {
		arg1 int
	}
	getVolumeSnapshotSchedulesReturns struct {
		result1 datatypes.Network_Storage
		result2 error
	}
	getVolumeSnapshotSchedulesReturnsOnCall map[int]struct {
		result1 datatypes.Network_Storage
		result2 error
	}
	ListVolumesStub        func(string, string, string, string, int, string) ([]datatypes.Network_Storage, error)
	listVolumesMutex       sync.RWMutex
	listVolumesArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 int
		arg6 string
	}
	listVolumesReturns struct {
		result1 []datatypes.Network_Storage
		result2 error
	}
	listVolumesReturnsOnCall map[int]struct {
		result1 []datatypes.Network_Storage
		result2 error
	}
	OrderDuplicateVolumeStub        func(managers.DuplicateOrderConfig) (datatypes.Container_Product_Order_Receipt, error)
	orderDuplicateVolumeMutex       sync.RWMutex
	orderDuplicateVolumeArgsForCall []struct {
		arg1 managers.DuplicateOrderConfig
	}
	orderDuplicateVolumeReturns struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	orderDuplicateVolumeReturnsOnCall map[int]struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	OrderModifiedVolumeStub        func(string, int, float64, int, int) (datatypes.Container_Product_Order_Receipt, error)
	orderModifiedVolumeMutex       sync.RWMutex
	orderModifiedVolumeArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 float64
		arg4 int
		arg5 int
	}
	orderModifiedVolumeReturns struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	orderModifiedVolumeReturnsOnCall map[int]struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	OrderReplicantVolumeStub        func(string, int, string, string, float64, int, string) (datatypes.Container_Product_Order_Receipt, error)
	orderReplicantVolumeMutex       sync.RWMutex
	orderReplicantVolumeArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 string
		arg4 string
		arg5 float64
		arg6 int
		arg7 string
	}
	orderReplicantVolumeReturns struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	orderReplicantVolumeReturnsOnCall map[int]struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	OrderSnapshotSpaceStub        func(string, int, int, float64, int, bool) (datatypes.Container_Product_Order_Receipt, error)
	orderSnapshotSpaceMutex       sync.RWMutex
	orderSnapshotSpaceArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
		arg4 float64
		arg5 int
		arg6 bool
	}
	orderSnapshotSpaceReturns struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	orderSnapshotSpaceReturnsOnCall map[int]struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	OrderVolumeStub        func(string, string, string, string, int, float64, int, int, bool) (datatypes.Container_Product_Order_Receipt, error)
	orderVolumeMutex       sync.RWMutex
	orderVolumeArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 int
		arg6 float64
		arg7 int
		arg8 int
		arg9 bool
	}
	orderVolumeReturns struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	orderVolumeReturnsOnCall map[int]struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	RestoreFromSnapshotStub        func(int, int) error
	restoreFromSnapshotMutex       sync.RWMutex
	restoreFromSnapshotArgsForCall []struct {
		arg1 int
		arg2 int
	}
	restoreFromSnapshotReturns struct {
		result1 error
	}
	restoreFromSnapshotReturnsOnCall map[int]struct {
		result1 error
	}
	SetCredentialPasswordStub        func(int, string) error
	setCredentialPasswordMutex       sync.RWMutex
	setCredentialPasswordArgsForCall []struct {
		arg1 int
		arg2 string
	}
	setCredentialPasswordReturns struct {
		result1 error
	}
	setCredentialPasswordReturnsOnCall map[int]struct {
		result1 error
	}
	SetLunIdStub        func(int, int) (datatypes.Network_Storage_Property, error)
	setLunIdMutex       sync.RWMutex
	setLunIdArgsForCall []struct {
		arg1 int
		arg2 int
	}
	setLunIdReturns struct {
		result1 datatypes.Network_Storage_Property
		result2 error
	}
	setLunIdReturnsOnCall map[int]struct {
		result1 datatypes.Network_Storage_Property
		result2 error
	}
	SetSnapshotNotificationStub        func(int, bool) error
	setSnapshotNotificationMutex       sync.RWMutex
	setSnapshotNotificationArgsForCall []struct {
		arg1 int
		arg2 bool
	}
	setSnapshotNotificationReturns struct {
		result1 error
	}
	setSnapshotNotificationReturnsOnCall map[int]struct {
		result1 error
	}
	VolumeConvertStub        func(int) error
	volumeConvertMutex       sync.RWMutex
	volumeConvertArgsForCall []struct {
		arg1 int
	}
	volumeConvertReturns struct {
		result1 error
	}
	volumeConvertReturnsOnCall map[int]struct {
		result1 error
	}
	VolumeRefreshStub        func(int, int) error
	volumeRefreshMutex       sync.RWMutex
	volumeRefreshArgsForCall []struct {
		arg1 int
		arg2 int
	}
	volumeRefreshReturns struct {
		result1 error
	}
	volumeRefreshReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeStorageManager) AuthorizeHostToVolume(arg1 int, arg2 []int, arg3 []int, arg4 []int, arg5 []int) ([]datatypes.Network_Storage_Allowed_Host, error) {
	var arg2Copy []int
	if arg2 != nil {
		arg2Copy = make([]int, len(arg2))
		copy(arg2Copy, arg2)
	}
	var arg3Copy []int
	if arg3 != nil {
		arg3Copy = make([]int, len(arg3))
		copy(arg3Copy, arg3)
	}
	var arg4Copy []int
	if arg4 != nil {
		arg4Copy = make([]int, len(arg4))
		copy(arg4Copy, arg4)
	}
	var arg5Copy []int
	if arg5 != nil {
		arg5Copy = make([]int, len(arg5))
		copy(arg5Copy, arg5)
	}
	fake.authorizeHostToVolumeMutex.Lock()
	ret, specificReturn := fake.authorizeHostToVolumeReturnsOnCall[len(fake.authorizeHostToVolumeArgsForCall)]
	fake.authorizeHostToVolumeArgsForCall = append(fake.authorizeHostToVolumeArgsForCall, struct {
		arg1 int
		arg2 []int
		arg3 []int
		arg4 []int
		arg5 []int
	}{arg1, arg2Copy, arg3Copy, arg4Copy, arg5Copy})
	fake.recordInvocation("AuthorizeHostToVolume", []interface{}{arg1, arg2Copy, arg3Copy, arg4Copy, arg5Copy})
	fake.authorizeHostToVolumeMutex.Unlock()
	if fake.AuthorizeHostToVolumeStub != nil {
		return fake.AuthorizeHostToVolumeStub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.authorizeHostToVolumeReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageManager) AuthorizeHostToVolumeCallCount() int {
	fake.authorizeHostToVolumeMutex.RLock()
	defer fake.authorizeHostToVolumeMutex.RUnlock()
	return len(fake.authorizeHostToVolumeArgsForCall)
}

func (fake *FakeStorageManager) AuthorizeHostToVolumeCalls(stub func(int, []int, []int, []int, []int) ([]datatypes.Network_Storage_Allowed_Host, error)) {
	fake.authorizeHostToVolumeMutex.Lock()
	defer fake.authorizeHostToVolumeMutex.Unlock()
	fake.AuthorizeHostToVolumeStub = stub
}

func (fake *FakeStorageManager) AuthorizeHostToVolumeArgsForCall(i int) (int, []int, []int, []int, []int) {
	fake.authorizeHostToVolumeMutex.RLock()
	defer fake.authorizeHostToVolumeMutex.RUnlock()
	argsForCall := fake.authorizeHostToVolumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeStorageManager) AuthorizeHostToVolumeReturns(result1 []datatypes.Network_Storage_Allowed_Host, result2 error) {
	fake.authorizeHostToVolumeMutex.Lock()
	defer fake.authorizeHostToVolumeMutex.Unlock()
	fake.AuthorizeHostToVolumeStub = nil
	fake.authorizeHostToVolumeReturns = struct {
		result1 []datatypes.Network_Storage_Allowed_Host
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) AuthorizeHostToVolumeReturnsOnCall(i int, result1 []datatypes.Network_Storage_Allowed_Host, result2 error) {
	fake.authorizeHostToVolumeMutex.Lock()
	defer fake.authorizeHostToVolumeMutex.Unlock()
	fake.AuthorizeHostToVolumeStub = nil
	if fake.authorizeHostToVolumeReturnsOnCall == nil {
		fake.authorizeHostToVolumeReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Network_Storage_Allowed_Host
			result2 error
		})
	}
	fake.authorizeHostToVolumeReturnsOnCall[i] = struct {
		result1 []datatypes.Network_Storage_Allowed_Host
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) CancelSnapshotSpace(arg1 string, arg2 int, arg3 string, arg4 bool) error {
	fake.cancelSnapshotSpaceMutex.Lock()
	ret, specificReturn := fake.cancelSnapshotSpaceReturnsOnCall[len(fake.cancelSnapshotSpaceArgsForCall)]
	fake.cancelSnapshotSpaceArgsForCall = append(fake.cancelSnapshotSpaceArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 string
		arg4 bool
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("CancelSnapshotSpace", []interface{}{arg1, arg2, arg3, arg4})
	fake.cancelSnapshotSpaceMutex.Unlock()
	if fake.CancelSnapshotSpaceStub != nil {
		return fake.CancelSnapshotSpaceStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.cancelSnapshotSpaceReturns
	return fakeReturns.result1
}

func (fake *FakeStorageManager) CancelSnapshotSpaceCallCount() int {
	fake.cancelSnapshotSpaceMutex.RLock()
	defer fake.cancelSnapshotSpaceMutex.RUnlock()
	return len(fake.cancelSnapshotSpaceArgsForCall)
}

func (fake *FakeStorageManager) CancelSnapshotSpaceCalls(stub func(string, int, string, bool) error) {
	fake.cancelSnapshotSpaceMutex.Lock()
	defer fake.cancelSnapshotSpaceMutex.Unlock()
	fake.CancelSnapshotSpaceStub = stub
}

func (fake *FakeStorageManager) CancelSnapshotSpaceArgsForCall(i int) (string, int, string, bool) {
	fake.cancelSnapshotSpaceMutex.RLock()
	defer fake.cancelSnapshotSpaceMutex.RUnlock()
	argsForCall := fake.cancelSnapshotSpaceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeStorageManager) CancelSnapshotSpaceReturns(result1 error) {
	fake.cancelSnapshotSpaceMutex.Lock()
	defer fake.cancelSnapshotSpaceMutex.Unlock()
	fake.CancelSnapshotSpaceStub = nil
	fake.cancelSnapshotSpaceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageManager) CancelSnapshotSpaceReturnsOnCall(i int, result1 error) {
	fake.cancelSnapshotSpaceMutex.Lock()
	defer fake.cancelSnapshotSpaceMutex.Unlock()
	fake.CancelSnapshotSpaceStub = nil
	if fake.cancelSnapshotSpaceReturnsOnCall == nil {
		fake.cancelSnapshotSpaceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelSnapshotSpaceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageManager) CancelVolume(arg1 string, arg2 int, arg3 string, arg4 bool) error {
	fake.cancelVolumeMutex.Lock()
	ret, specificReturn := fake.cancelVolumeReturnsOnCall[len(fake.cancelVolumeArgsForCall)]
	fake.cancelVolumeArgsForCall = append(fake.cancelVolumeArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 string
		arg4 bool
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("CancelVolume", []interface{}{arg1, arg2, arg3, arg4})
	fake.cancelVolumeMutex.Unlock()
	if fake.CancelVolumeStub != nil {
		return fake.CancelVolumeStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.cancelVolumeReturns
	return fakeReturns.result1
}

func (fake *FakeStorageManager) CancelVolumeCallCount() int {
	fake.cancelVolumeMutex.RLock()
	defer fake.cancelVolumeMutex.RUnlock()
	return len(fake.cancelVolumeArgsForCall)
}

func (fake *FakeStorageManager) CancelVolumeCalls(stub func(string, int, string, bool) error) {
	fake.cancelVolumeMutex.Lock()
	defer fake.cancelVolumeMutex.Unlock()
	fake.CancelVolumeStub = stub
}

func (fake *FakeStorageManager) CancelVolumeArgsForCall(i int) (string, int, string, bool) {
	fake.cancelVolumeMutex.RLock()
	defer fake.cancelVolumeMutex.RUnlock()
	argsForCall := fake.cancelVolumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeStorageManager) CancelVolumeReturns(result1 error) {
	fake.cancelVolumeMutex.Lock()
	defer fake.cancelVolumeMutex.Unlock()
	fake.CancelVolumeStub = nil
	fake.cancelVolumeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageManager) CancelVolumeReturnsOnCall(i int, result1 error) {
	fake.cancelVolumeMutex.Lock()
	defer fake.cancelVolumeMutex.Unlock()
	fake.CancelVolumeStub = nil
	if fake.cancelVolumeReturnsOnCall == nil {
		fake.cancelVolumeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelVolumeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageManager) CreateSnapshot(arg1 int, arg2 string) (datatypes.Network_Storage, error) {
	fake.createSnapshotMutex.Lock()
	ret, specificReturn := fake.createSnapshotReturnsOnCall[len(fake.createSnapshotArgsForCall)]
	fake.createSnapshotArgsForCall = append(fake.createSnapshotArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("CreateSnapshot", []interface{}{arg1, arg2})
	fake.createSnapshotMutex.Unlock()
	if fake.CreateSnapshotStub != nil {
		return fake.CreateSnapshotStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createSnapshotReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageManager) CreateSnapshotCallCount() int {
	fake.createSnapshotMutex.RLock()
	defer fake.createSnapshotMutex.RUnlock()
	return len(fake.createSnapshotArgsForCall)
}

func (fake *FakeStorageManager) CreateSnapshotCalls(stub func(int, string) (datatypes.Network_Storage, error)) {
	fake.createSnapshotMutex.Lock()
	defer fake.createSnapshotMutex.Unlock()
	fake.CreateSnapshotStub = stub
}

func (fake *FakeStorageManager) CreateSnapshotArgsForCall(i int) (int, string) {
	fake.createSnapshotMutex.RLock()
	defer fake.createSnapshotMutex.RUnlock()
	argsForCall := fake.createSnapshotArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorageManager) CreateSnapshotReturns(result1 datatypes.Network_Storage, result2 error) {
	fake.createSnapshotMutex.Lock()
	defer fake.createSnapshotMutex.Unlock()
	fake.CreateSnapshotStub = nil
	fake.createSnapshotReturns = struct {
		result1 datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) CreateSnapshotReturnsOnCall(i int, result1 datatypes.Network_Storage, result2 error) {
	fake.createSnapshotMutex.Lock()
	defer fake.createSnapshotMutex.Unlock()
	fake.CreateSnapshotStub = nil
	if fake.createSnapshotReturnsOnCall == nil {
		fake.createSnapshotReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_Storage
			result2 error
		})
	}
	fake.createSnapshotReturnsOnCall[i] = struct {
		result1 datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) DeauthorizeHostToVolume(arg1 int, arg2 []int, arg3 []int, arg4 []int, arg5 []int) ([]datatypes.Network_Storage_Allowed_Host, error) {
	var arg2Copy []int
	if arg2 != nil {
		arg2Copy = make([]int, len(arg2))
		copy(arg2Copy, arg2)
	}
	var arg3Copy []int
	if arg3 != nil {
		arg3Copy = make([]int, len(arg3))
		copy(arg3Copy, arg3)
	}
	var arg4Copy []int
	if arg4 != nil {
		arg4Copy = make([]int, len(arg4))
		copy(arg4Copy, arg4)
	}
	var arg5Copy []int
	if arg5 != nil {
		arg5Copy = make([]int, len(arg5))
		copy(arg5Copy, arg5)
	}
	fake.deauthorizeHostToVolumeMutex.Lock()
	ret, specificReturn := fake.deauthorizeHostToVolumeReturnsOnCall[len(fake.deauthorizeHostToVolumeArgsForCall)]
	fake.deauthorizeHostToVolumeArgsForCall = append(fake.deauthorizeHostToVolumeArgsForCall, struct {
		arg1 int
		arg2 []int
		arg3 []int
		arg4 []int
		arg5 []int
	}{arg1, arg2Copy, arg3Copy, arg4Copy, arg5Copy})
	fake.recordInvocation("DeauthorizeHostToVolume", []interface{}{arg1, arg2Copy, arg3Copy, arg4Copy, arg5Copy})
	fake.deauthorizeHostToVolumeMutex.Unlock()
	if fake.DeauthorizeHostToVolumeStub != nil {
		return fake.DeauthorizeHostToVolumeStub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deauthorizeHostToVolumeReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageManager) DeauthorizeHostToVolumeCallCount() int {
	fake.deauthorizeHostToVolumeMutex.RLock()
	defer fake.deauthorizeHostToVolumeMutex.RUnlock()
	return len(fake.deauthorizeHostToVolumeArgsForCall)
}

func (fake *FakeStorageManager) DeauthorizeHostToVolumeCalls(stub func(int, []int, []int, []int, []int) ([]datatypes.Network_Storage_Allowed_Host, error)) {
	fake.deauthorizeHostToVolumeMutex.Lock()
	defer fake.deauthorizeHostToVolumeMutex.Unlock()
	fake.DeauthorizeHostToVolumeStub = stub
}

func (fake *FakeStorageManager) DeauthorizeHostToVolumeArgsForCall(i int) (int, []int, []int, []int, []int) {
	fake.deauthorizeHostToVolumeMutex.RLock()
	defer fake.deauthorizeHostToVolumeMutex.RUnlock()
	argsForCall := fake.deauthorizeHostToVolumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeStorageManager) DeauthorizeHostToVolumeReturns(result1 []datatypes.Network_Storage_Allowed_Host, result2 error) {
	fake.deauthorizeHostToVolumeMutex.Lock()
	defer fake.deauthorizeHostToVolumeMutex.Unlock()
	fake.DeauthorizeHostToVolumeStub = nil
	fake.deauthorizeHostToVolumeReturns = struct {
		result1 []datatypes.Network_Storage_Allowed_Host
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) DeauthorizeHostToVolumeReturnsOnCall(i int, result1 []datatypes.Network_Storage_Allowed_Host, result2 error) {
	fake.deauthorizeHostToVolumeMutex.Lock()
	defer fake.deauthorizeHostToVolumeMutex.Unlock()
	fake.DeauthorizeHostToVolumeStub = nil
	if fake.deauthorizeHostToVolumeReturnsOnCall == nil {
		fake.deauthorizeHostToVolumeReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Network_Storage_Allowed_Host
			result2 error
		})
	}
	fake.deauthorizeHostToVolumeReturnsOnCall[i] = struct {
		result1 []datatypes.Network_Storage_Allowed_Host
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) DeleteSnapshot(arg1 int) error {
	fake.deleteSnapshotMutex.Lock()
	ret, specificReturn := fake.deleteSnapshotReturnsOnCall[len(fake.deleteSnapshotArgsForCall)]
	fake.deleteSnapshotArgsForCall = append(fake.deleteSnapshotArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("DeleteSnapshot", []interface{}{arg1})
	fake.deleteSnapshotMutex.Unlock()
	if fake.DeleteSnapshotStub != nil {
		return fake.DeleteSnapshotStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteSnapshotReturns
	return fakeReturns.result1
}

func (fake *FakeStorageManager) DeleteSnapshotCallCount() int {
	fake.deleteSnapshotMutex.RLock()
	defer fake.deleteSnapshotMutex.RUnlock()
	return len(fake.deleteSnapshotArgsForCall)
}

func (fake *FakeStorageManager) DeleteSnapshotCalls(stub func(int) error) {
	fake.deleteSnapshotMutex.Lock()
	defer fake.deleteSnapshotMutex.Unlock()
	fake.DeleteSnapshotStub = stub
}

func (fake *FakeStorageManager) DeleteSnapshotArgsForCall(i int) int {
	fake.deleteSnapshotMutex.RLock()
	defer fake.deleteSnapshotMutex.RUnlock()
	argsForCall := fake.deleteSnapshotArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageManager) DeleteSnapshotReturns(result1 error) {
	fake.deleteSnapshotMutex.Lock()
	defer fake.deleteSnapshotMutex.Unlock()
	fake.DeleteSnapshotStub = nil
	fake.deleteSnapshotReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageManager) DeleteSnapshotReturnsOnCall(i int, result1 error) {
	fake.deleteSnapshotMutex.Lock()
	defer fake.deleteSnapshotMutex.Unlock()
	fake.DeleteSnapshotStub = nil
	if fake.deleteSnapshotReturnsOnCall == nil {
		fake.deleteSnapshotReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteSnapshotReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageManager) DisableSnapshots(arg1 int, arg2 string) error {
	fake.disableSnapshotsMutex.Lock()
	ret, specificReturn := fake.disableSnapshotsReturnsOnCall[len(fake.disableSnapshotsArgsForCall)]
	fake.disableSnapshotsArgsForCall = append(fake.disableSnapshotsArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("DisableSnapshots", []interface{}{arg1, arg2})
	fake.disableSnapshotsMutex.Unlock()
	if fake.DisableSnapshotsStub != nil {
		return fake.DisableSnapshotsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.disableSnapshotsReturns
	return fakeReturns.result1
}

func (fake *FakeStorageManager) DisableSnapshotsCallCount() int {
	fake.disableSnapshotsMutex.RLock()
	defer fake.disableSnapshotsMutex.RUnlock()
	return len(fake.disableSnapshotsArgsForCall)
}

func (fake *FakeStorageManager) DisableSnapshotsCalls(stub func(int, string) error) {
	fake.disableSnapshotsMutex.Lock()
	defer fake.disableSnapshotsMutex.Unlock()
	fake.DisableSnapshotsStub = stub
}

func (fake *FakeStorageManager) DisableSnapshotsArgsForCall(i int) (int, string) {
	fake.disableSnapshotsMutex.RLock()
	defer fake.disableSnapshotsMutex.RUnlock()
	argsForCall := fake.disableSnapshotsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorageManager) DisableSnapshotsReturns(result1 error) {
	fake.disableSnapshotsMutex.Lock()
	defer fake.disableSnapshotsMutex.Unlock()
	fake.DisableSnapshotsStub = nil
	fake.disableSnapshotsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageManager) DisableSnapshotsReturnsOnCall(i int, result1 error) {
	fake.disableSnapshotsMutex.Lock()
	defer fake.disableSnapshotsMutex.Unlock()
	fake.DisableSnapshotsStub = nil
	if fake.disableSnapshotsReturnsOnCall == nil {
		fake.disableSnapshotsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.disableSnapshotsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageManager) DisasterRecoveryFailover(arg1 int, arg2 int) error {
	fake.disasterRecoveryFailoverMutex.Lock()
	ret, specificReturn := fake.disasterRecoveryFailoverReturnsOnCall[len(fake.disasterRecoveryFailoverArgsForCall)]
	fake.disasterRecoveryFailoverArgsForCall = append(fake.disasterRecoveryFailoverArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("DisasterRecoveryFailover", []interface{}{arg1, arg2})
	fake.disasterRecoveryFailoverMutex.Unlock()
	if fake.DisasterRecoveryFailoverStub != nil {
		return fake.DisasterRecoveryFailoverStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.disasterRecoveryFailoverReturns
	return fakeReturns.result1
}

func (fake *FakeStorageManager) DisasterRecoveryFailoverCallCount() int {
	fake.disasterRecoveryFailoverMutex.RLock()
	defer fake.disasterRecoveryFailoverMutex.RUnlock()
	return len(fake.disasterRecoveryFailoverArgsForCall)
}

func (fake *FakeStorageManager) DisasterRecoveryFailoverCalls(stub func(int, int) error) {
	fake.disasterRecoveryFailoverMutex.Lock()
	defer fake.disasterRecoveryFailoverMutex.Unlock()
	fake.DisasterRecoveryFailoverStub = stub
}

func (fake *FakeStorageManager) DisasterRecoveryFailoverArgsForCall(i int) (int, int) {
	fake.disasterRecoveryFailoverMutex.RLock()
	defer fake.disasterRecoveryFailoverMutex.RUnlock()
	argsForCall := fake.disasterRecoveryFailoverArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorageManager) DisasterRecoveryFailoverReturns(result1 error) {
	fake.disasterRecoveryFailoverMutex.Lock()
	defer fake.disasterRecoveryFailoverMutex.Unlock()
	fake.DisasterRecoveryFailoverStub = nil
	fake.disasterRecoveryFailoverReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageManager) DisasterRecoveryFailoverReturnsOnCall(i int, result1 error) {
	fake.disasterRecoveryFailoverMutex.Lock()
	defer fake.disasterRecoveryFailoverMutex.Unlock()
	fake.DisasterRecoveryFailoverStub = nil
	if fake.disasterRecoveryFailoverReturnsOnCall == nil {
		fake.disasterRecoveryFailoverReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.disasterRecoveryFailoverReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageManager) EnableSnapshot(arg1 int, arg2 string, arg3 int, arg4 int, arg5 int, arg6 string) error {
	fake.enableSnapshotMutex.Lock()
	ret, specificReturn := fake.enableSnapshotReturnsOnCall[len(fake.enableSnapshotArgsForCall)]
	fake.enableSnapshotArgsForCall = append(fake.enableSnapshotArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 int
		arg4 int
		arg5 int
		arg6 string
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.recordInvocation("EnableSnapshot", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.enableSnapshotMutex.Unlock()
	if fake.EnableSnapshotStub != nil {
		return fake.EnableSnapshotStub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.enableSnapshotReturns
	return fakeReturns.result1
}

func (fake *FakeStorageManager) EnableSnapshotCallCount() int {
	fake.enableSnapshotMutex.RLock()
	defer fake.enableSnapshotMutex.RUnlock()
	return len(fake.enableSnapshotArgsForCall)
}

func (fake *FakeStorageManager) EnableSnapshotCalls(stub func(int, string, int, int, int, string) error) {
	fake.enableSnapshotMutex.Lock()
	defer fake.enableSnapshotMutex.Unlock()
	fake.EnableSnapshotStub = stub
}

func (fake *FakeStorageManager) EnableSnapshotArgsForCall(i int) (int, string, int, int, int, string) {
	fake.enableSnapshotMutex.RLock()
	defer fake.enableSnapshotMutex.RUnlock()
	argsForCall := fake.enableSnapshotArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeStorageManager) EnableSnapshotReturns(result1 error) {
	fake.enableSnapshotMutex.Lock()
	defer fake.enableSnapshotMutex.Unlock()
	fake.EnableSnapshotStub = nil
	fake.enableSnapshotReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageManager) EnableSnapshotReturnsOnCall(i int, result1 error) {
	fake.enableSnapshotMutex.Lock()
	defer fake.enableSnapshotMutex.Unlock()
	fake.EnableSnapshotStub = nil
	if fake.enableSnapshotReturnsOnCall == nil {
		fake.enableSnapshotReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.enableSnapshotReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageManager) FailBackFromReplicant(arg1 int) error {
	fake.failBackFromReplicantMutex.Lock()
	ret, specificReturn := fake.failBackFromReplicantReturnsOnCall[len(fake.failBackFromReplicantArgsForCall)]
	fake.failBackFromReplicantArgsForCall = append(fake.failBackFromReplicantArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("FailBackFromReplicant", []interface{}{arg1})
	fake.failBackFromReplicantMutex.Unlock()
	if fake.FailBackFromReplicantStub != nil {
		return fake.FailBackFromReplicantStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.failBackFromReplicantReturns
	return fakeReturns.result1
}

func (fake *FakeStorageManager) FailBackFromReplicantCallCount() int {
	fake.failBackFromReplicantMutex.RLock()
	defer fake.failBackFromReplicantMutex.RUnlock()
	return len(fake.failBackFromReplicantArgsForCall)
}

func (fake *FakeStorageManager) FailBackFromReplicantCalls(stub func(int) error) {
	fake.failBackFromReplicantMutex.Lock()
	defer fake.failBackFromReplicantMutex.Unlock()
	fake.FailBackFromReplicantStub = stub
}

func (fake *FakeStorageManager) FailBackFromReplicantArgsForCall(i int) int {
	fake.failBackFromReplicantMutex.RLock()
	defer fake.failBackFromReplicantMutex.RUnlock()
	argsForCall := fake.failBackFromReplicantArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageManager) FailBackFromReplicantReturns(result1 error) {
	fake.failBackFromReplicantMutex.Lock()
	defer fake.failBackFromReplicantMutex.Unlock()
	fake.FailBackFromReplicantStub = nil
	fake.failBackFromReplicantReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageManager) FailBackFromReplicantReturnsOnCall(i int, result1 error) {
	fake.failBackFromReplicantMutex.Lock()
	defer fake.failBackFromReplicantMutex.Unlock()
	fake.FailBackFromReplicantStub = nil
	if fake.failBackFromReplicantReturnsOnCall == nil {
		fake.failBackFromReplicantReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.failBackFromReplicantReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageManager) FailOverToReplicant(arg1 int, arg2 int) error {
	fake.failOverToReplicantMutex.Lock()
	ret, specificReturn := fake.failOverToReplicantReturnsOnCall[len(fake.failOverToReplicantArgsForCall)]
	fake.failOverToReplicantArgsForCall = append(fake.failOverToReplicantArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("FailOverToReplicant", []interface{}{arg1, arg2})
	fake.failOverToReplicantMutex.Unlock()
	if fake.FailOverToReplicantStub != nil {
		return fake.FailOverToReplicantStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.failOverToReplicantReturns
	return fakeReturns.result1
}

func (fake *FakeStorageManager) FailOverToReplicantCallCount() int {
	fake.failOverToReplicantMutex.RLock()
	defer fake.failOverToReplicantMutex.RUnlock()
	return len(fake.failOverToReplicantArgsForCall)
}

func (fake *FakeStorageManager) FailOverToReplicantCalls(stub func(int, int) error) {
	fake.failOverToReplicantMutex.Lock()
	defer fake.failOverToReplicantMutex.Unlock()
	fake.FailOverToReplicantStub = stub
}

func (fake *FakeStorageManager) FailOverToReplicantArgsForCall(i int) (int, int) {
	fake.failOverToReplicantMutex.RLock()
	defer fake.failOverToReplicantMutex.RUnlock()
	argsForCall := fake.failOverToReplicantArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorageManager) FailOverToReplicantReturns(result1 error) {
	fake.failOverToReplicantMutex.Lock()
	defer fake.failOverToReplicantMutex.Unlock()
	fake.FailOverToReplicantStub = nil
	fake.failOverToReplicantReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageManager) FailOverToReplicantReturnsOnCall(i int, result1 error) {
	fake.failOverToReplicantMutex.Lock()
	defer fake.failOverToReplicantMutex.Unlock()
	fake.FailOverToReplicantStub = nil
	if fake.failOverToReplicantReturnsOnCall == nil {
		fake.failOverToReplicantReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.failOverToReplicantReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageManager) GetAllDatacenters() ([]string, error) {
	fake.getAllDatacentersMutex.Lock()
	ret, specificReturn := fake.getAllDatacentersReturnsOnCall[len(fake.getAllDatacentersArgsForCall)]
	fake.getAllDatacentersArgsForCall = append(fake.getAllDatacentersArgsForCall, struct {
	}{})
	fake.recordInvocation("GetAllDatacenters", []interface{}{})
	fake.getAllDatacentersMutex.Unlock()
	if fake.GetAllDatacentersStub != nil {
		return fake.GetAllDatacentersStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getAllDatacentersReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageManager) GetAllDatacentersCallCount() int {
	fake.getAllDatacentersMutex.RLock()
	defer fake.getAllDatacentersMutex.RUnlock()
	return len(fake.getAllDatacentersArgsForCall)
}

func (fake *FakeStorageManager) GetAllDatacentersCalls(stub func() ([]string, error)) {
	fake.getAllDatacentersMutex.Lock()
	defer fake.getAllDatacentersMutex.Unlock()
	fake.GetAllDatacentersStub = stub
}

func (fake *FakeStorageManager) GetAllDatacentersReturns(result1 []string, result2 error) {
	fake.getAllDatacentersMutex.Lock()
	defer fake.getAllDatacentersMutex.Unlock()
	fake.GetAllDatacentersStub = nil
	fake.getAllDatacentersReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) GetAllDatacentersReturnsOnCall(i int, result1 []string, result2 error) {
	fake.getAllDatacentersMutex.Lock()
	defer fake.getAllDatacentersMutex.Unlock()
	fake.GetAllDatacentersStub = nil
	if fake.getAllDatacentersReturnsOnCall == nil {
		fake.getAllDatacentersReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.getAllDatacentersReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) GetReplicationLocations(arg1 int) ([]datatypes.Location, error) {
	fake.getReplicationLocationsMutex.Lock()
	ret, specificReturn := fake.getReplicationLocationsReturnsOnCall[len(fake.getReplicationLocationsArgsForCall)]
	fake.getReplicationLocationsArgsForCall = append(fake.getReplicationLocationsArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("GetReplicationLocations", []interface{}{arg1})
	fake.getReplicationLocationsMutex.Unlock()
	if fake.GetReplicationLocationsStub != nil {
		return fake.GetReplicationLocationsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getReplicationLocationsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageManager) GetReplicationLocationsCallCount() int {
	fake.getReplicationLocationsMutex.RLock()
	defer fake.getReplicationLocationsMutex.RUnlock()
	return len(fake.getReplicationLocationsArgsForCall)
}

func (fake *FakeStorageManager) GetReplicationLocationsCalls(stub func(int) ([]datatypes.Location, error)) {
	fake.getReplicationLocationsMutex.Lock()
	defer fake.getReplicationLocationsMutex.Unlock()
	fake.GetReplicationLocationsStub = stub
}

func (fake *FakeStorageManager) GetReplicationLocationsArgsForCall(i int) int {
	fake.getReplicationLocationsMutex.RLock()
	defer fake.getReplicationLocationsMutex.RUnlock()
	argsForCall := fake.getReplicationLocationsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageManager) GetReplicationLocationsReturns(result1 []datatypes.Location, result2 error) {
	fake.getReplicationLocationsMutex.Lock()
	defer fake.getReplicationLocationsMutex.Unlock()
	fake.GetReplicationLocationsStub = nil
	fake.getReplicationLocationsReturns = struct {
		result1 []datatypes.Location
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) GetReplicationLocationsReturnsOnCall(i int, result1 []datatypes.Location, result2 error) {
	fake.getReplicationLocationsMutex.Lock()
	defer fake.getReplicationLocationsMutex.Unlock()
	fake.GetReplicationLocationsStub = nil
	if fake.getReplicationLocationsReturnsOnCall == nil {
		fake.getReplicationLocationsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Location
			result2 error
		})
	}
	fake.getReplicationLocationsReturnsOnCall[i] = struct {
		result1 []datatypes.Location
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) GetReplicationPartners(arg1 int) ([]datatypes.Network_Storage, error) {
	fake.getReplicationPartnersMutex.Lock()
	ret, specificReturn := fake.getReplicationPartnersReturnsOnCall[len(fake.getReplicationPartnersArgsForCall)]
	fake.getReplicationPartnersArgsForCall = append(fake.getReplicationPartnersArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("GetReplicationPartners", []interface{}{arg1})
	fake.getReplicationPartnersMutex.Unlock()
	if fake.GetReplicationPartnersStub != nil {
		return fake.GetReplicationPartnersStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getReplicationPartnersReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageManager) GetReplicationPartnersCallCount() int {
	fake.getReplicationPartnersMutex.RLock()
	defer fake.getReplicationPartnersMutex.RUnlock()
	return len(fake.getReplicationPartnersArgsForCall)
}

func (fake *FakeStorageManager) GetReplicationPartnersCalls(stub func(int) ([]datatypes.Network_Storage, error)) {
	fake.getReplicationPartnersMutex.Lock()
	defer fake.getReplicationPartnersMutex.Unlock()
	fake.GetReplicationPartnersStub = stub
}

func (fake *FakeStorageManager) GetReplicationPartnersArgsForCall(i int) int {
	fake.getReplicationPartnersMutex.RLock()
	defer fake.getReplicationPartnersMutex.RUnlock()
	argsForCall := fake.getReplicationPartnersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageManager) GetReplicationPartnersReturns(result1 []datatypes.Network_Storage, result2 error) {
	fake.getReplicationPartnersMutex.Lock()
	defer fake.getReplicationPartnersMutex.Unlock()
	fake.GetReplicationPartnersStub = nil
	fake.getReplicationPartnersReturns = struct {
		result1 []datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) GetReplicationPartnersReturnsOnCall(i int, result1 []datatypes.Network_Storage, result2 error) {
	fake.getReplicationPartnersMutex.Lock()
	defer fake.getReplicationPartnersMutex.Unlock()
	fake.GetReplicationPartnersStub = nil
	if fake.getReplicationPartnersReturnsOnCall == nil {
		fake.getReplicationPartnersReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Network_Storage
			result2 error
		})
	}
	fake.getReplicationPartnersReturnsOnCall[i] = struct {
		result1 []datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) GetSnapshotNotificationStatus(arg1 int) (int, error) {
	fake.getSnapshotNotificationStatusMutex.Lock()
	ret, specificReturn := fake.getSnapshotNotificationStatusReturnsOnCall[len(fake.getSnapshotNotificationStatusArgsForCall)]
	fake.getSnapshotNotificationStatusArgsForCall = append(fake.getSnapshotNotificationStatusArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("GetSnapshotNotificationStatus", []interface{}{arg1})
	fake.getSnapshotNotificationStatusMutex.Unlock()
	if fake.GetSnapshotNotificationStatusStub != nil {
		return fake.GetSnapshotNotificationStatusStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getSnapshotNotificationStatusReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageManager) GetSnapshotNotificationStatusCallCount() int {
	fake.getSnapshotNotificationStatusMutex.RLock()
	defer fake.getSnapshotNotificationStatusMutex.RUnlock()
	return len(fake.getSnapshotNotificationStatusArgsForCall)
}

func (fake *FakeStorageManager) GetSnapshotNotificationStatusCalls(stub func(int) (int, error)) {
	fake.getSnapshotNotificationStatusMutex.Lock()
	defer fake.getSnapshotNotificationStatusMutex.Unlock()
	fake.GetSnapshotNotificationStatusStub = stub
}

func (fake *FakeStorageManager) GetSnapshotNotificationStatusArgsForCall(i int) int {
	fake.getSnapshotNotificationStatusMutex.RLock()
	defer fake.getSnapshotNotificationStatusMutex.RUnlock()
	argsForCall := fake.getSnapshotNotificationStatusArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageManager) GetSnapshotNotificationStatusReturns(result1 int, result2 error) {
	fake.getSnapshotNotificationStatusMutex.Lock()
	defer fake.getSnapshotNotificationStatusMutex.Unlock()
	fake.GetSnapshotNotificationStatusStub = nil
	fake.getSnapshotNotificationStatusReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) GetSnapshotNotificationStatusReturnsOnCall(i int, result1 int, result2 error) {
	fake.getSnapshotNotificationStatusMutex.Lock()
	defer fake.getSnapshotNotificationStatusMutex.Unlock()
	fake.GetSnapshotNotificationStatusStub = nil
	if fake.getSnapshotNotificationStatusReturnsOnCall == nil {
		fake.getSnapshotNotificationStatusReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.getSnapshotNotificationStatusReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) GetVolumeAccessList(arg1 int) (datatypes.Network_Storage, error) {
	fake.getVolumeAccessListMutex.Lock()
	ret, specificReturn := fake.getVolumeAccessListReturnsOnCall[len(fake.getVolumeAccessListArgsForCall)]
	fake.getVolumeAccessListArgsForCall = append(fake.getVolumeAccessListArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("GetVolumeAccessList", []interface{}{arg1})
	fake.getVolumeAccessListMutex.Unlock()
	if fake.GetVolumeAccessListStub != nil {
		return fake.GetVolumeAccessListStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getVolumeAccessListReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageManager) GetVolumeAccessListCallCount() int {
	fake.getVolumeAccessListMutex.RLock()
	defer fake.getVolumeAccessListMutex.RUnlock()
	return len(fake.getVolumeAccessListArgsForCall)
}

func (fake *FakeStorageManager) GetVolumeAccessListCalls(stub func(int) (datatypes.Network_Storage, error)) {
	fake.getVolumeAccessListMutex.Lock()
	defer fake.getVolumeAccessListMutex.Unlock()
	fake.GetVolumeAccessListStub = stub
}

func (fake *FakeStorageManager) GetVolumeAccessListArgsForCall(i int) int {
	fake.getVolumeAccessListMutex.RLock()
	defer fake.getVolumeAccessListMutex.RUnlock()
	argsForCall := fake.getVolumeAccessListArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageManager) GetVolumeAccessListReturns(result1 datatypes.Network_Storage, result2 error) {
	fake.getVolumeAccessListMutex.Lock()
	defer fake.getVolumeAccessListMutex.Unlock()
	fake.GetVolumeAccessListStub = nil
	fake.getVolumeAccessListReturns = struct {
		result1 datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) GetVolumeAccessListReturnsOnCall(i int, result1 datatypes.Network_Storage, result2 error) {
	fake.getVolumeAccessListMutex.Lock()
	defer fake.getVolumeAccessListMutex.Unlock()
	fake.GetVolumeAccessListStub = nil
	if fake.getVolumeAccessListReturnsOnCall == nil {
		fake.getVolumeAccessListReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_Storage
			result2 error
		})
	}
	fake.getVolumeAccessListReturnsOnCall[i] = struct {
		result1 datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) GetVolumeByUsername(arg1 string) ([]datatypes.Network_Storage, error) {
	fake.getVolumeByUsernameMutex.Lock()
	ret, specificReturn := fake.getVolumeByUsernameReturnsOnCall[len(fake.getVolumeByUsernameArgsForCall)]
	fake.getVolumeByUsernameArgsForCall = append(fake.getVolumeByUsernameArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetVolumeByUsername", []interface{}{arg1})
	fake.getVolumeByUsernameMutex.Unlock()
	if fake.GetVolumeByUsernameStub != nil {
		return fake.GetVolumeByUsernameStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getVolumeByUsernameReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageManager) GetVolumeByUsernameCallCount() int {
	fake.getVolumeByUsernameMutex.RLock()
	defer fake.getVolumeByUsernameMutex.RUnlock()
	return len(fake.getVolumeByUsernameArgsForCall)
}

func (fake *FakeStorageManager) GetVolumeByUsernameCalls(stub func(string) ([]datatypes.Network_Storage, error)) {
	fake.getVolumeByUsernameMutex.Lock()
	defer fake.getVolumeByUsernameMutex.Unlock()
	fake.GetVolumeByUsernameStub = stub
}

func (fake *FakeStorageManager) GetVolumeByUsernameArgsForCall(i int) string {
	fake.getVolumeByUsernameMutex.RLock()
	defer fake.getVolumeByUsernameMutex.RUnlock()
	argsForCall := fake.getVolumeByUsernameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageManager) GetVolumeByUsernameReturns(result1 []datatypes.Network_Storage, result2 error) {
	fake.getVolumeByUsernameMutex.Lock()
	defer fake.getVolumeByUsernameMutex.Unlock()
	fake.GetVolumeByUsernameStub = nil
	fake.getVolumeByUsernameReturns = struct {
		result1 []datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) GetVolumeByUsernameReturnsOnCall(i int, result1 []datatypes.Network_Storage, result2 error) {
	fake.getVolumeByUsernameMutex.Lock()
	defer fake.getVolumeByUsernameMutex.Unlock()
	fake.GetVolumeByUsernameStub = nil
	if fake.getVolumeByUsernameReturnsOnCall == nil {
		fake.getVolumeByUsernameReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Network_Storage
			result2 error
		})
	}
	fake.getVolumeByUsernameReturnsOnCall[i] = struct {
		result1 []datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) GetVolumeCountLimits() ([]datatypes.Container_Network_Storage_DataCenterLimits_VolumeCountLimitContainer, error) {
	fake.getVolumeCountLimitsMutex.Lock()
	ret, specificReturn := fake.getVolumeCountLimitsReturnsOnCall[len(fake.getVolumeCountLimitsArgsForCall)]
	fake.getVolumeCountLimitsArgsForCall = append(fake.getVolumeCountLimitsArgsForCall, struct {
	}{})
	fake.recordInvocation("GetVolumeCountLimits", []interface{}{})
	fake.getVolumeCountLimitsMutex.Unlock()
	if fake.GetVolumeCountLimitsStub != nil {
		return fake.GetVolumeCountLimitsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getVolumeCountLimitsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageManager) GetVolumeCountLimitsCallCount() int {
	fake.getVolumeCountLimitsMutex.RLock()
	defer fake.getVolumeCountLimitsMutex.RUnlock()
	return len(fake.getVolumeCountLimitsArgsForCall)
}

func (fake *FakeStorageManager) GetVolumeCountLimitsCalls(stub func() ([]datatypes.Container_Network_Storage_DataCenterLimits_VolumeCountLimitContainer, error)) {
	fake.getVolumeCountLimitsMutex.Lock()
	defer fake.getVolumeCountLimitsMutex.Unlock()
	fake.GetVolumeCountLimitsStub = stub
}

func (fake *FakeStorageManager) GetVolumeCountLimitsReturns(result1 []datatypes.Container_Network_Storage_DataCenterLimits_VolumeCountLimitContainer, result2 error) {
	fake.getVolumeCountLimitsMutex.Lock()
	defer fake.getVolumeCountLimitsMutex.Unlock()
	fake.GetVolumeCountLimitsStub = nil
	fake.getVolumeCountLimitsReturns = struct {
		result1 []datatypes.Container_Network_Storage_DataCenterLimits_VolumeCountLimitContainer
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) GetVolumeCountLimitsReturnsOnCall(i int, result1 []datatypes.Container_Network_Storage_DataCenterLimits_VolumeCountLimitContainer, result2 error) {
	fake.getVolumeCountLimitsMutex.Lock()
	defer fake.getVolumeCountLimitsMutex.Unlock()
	fake.GetVolumeCountLimitsStub = nil
	if fake.getVolumeCountLimitsReturnsOnCall == nil {
		fake.getVolumeCountLimitsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Container_Network_Storage_DataCenterLimits_VolumeCountLimitContainer
			result2 error
		})
	}
	fake.getVolumeCountLimitsReturnsOnCall[i] = struct {
		result1 []datatypes.Container_Network_Storage_DataCenterLimits_VolumeCountLimitContainer
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) GetVolumeDetails(arg1 string, arg2 int, arg3 string) (datatypes.Network_Storage, error) {
	fake.getVolumeDetailsMutex.Lock()
	ret, specificReturn := fake.getVolumeDetailsReturnsOnCall[len(fake.getVolumeDetailsArgsForCall)]
	fake.getVolumeDetailsArgsForCall = append(fake.getVolumeDetailsArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetVolumeDetails", []interface{}{arg1, arg2, arg3})
	fake.getVolumeDetailsMutex.Unlock()
	if fake.GetVolumeDetailsStub != nil {
		return fake.GetVolumeDetailsStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getVolumeDetailsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageManager) GetVolumeDetailsCallCount() int {
	fake.getVolumeDetailsMutex.RLock()
	defer fake.getVolumeDetailsMutex.RUnlock()
	return len(fake.getVolumeDetailsArgsForCall)
}

func (fake *FakeStorageManager) GetVolumeDetailsCalls(stub func(string, int, string) (datatypes.Network_Storage, error)) {
	fake.getVolumeDetailsMutex.Lock()
	defer fake.getVolumeDetailsMutex.Unlock()
	fake.GetVolumeDetailsStub = stub
}

func (fake *FakeStorageManager) GetVolumeDetailsArgsForCall(i int) (string, int, string) {
	fake.getVolumeDetailsMutex.RLock()
	defer fake.getVolumeDetailsMutex.RUnlock()
	argsForCall := fake.getVolumeDetailsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStorageManager) GetVolumeDetailsReturns(result1 datatypes.Network_Storage, result2 error) {
	fake.getVolumeDetailsMutex.Lock()
	defer fake.getVolumeDetailsMutex.Unlock()
	fake.GetVolumeDetailsStub = nil
	fake.getVolumeDetailsReturns = struct {
		result1 datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) GetVolumeDetailsReturnsOnCall(i int, result1 datatypes.Network_Storage, result2 error) {
	fake.getVolumeDetailsMutex.Lock()
	defer fake.getVolumeDetailsMutex.Unlock()
	fake.GetVolumeDetailsStub = nil
	if fake.getVolumeDetailsReturnsOnCall == nil {
		fake.getVolumeDetailsReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_Storage
			result2 error
		})
	}
	fake.getVolumeDetailsReturnsOnCall[i] = struct {
		result1 datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) GetVolumeSnapshotList(arg1 int) ([]datatypes.Network_Storage, error) {
	fake.getVolumeSnapshotListMutex.Lock()
	ret, specificReturn := fake.getVolumeSnapshotListReturnsOnCall[len(fake.getVolumeSnapshotListArgsForCall)]
	fake.getVolumeSnapshotListArgsForCall = append(fake.getVolumeSnapshotListArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("GetVolumeSnapshotList", []interface{}{arg1})
	fake.getVolumeSnapshotListMutex.Unlock()
	if fake.GetVolumeSnapshotListStub != nil {
		return fake.GetVolumeSnapshotListStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getVolumeSnapshotListReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageManager) GetVolumeSnapshotListCallCount() int {
	fake.getVolumeSnapshotListMutex.RLock()
	defer fake.getVolumeSnapshotListMutex.RUnlock()
	return len(fake.getVolumeSnapshotListArgsForCall)
}

func (fake *FakeStorageManager) GetVolumeSnapshotListCalls(stub func(int) ([]datatypes.Network_Storage, error)) {
	fake.getVolumeSnapshotListMutex.Lock()
	defer fake.getVolumeSnapshotListMutex.Unlock()
	fake.GetVolumeSnapshotListStub = stub
}

func (fake *FakeStorageManager) GetVolumeSnapshotListArgsForCall(i int) int {
	fake.getVolumeSnapshotListMutex.RLock()
	defer fake.getVolumeSnapshotListMutex.RUnlock()
	argsForCall := fake.getVolumeSnapshotListArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageManager) GetVolumeSnapshotListReturns(result1 []datatypes.Network_Storage, result2 error) {
	fake.getVolumeSnapshotListMutex.Lock()
	defer fake.getVolumeSnapshotListMutex.Unlock()
	fake.GetVolumeSnapshotListStub = nil
	fake.getVolumeSnapshotListReturns = struct {
		result1 []datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) GetVolumeSnapshotListReturnsOnCall(i int, result1 []datatypes.Network_Storage, result2 error) {
	fake.getVolumeSnapshotListMutex.Lock()
	defer fake.getVolumeSnapshotListMutex.Unlock()
	fake.GetVolumeSnapshotListStub = nil
	if fake.getVolumeSnapshotListReturnsOnCall == nil {
		fake.getVolumeSnapshotListReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Network_Storage
			result2 error
		})
	}
	fake.getVolumeSnapshotListReturnsOnCall[i] = struct {
		result1 []datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) GetVolumeSnapshotSchedules(arg1 int) (datatypes.Network_Storage, error) {
	fake.getVolumeSnapshotSchedulesMutex.Lock()
	ret, specificReturn := fake.getVolumeSnapshotSchedulesReturnsOnCall[len(fake.getVolumeSnapshotSchedulesArgsForCall)]
	fake.getVolumeSnapshotSchedulesArgsForCall = append(fake.getVolumeSnapshotSchedulesArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("GetVolumeSnapshotSchedules", []interface{}{arg1})
	fake.getVolumeSnapshotSchedulesMutex.Unlock()
	if fake.GetVolumeSnapshotSchedulesStub != nil {
		return fake.GetVolumeSnapshotSchedulesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getVolumeSnapshotSchedulesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageManager) GetVolumeSnapshotSchedulesCallCount() int {
	fake.getVolumeSnapshotSchedulesMutex.RLock()
	defer fake.getVolumeSnapshotSchedulesMutex.RUnlock()
	return len(fake.getVolumeSnapshotSchedulesArgsForCall)
}

func (fake *FakeStorageManager) GetVolumeSnapshotSchedulesCalls(stub func(int) (datatypes.Network_Storage, error)) {
	fake.getVolumeSnapshotSchedulesMutex.Lock()
	defer fake.getVolumeSnapshotSchedulesMutex.Unlock()
	fake.GetVolumeSnapshotSchedulesStub = stub
}

func (fake *FakeStorageManager) GetVolumeSnapshotSchedulesArgsForCall(i int) int {
	fake.getVolumeSnapshotSchedulesMutex.RLock()
	defer fake.getVolumeSnapshotSchedulesMutex.RUnlock()
	argsForCall := fake.getVolumeSnapshotSchedulesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageManager) GetVolumeSnapshotSchedulesReturns(result1 datatypes.Network_Storage, result2 error) {
	fake.getVolumeSnapshotSchedulesMutex.Lock()
	defer fake.getVolumeSnapshotSchedulesMutex.Unlock()
	fake.GetVolumeSnapshotSchedulesStub = nil
	fake.getVolumeSnapshotSchedulesReturns = struct {
		result1 datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) GetVolumeSnapshotSchedulesReturnsOnCall(i int, result1 datatypes.Network_Storage, result2 error) {
	fake.getVolumeSnapshotSchedulesMutex.Lock()
	defer fake.getVolumeSnapshotSchedulesMutex.Unlock()
	fake.GetVolumeSnapshotSchedulesStub = nil
	if fake.getVolumeSnapshotSchedulesReturnsOnCall == nil {
		fake.getVolumeSnapshotSchedulesReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_Storage
			result2 error
		})
	}
	fake.getVolumeSnapshotSchedulesReturnsOnCall[i] = struct {
		result1 datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) ListVolumes(arg1 string, arg2 string, arg3 string, arg4 string, arg5 int, arg6 string) ([]datatypes.Network_Storage, error) {
	fake.listVolumesMutex.Lock()
	ret, specificReturn := fake.listVolumesReturnsOnCall[len(fake.listVolumesArgsForCall)]
	fake.listVolumesArgsForCall = append(fake.listVolumesArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 int
		arg6 string
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.recordInvocation("ListVolumes", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.listVolumesMutex.Unlock()
	if fake.ListVolumesStub != nil {
		return fake.ListVolumesStub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listVolumesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageManager) ListVolumesCallCount() int {
	fake.listVolumesMutex.RLock()
	defer fake.listVolumesMutex.RUnlock()
	return len(fake.listVolumesArgsForCall)
}

func (fake *FakeStorageManager) ListVolumesCalls(stub func(string, string, string, string, int, string) ([]datatypes.Network_Storage, error)) {
	fake.listVolumesMutex.Lock()
	defer fake.listVolumesMutex.Unlock()
	fake.ListVolumesStub = stub
}

func (fake *FakeStorageManager) ListVolumesArgsForCall(i int) (string, string, string, string, int, string) {
	fake.listVolumesMutex.RLock()
	defer fake.listVolumesMutex.RUnlock()
	argsForCall := fake.listVolumesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeStorageManager) ListVolumesReturns(result1 []datatypes.Network_Storage, result2 error) {
	fake.listVolumesMutex.Lock()
	defer fake.listVolumesMutex.Unlock()
	fake.ListVolumesStub = nil
	fake.listVolumesReturns = struct {
		result1 []datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) ListVolumesReturnsOnCall(i int, result1 []datatypes.Network_Storage, result2 error) {
	fake.listVolumesMutex.Lock()
	defer fake.listVolumesMutex.Unlock()
	fake.ListVolumesStub = nil
	if fake.listVolumesReturnsOnCall == nil {
		fake.listVolumesReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Network_Storage
			result2 error
		})
	}
	fake.listVolumesReturnsOnCall[i] = struct {
		result1 []datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) OrderDuplicateVolume(arg1 managers.DuplicateOrderConfig) (datatypes.Container_Product_Order_Receipt, error) {
	fake.orderDuplicateVolumeMutex.Lock()
	ret, specificReturn := fake.orderDuplicateVolumeReturnsOnCall[len(fake.orderDuplicateVolumeArgsForCall)]
	fake.orderDuplicateVolumeArgsForCall = append(fake.orderDuplicateVolumeArgsForCall, struct {
		arg1 managers.DuplicateOrderConfig
	}{arg1})
	fake.recordInvocation("OrderDuplicateVolume", []interface{}{arg1})
	fake.orderDuplicateVolumeMutex.Unlock()
	if fake.OrderDuplicateVolumeStub != nil {
		return fake.OrderDuplicateVolumeStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.orderDuplicateVolumeReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageManager) OrderDuplicateVolumeCallCount() int {
	fake.orderDuplicateVolumeMutex.RLock()
	defer fake.orderDuplicateVolumeMutex.RUnlock()
	return len(fake.orderDuplicateVolumeArgsForCall)
}

func (fake *FakeStorageManager) OrderDuplicateVolumeCalls(stub func(managers.DuplicateOrderConfig) (datatypes.Container_Product_Order_Receipt, error)) {
	fake.orderDuplicateVolumeMutex.Lock()
	defer fake.orderDuplicateVolumeMutex.Unlock()
	fake.OrderDuplicateVolumeStub = stub
}

func (fake *FakeStorageManager) OrderDuplicateVolumeArgsForCall(i int) managers.DuplicateOrderConfig {
	fake.orderDuplicateVolumeMutex.RLock()
	defer fake.orderDuplicateVolumeMutex.RUnlock()
	argsForCall := fake.orderDuplicateVolumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageManager) OrderDuplicateVolumeReturns(result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.orderDuplicateVolumeMutex.Lock()
	defer fake.orderDuplicateVolumeMutex.Unlock()
	fake.OrderDuplicateVolumeStub = nil
	fake.orderDuplicateVolumeReturns = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) OrderDuplicateVolumeReturnsOnCall(i int, result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.orderDuplicateVolumeMutex.Lock()
	defer fake.orderDuplicateVolumeMutex.Unlock()
	fake.OrderDuplicateVolumeStub = nil
	if fake.orderDuplicateVolumeReturnsOnCall == nil {
		fake.orderDuplicateVolumeReturnsOnCall = make(map[int]struct {
			result1 datatypes.Container_Product_Order_Receipt
			result2 error
		})
	}
	fake.orderDuplicateVolumeReturnsOnCall[i] = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) OrderModifiedVolume(arg1 string, arg2 int, arg3 float64, arg4 int, arg5 int) (datatypes.Container_Product_Order_Receipt, error) {
	fake.orderModifiedVolumeMutex.Lock()
	ret, specificReturn := fake.orderModifiedVolumeReturnsOnCall[len(fake.orderModifiedVolumeArgsForCall)]
	fake.orderModifiedVolumeArgsForCall = append(fake.orderModifiedVolumeArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 float64
		arg4 int
		arg5 int
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("OrderModifiedVolume", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.orderModifiedVolumeMutex.Unlock()
	if fake.OrderModifiedVolumeStub != nil {
		return fake.OrderModifiedVolumeStub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.orderModifiedVolumeReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageManager) OrderModifiedVolumeCallCount() int {
	fake.orderModifiedVolumeMutex.RLock()
	defer fake.orderModifiedVolumeMutex.RUnlock()
	return len(fake.orderModifiedVolumeArgsForCall)
}

func (fake *FakeStorageManager) OrderModifiedVolumeCalls(stub func(string, int, float64, int, int) (datatypes.Container_Product_Order_Receipt, error)) {
	fake.orderModifiedVolumeMutex.Lock()
	defer fake.orderModifiedVolumeMutex.Unlock()
	fake.OrderModifiedVolumeStub = stub
}

func (fake *FakeStorageManager) OrderModifiedVolumeArgsForCall(i int) (string, int, float64, int, int) {
	fake.orderModifiedVolumeMutex.RLock()
	defer fake.orderModifiedVolumeMutex.RUnlock()
	argsForCall := fake.orderModifiedVolumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeStorageManager) OrderModifiedVolumeReturns(result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.orderModifiedVolumeMutex.Lock()
	defer fake.orderModifiedVolumeMutex.Unlock()
	fake.OrderModifiedVolumeStub = nil
	fake.orderModifiedVolumeReturns = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) OrderModifiedVolumeReturnsOnCall(i int, result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.orderModifiedVolumeMutex.Lock()
	defer fake.orderModifiedVolumeMutex.Unlock()
	fake.OrderModifiedVolumeStub = nil
	if fake.orderModifiedVolumeReturnsOnCall == nil {
		fake.orderModifiedVolumeReturnsOnCall = make(map[int]struct {
			result1 datatypes.Container_Product_Order_Receipt
			result2 error
		})
	}
	fake.orderModifiedVolumeReturnsOnCall[i] = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) OrderReplicantVolume(arg1 string, arg2 int, arg3 string, arg4 string, arg5 float64, arg6 int, arg7 string) (datatypes.Container_Product_Order_Receipt, error) {
	fake.orderReplicantVolumeMutex.Lock()
	ret, specificReturn := fake.orderReplicantVolumeReturnsOnCall[len(fake.orderReplicantVolumeArgsForCall)]
	fake.orderReplicantVolumeArgsForCall = append(fake.orderReplicantVolumeArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 string
		arg4 string
		arg5 float64
		arg6 int
		arg7 string
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.recordInvocation("OrderReplicantVolume", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.orderReplicantVolumeMutex.Unlock()
	if fake.OrderReplicantVolumeStub != nil {
		return fake.OrderReplicantVolumeStub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.orderReplicantVolumeReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageManager) OrderReplicantVolumeCallCount() int {
	fake.orderReplicantVolumeMutex.RLock()
	defer fake.orderReplicantVolumeMutex.RUnlock()
	return len(fake.orderReplicantVolumeArgsForCall)
}

func (fake *FakeStorageManager) OrderReplicantVolumeCalls(stub func(string, int, string, string, float64, int, string) (datatypes.Container_Product_Order_Receipt, error)) {
	fake.orderReplicantVolumeMutex.Lock()
	defer fake.orderReplicantVolumeMutex.Unlock()
	fake.OrderReplicantVolumeStub = stub
}

func (fake *FakeStorageManager) OrderReplicantVolumeArgsForCall(i int) (string, int, string, string, float64, int, string) {
	fake.orderReplicantVolumeMutex.RLock()
	defer fake.orderReplicantVolumeMutex.RUnlock()
	argsForCall := fake.orderReplicantVolumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeStorageManager) OrderReplicantVolumeReturns(result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.orderReplicantVolumeMutex.Lock()
	defer fake.orderReplicantVolumeMutex.Unlock()
	fake.OrderReplicantVolumeStub = nil
	fake.orderReplicantVolumeReturns = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) OrderReplicantVolumeReturnsOnCall(i int, result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.orderReplicantVolumeMutex.Lock()
	defer fake.orderReplicantVolumeMutex.Unlock()
	fake.OrderReplicantVolumeStub = nil
	if fake.orderReplicantVolumeReturnsOnCall == nil {
		fake.orderReplicantVolumeReturnsOnCall = make(map[int]struct {
			result1 datatypes.Container_Product_Order_Receipt
			result2 error
		})
	}
	fake.orderReplicantVolumeReturnsOnCall[i] = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) OrderSnapshotSpace(arg1 string, arg2 int, arg3 int, arg4 float64, arg5 int, arg6 bool) (datatypes.Container_Product_Order_Receipt, error) {
	fake.orderSnapshotSpaceMutex.Lock()
	ret, specificReturn := fake.orderSnapshotSpaceReturnsOnCall[len(fake.orderSnapshotSpaceArgsForCall)]
	fake.orderSnapshotSpaceArgsForCall = append(fake.orderSnapshotSpaceArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
		arg4 float64
		arg5 int
		arg6 bool
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.recordInvocation("OrderSnapshotSpace", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.orderSnapshotSpaceMutex.Unlock()
	if fake.OrderSnapshotSpaceStub != nil {
		return fake.OrderSnapshotSpaceStub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.orderSnapshotSpaceReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageManager) OrderSnapshotSpaceCallCount() int {
	fake.orderSnapshotSpaceMutex.RLock()
	defer fake.orderSnapshotSpaceMutex.RUnlock()
	return len(fake.orderSnapshotSpaceArgsForCall)
}

func (fake *FakeStorageManager) OrderSnapshotSpaceCalls(stub func(string, int, int, float64, int, bool) (datatypes.Container_Product_Order_Receipt, error)) {
	fake.orderSnapshotSpaceMutex.Lock()
	defer fake.orderSnapshotSpaceMutex.Unlock()
	fake.OrderSnapshotSpaceStub = stub
}

func (fake *FakeStorageManager) OrderSnapshotSpaceArgsForCall(i int) (string, int, int, float64, int, bool) {
	fake.orderSnapshotSpaceMutex.RLock()
	defer fake.orderSnapshotSpaceMutex.RUnlock()
	argsForCall := fake.orderSnapshotSpaceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeStorageManager) OrderSnapshotSpaceReturns(result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.orderSnapshotSpaceMutex.Lock()
	defer fake.orderSnapshotSpaceMutex.Unlock()
	fake.OrderSnapshotSpaceStub = nil
	fake.orderSnapshotSpaceReturns = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) OrderSnapshotSpaceReturnsOnCall(i int, result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.orderSnapshotSpaceMutex.Lock()
	defer fake.orderSnapshotSpaceMutex.Unlock()
	fake.OrderSnapshotSpaceStub = nil
	if fake.orderSnapshotSpaceReturnsOnCall == nil {
		fake.orderSnapshotSpaceReturnsOnCall = make(map[int]struct {
			result1 datatypes.Container_Product_Order_Receipt
			result2 error
		})
	}
	fake.orderSnapshotSpaceReturnsOnCall[i] = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) OrderVolume(arg1 string, arg2 string, arg3 string, arg4 string, arg5 int, arg6 float64, arg7 int, arg8 int, arg9 bool) (datatypes.Container_Product_Order_Receipt, error) {
	fake.orderVolumeMutex.Lock()
	ret, specificReturn := fake.orderVolumeReturnsOnCall[len(fake.orderVolumeArgsForCall)]
	fake.orderVolumeArgsForCall = append(fake.orderVolumeArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 int
		arg6 float64
		arg7 int
		arg8 int
		arg9 bool
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9})
	fake.recordInvocation("OrderVolume", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9})
	fake.orderVolumeMutex.Unlock()
	if fake.OrderVolumeStub != nil {
		return fake.OrderVolumeStub(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.orderVolumeReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageManager) OrderVolumeCallCount() int {
	fake.orderVolumeMutex.RLock()
	defer fake.orderVolumeMutex.RUnlock()
	return len(fake.orderVolumeArgsForCall)
}

func (fake *FakeStorageManager) OrderVolumeCalls(stub func(string, string, string, string, int, float64, int, int, bool) (datatypes.Container_Product_Order_Receipt, error)) {
	fake.orderVolumeMutex.Lock()
	defer fake.orderVolumeMutex.Unlock()
	fake.OrderVolumeStub = stub
}

func (fake *FakeStorageManager) OrderVolumeArgsForCall(i int) (string, string, string, string, int, float64, int, int, bool) {
	fake.orderVolumeMutex.RLock()
	defer fake.orderVolumeMutex.RUnlock()
	argsForCall := fake.orderVolumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7, argsForCall.arg8, argsForCall.arg9
}

func (fake *FakeStorageManager) OrderVolumeReturns(result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.orderVolumeMutex.Lock()
	defer fake.orderVolumeMutex.Unlock()
	fake.OrderVolumeStub = nil
	fake.orderVolumeReturns = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) OrderVolumeReturnsOnCall(i int, result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.orderVolumeMutex.Lock()
	defer fake.orderVolumeMutex.Unlock()
	fake.OrderVolumeStub = nil
	if fake.orderVolumeReturnsOnCall == nil {
		fake.orderVolumeReturnsOnCall = make(map[int]struct {
			result1 datatypes.Container_Product_Order_Receipt
			result2 error
		})
	}
	fake.orderVolumeReturnsOnCall[i] = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) RestoreFromSnapshot(arg1 int, arg2 int) error {
	fake.restoreFromSnapshotMutex.Lock()
	ret, specificReturn := fake.restoreFromSnapshotReturnsOnCall[len(fake.restoreFromSnapshotArgsForCall)]
	fake.restoreFromSnapshotArgsForCall = append(fake.restoreFromSnapshotArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("RestoreFromSnapshot", []interface{}{arg1, arg2})
	fake.restoreFromSnapshotMutex.Unlock()
	if fake.RestoreFromSnapshotStub != nil {
		return fake.RestoreFromSnapshotStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.restoreFromSnapshotReturns
	return fakeReturns.result1
}

func (fake *FakeStorageManager) RestoreFromSnapshotCallCount() int {
	fake.restoreFromSnapshotMutex.RLock()
	defer fake.restoreFromSnapshotMutex.RUnlock()
	return len(fake.restoreFromSnapshotArgsForCall)
}

func (fake *FakeStorageManager) RestoreFromSnapshotCalls(stub func(int, int) error) {
	fake.restoreFromSnapshotMutex.Lock()
	defer fake.restoreFromSnapshotMutex.Unlock()
	fake.RestoreFromSnapshotStub = stub
}

func (fake *FakeStorageManager) RestoreFromSnapshotArgsForCall(i int) (int, int) {
	fake.restoreFromSnapshotMutex.RLock()
	defer fake.restoreFromSnapshotMutex.RUnlock()
	argsForCall := fake.restoreFromSnapshotArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorageManager) RestoreFromSnapshotReturns(result1 error) {
	fake.restoreFromSnapshotMutex.Lock()
	defer fake.restoreFromSnapshotMutex.Unlock()
	fake.RestoreFromSnapshotStub = nil
	fake.restoreFromSnapshotReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageManager) RestoreFromSnapshotReturnsOnCall(i int, result1 error) {
	fake.restoreFromSnapshotMutex.Lock()
	defer fake.restoreFromSnapshotMutex.Unlock()
	fake.RestoreFromSnapshotStub = nil
	if fake.restoreFromSnapshotReturnsOnCall == nil {
		fake.restoreFromSnapshotReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.restoreFromSnapshotReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageManager) SetCredentialPassword(arg1 int, arg2 string) error {
	fake.setCredentialPasswordMutex.Lock()
	ret, specificReturn := fake.setCredentialPasswordReturnsOnCall[len(fake.setCredentialPasswordArgsForCall)]
	fake.setCredentialPasswordArgsForCall = append(fake.setCredentialPasswordArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("SetCredentialPassword", []interface{}{arg1, arg2})
	fake.setCredentialPasswordMutex.Unlock()
	if fake.SetCredentialPasswordStub != nil {
		return fake.SetCredentialPasswordStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setCredentialPasswordReturns
	return fakeReturns.result1
}

func (fake *FakeStorageManager) SetCredentialPasswordCallCount() int {
	fake.setCredentialPasswordMutex.RLock()
	defer fake.setCredentialPasswordMutex.RUnlock()
	return len(fake.setCredentialPasswordArgsForCall)
}

func (fake *FakeStorageManager) SetCredentialPasswordCalls(stub func(int, string) error) {
	fake.setCredentialPasswordMutex.Lock()
	defer fake.setCredentialPasswordMutex.Unlock()
	fake.SetCredentialPasswordStub = stub
}

func (fake *FakeStorageManager) SetCredentialPasswordArgsForCall(i int) (int, string) {
	fake.setCredentialPasswordMutex.RLock()
	defer fake.setCredentialPasswordMutex.RUnlock()
	argsForCall := fake.setCredentialPasswordArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorageManager) SetCredentialPasswordReturns(result1 error) {
	fake.setCredentialPasswordMutex.Lock()
	defer fake.setCredentialPasswordMutex.Unlock()
	fake.SetCredentialPasswordStub = nil
	fake.setCredentialPasswordReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageManager) SetCredentialPasswordReturnsOnCall(i int, result1 error) {
	fake.setCredentialPasswordMutex.Lock()
	defer fake.setCredentialPasswordMutex.Unlock()
	fake.SetCredentialPasswordStub = nil
	if fake.setCredentialPasswordReturnsOnCall == nil {
		fake.setCredentialPasswordReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setCredentialPasswordReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageManager) SetLunId(arg1 int, arg2 int) (datatypes.Network_Storage_Property, error) {
	fake.setLunIdMutex.Lock()
	ret, specificReturn := fake.setLunIdReturnsOnCall[len(fake.setLunIdArgsForCall)]
	fake.setLunIdArgsForCall = append(fake.setLunIdArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("SetLunId", []interface{}{arg1, arg2})
	fake.setLunIdMutex.Unlock()
	if fake.SetLunIdStub != nil {
		return fake.SetLunIdStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.setLunIdReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageManager) SetLunIdCallCount() int {
	fake.setLunIdMutex.RLock()
	defer fake.setLunIdMutex.RUnlock()
	return len(fake.setLunIdArgsForCall)
}

func (fake *FakeStorageManager) SetLunIdCalls(stub func(int, int) (datatypes.Network_Storage_Property, error)) {
	fake.setLunIdMutex.Lock()
	defer fake.setLunIdMutex.Unlock()
	fake.SetLunIdStub = stub
}

func (fake *FakeStorageManager) SetLunIdArgsForCall(i int) (int, int) {
	fake.setLunIdMutex.RLock()
	defer fake.setLunIdMutex.RUnlock()
	argsForCall := fake.setLunIdArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorageManager) SetLunIdReturns(result1 datatypes.Network_Storage_Property, result2 error) {
	fake.setLunIdMutex.Lock()
	defer fake.setLunIdMutex.Unlock()
	fake.SetLunIdStub = nil
	fake.setLunIdReturns = struct {
		result1 datatypes.Network_Storage_Property
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) SetLunIdReturnsOnCall(i int, result1 datatypes.Network_Storage_Property, result2 error) {
	fake.setLunIdMutex.Lock()
	defer fake.setLunIdMutex.Unlock()
	fake.SetLunIdStub = nil
	if fake.setLunIdReturnsOnCall == nil {
		fake.setLunIdReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_Storage_Property
			result2 error
		})
	}
	fake.setLunIdReturnsOnCall[i] = struct {
		result1 datatypes.Network_Storage_Property
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageManager) SetSnapshotNotification(arg1 int, arg2 bool) error {
	fake.setSnapshotNotificationMutex.Lock()
	ret, specificReturn := fake.setSnapshotNotificationReturnsOnCall[len(fake.setSnapshotNotificationArgsForCall)]
	fake.setSnapshotNotificationArgsForCall = append(fake.setSnapshotNotificationArgsForCall, struct {
		arg1 int
		arg2 bool
	}{arg1, arg2})
	fake.recordInvocation("SetSnapshotNotification", []interface{}{arg1, arg2})
	fake.setSnapshotNotificationMutex.Unlock()
	if fake.SetSnapshotNotificationStub != nil {
		return fake.SetSnapshotNotificationStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setSnapshotNotificationReturns
	return fakeReturns.result1
}

func (fake *FakeStorageManager) SetSnapshotNotificationCallCount() int {
	fake.setSnapshotNotificationMutex.RLock()
	defer fake.setSnapshotNotificationMutex.RUnlock()
	return len(fake.setSnapshotNotificationArgsForCall)
}

func (fake *FakeStorageManager) SetSnapshotNotificationCalls(stub func(int, bool) error) {
	fake.setSnapshotNotificationMutex.Lock()
	defer fake.setSnapshotNotificationMutex.Unlock()
	fake.SetSnapshotNotificationStub = stub
}

func (fake *FakeStorageManager) SetSnapshotNotificationArgsForCall(i int) (int, bool) {
	fake.setSnapshotNotificationMutex.RLock()
	defer fake.setSnapshotNotificationMutex.RUnlock()
	argsForCall := fake.setSnapshotNotificationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorageManager) SetSnapshotNotificationReturns(result1 error) {
	fake.setSnapshotNotificationMutex.Lock()
	defer fake.setSnapshotNotificationMutex.Unlock()
	fake.SetSnapshotNotificationStub = nil
	fake.setSnapshotNotificationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageManager) SetSnapshotNotificationReturnsOnCall(i int, result1 error) {
	fake.setSnapshotNotificationMutex.Lock()
	defer fake.setSnapshotNotificationMutex.Unlock()
	fake.SetSnapshotNotificationStub = nil
	if fake.setSnapshotNotificationReturnsOnCall == nil {
		fake.setSnapshotNotificationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setSnapshotNotificationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageManager) VolumeConvert(arg1 int) error {
	fake.volumeConvertMutex.Lock()
	ret, specificReturn := fake.volumeConvertReturnsOnCall[len(fake.volumeConvertArgsForCall)]
	fake.volumeConvertArgsForCall = append(fake.volumeConvertArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("VolumeConvert", []interface{}{arg1})
	fake.volumeConvertMutex.Unlock()
	if fake.VolumeConvertStub != nil {
		return fake.VolumeConvertStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.volumeConvertReturns
	return fakeReturns.result1
}

func (fake *FakeStorageManager) VolumeConvertCallCount() int {
	fake.volumeConvertMutex.RLock()
	defer fake.volumeConvertMutex.RUnlock()
	return len(fake.volumeConvertArgsForCall)
}

func (fake *FakeStorageManager) VolumeConvertCalls(stub func(int) error) {
	fake.volumeConvertMutex.Lock()
	defer fake.volumeConvertMutex.Unlock()
	fake.VolumeConvertStub = stub
}

func (fake *FakeStorageManager) VolumeConvertArgsForCall(i int) int {
	fake.volumeConvertMutex.RLock()
	defer fake.volumeConvertMutex.RUnlock()
	argsForCall := fake.volumeConvertArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageManager) VolumeConvertReturns(result1 error) {
	fake.volumeConvertMutex.Lock()
	defer fake.volumeConvertMutex.Unlock()
	fake.VolumeConvertStub = nil
	fake.volumeConvertReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageManager) VolumeConvertReturnsOnCall(i int, result1 error) {
	fake.volumeConvertMutex.Lock()
	defer fake.volumeConvertMutex.Unlock()
	fake.VolumeConvertStub = nil
	if fake.volumeConvertReturnsOnCall == nil {
		fake.volumeConvertReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.volumeConvertReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageManager) VolumeRefresh(arg1 int, arg2 int) error {
	fake.volumeRefreshMutex.Lock()
	ret, specificReturn := fake.volumeRefreshReturnsOnCall[len(fake.volumeRefreshArgsForCall)]
	fake.volumeRefreshArgsForCall = append(fake.volumeRefreshArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("VolumeRefresh", []interface{}{arg1, arg2})
	fake.volumeRefreshMutex.Unlock()
	if fake.VolumeRefreshStub != nil {
		return fake.VolumeRefreshStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.volumeRefreshReturns
	return fakeReturns.result1
}

func (fake *FakeStorageManager) VolumeRefreshCallCount() int {
	fake.volumeRefreshMutex.RLock()
	defer fake.volumeRefreshMutex.RUnlock()
	return len(fake.volumeRefreshArgsForCall)
}

func (fake *FakeStorageManager) VolumeRefreshCalls(stub func(int, int) error) {
	fake.volumeRefreshMutex.Lock()
	defer fake.volumeRefreshMutex.Unlock()
	fake.VolumeRefreshStub = stub
}

func (fake *FakeStorageManager) VolumeRefreshArgsForCall(i int) (int, int) {
	fake.volumeRefreshMutex.RLock()
	defer fake.volumeRefreshMutex.RUnlock()
	argsForCall := fake.volumeRefreshArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorageManager) VolumeRefreshReturns(result1 error) {
	fake.volumeRefreshMutex.Lock()
	defer fake.volumeRefreshMutex.Unlock()
	fake.VolumeRefreshStub = nil
	fake.volumeRefreshReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageManager) VolumeRefreshReturnsOnCall(i int, result1 error) {
	fake.volumeRefreshMutex.Lock()
	defer fake.volumeRefreshMutex.Unlock()
	fake.VolumeRefreshStub = nil
	if fake.volumeRefreshReturnsOnCall == nil {
		fake.volumeRefreshReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.volumeRefreshReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.authorizeHostToVolumeMutex.RLock()
	defer fake.authorizeHostToVolumeMutex.RUnlock()
	fake.cancelSnapshotSpaceMutex.RLock()
	defer fake.cancelSnapshotSpaceMutex.RUnlock()
	fake.cancelVolumeMutex.RLock()
	defer fake.cancelVolumeMutex.RUnlock()
	fake.createSnapshotMutex.RLock()
	defer fake.createSnapshotMutex.RUnlock()
	fake.deauthorizeHostToVolumeMutex.RLock()
	defer fake.deauthorizeHostToVolumeMutex.RUnlock()
	fake.deleteSnapshotMutex.RLock()
	defer fake.deleteSnapshotMutex.RUnlock()
	fake.disableSnapshotsMutex.RLock()
	defer fake.disableSnapshotsMutex.RUnlock()
	fake.disasterRecoveryFailoverMutex.RLock()
	defer fake.disasterRecoveryFailoverMutex.RUnlock()
	fake.enableSnapshotMutex.RLock()
	defer fake.enableSnapshotMutex.RUnlock()
	fake.failBackFromReplicantMutex.RLock()
	defer fake.failBackFromReplicantMutex.RUnlock()
	fake.failOverToReplicantMutex.RLock()
	defer fake.failOverToReplicantMutex.RUnlock()
	fake.getAllDatacentersMutex.RLock()
	defer fake.getAllDatacentersMutex.RUnlock()
	fake.getReplicationLocationsMutex.RLock()
	defer fake.getReplicationLocationsMutex.RUnlock()
	fake.getReplicationPartnersMutex.RLock()
	defer fake.getReplicationPartnersMutex.RUnlock()
	fake.getSnapshotNotificationStatusMutex.RLock()
	defer fake.getSnapshotNotificationStatusMutex.RUnlock()
	fake.getVolumeAccessListMutex.RLock()
	defer fake.getVolumeAccessListMutex.RUnlock()
	fake.getVolumeByUsernameMutex.RLock()
	defer fake.getVolumeByUsernameMutex.RUnlock()
	fake.getVolumeCountLimitsMutex.RLock()
	defer fake.getVolumeCountLimitsMutex.RUnlock()
	fake.getVolumeDetailsMutex.RLock()
	defer fake.getVolumeDetailsMutex.RUnlock()
	fake.getVolumeSnapshotListMutex.RLock()
	defer fake.getVolumeSnapshotListMutex.RUnlock()
	fake.getVolumeSnapshotSchedulesMutex.RLock()
	defer fake.getVolumeSnapshotSchedulesMutex.RUnlock()
	fake.listVolumesMutex.RLock()
	defer fake.listVolumesMutex.RUnlock()
	fake.orderDuplicateVolumeMutex.RLock()
	defer fake.orderDuplicateVolumeMutex.RUnlock()
	fake.orderModifiedVolumeMutex.RLock()
	defer fake.orderModifiedVolumeMutex.RUnlock()
	fake.orderReplicantVolumeMutex.RLock()
	defer fake.orderReplicantVolumeMutex.RUnlock()
	fake.orderSnapshotSpaceMutex.RLock()
	defer fake.orderSnapshotSpaceMutex.RUnlock()
	fake.orderVolumeMutex.RLock()
	defer fake.orderVolumeMutex.RUnlock()
	fake.restoreFromSnapshotMutex.RLock()
	defer fake.restoreFromSnapshotMutex.RUnlock()
	fake.setCredentialPasswordMutex.RLock()
	defer fake.setCredentialPasswordMutex.RUnlock()
	fake.setLunIdMutex.RLock()
	defer fake.setLunIdMutex.RUnlock()
	fake.setSnapshotNotificationMutex.RLock()
	defer fake.setSnapshotNotificationMutex.RUnlock()
	fake.volumeConvertMutex.RLock()
	defer fake.volumeConvertMutex.RUnlock()
	fake.volumeRefreshMutex.RLock()
	defer fake.volumeRefreshMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeStorageManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ managers.StorageManager = new(FakeStorageManager)
