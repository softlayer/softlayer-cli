// Code generated by counterfeiter. DO NOT EDIT.
package testhelpers

import (
	"sync"

	"github.com/softlayer/softlayer-go/datatypes"
	"github.ibm.com/SoftLayer/softlayer-cli/plugin/managers"
)

type FakeIPSECManager struct {
	AddInternalSubnetStub        func(int, int) error
	addInternalSubnetMutex       sync.RWMutex
	addInternalSubnetArgsForCall []struct {
		arg1 int
		arg2 int
	}
	addInternalSubnetReturns struct {
		result1 error
	}
	addInternalSubnetReturnsOnCall map[int]struct {
		result1 error
	}
	AddRemoteSubnetStub        func(int, int) error
	addRemoteSubnetMutex       sync.RWMutex
	addRemoteSubnetArgsForCall []struct {
		arg1 int
		arg2 int
	}
	addRemoteSubnetReturns struct {
		result1 error
	}
	addRemoteSubnetReturnsOnCall map[int]struct {
		result1 error
	}
	AddServiceSubnetStub        func(int, int) error
	addServiceSubnetMutex       sync.RWMutex
	addServiceSubnetArgsForCall []struct {
		arg1 int
		arg2 int
	}
	addServiceSubnetReturns struct {
		result1 error
	}
	addServiceSubnetReturnsOnCall map[int]struct {
		result1 error
	}
	ApplyConfigurationStub        func(int) error
	applyConfigurationMutex       sync.RWMutex
	applyConfigurationArgsForCall []struct {
		arg1 int
	}
	applyConfigurationReturns struct {
		result1 error
	}
	applyConfigurationReturnsOnCall map[int]struct {
		result1 error
	}
	CancelTunnelContextStub        func(int, bool, string) error
	cancelTunnelContextMutex       sync.RWMutex
	cancelTunnelContextArgsForCall []struct {
		arg1 int
		arg2 bool
		arg3 string
	}
	cancelTunnelContextReturns struct {
		result1 error
	}
	cancelTunnelContextReturnsOnCall map[int]struct {
		result1 error
	}
	CreateRemoteSubnetStub        func(int, string, int) (datatypes.Network_Customer_Subnet, error)
	createRemoteSubnetMutex       sync.RWMutex
	createRemoteSubnetArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 int
	}
	createRemoteSubnetReturns struct {
		result1 datatypes.Network_Customer_Subnet
		result2 error
	}
	createRemoteSubnetReturnsOnCall map[int]struct {
		result1 datatypes.Network_Customer_Subnet
		result2 error
	}
	CreateTranslationStub        func(int, string, string, string) (datatypes.Network_Tunnel_Module_Context_Address_Translation, error)
	createTranslationMutex       sync.RWMutex
	createTranslationArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 string
		arg4 string
	}
	createTranslationReturns struct {
		result1 datatypes.Network_Tunnel_Module_Context_Address_Translation
		result2 error
	}
	createTranslationReturnsOnCall map[int]struct {
		result1 datatypes.Network_Tunnel_Module_Context_Address_Translation
		result2 error
	}
	DeleteRemoteSubnetStub        func(int, int) error
	deleteRemoteSubnetMutex       sync.RWMutex
	deleteRemoteSubnetArgsForCall []struct {
		arg1 int
		arg2 int
	}
	deleteRemoteSubnetReturns struct {
		result1 error
	}
	deleteRemoteSubnetReturnsOnCall map[int]struct {
		result1 error
	}
	GetTranslationStub        func(int, int) (datatypes.Network_Tunnel_Module_Context_Address_Translation, error)
	getTranslationMutex       sync.RWMutex
	getTranslationArgsForCall []struct {
		arg1 int
		arg2 int
	}
	getTranslationReturns struct {
		result1 datatypes.Network_Tunnel_Module_Context_Address_Translation
		result2 error
	}
	getTranslationReturnsOnCall map[int]struct {
		result1 datatypes.Network_Tunnel_Module_Context_Address_Translation
		result2 error
	}
	GetTranslationsStub        func(int) ([]datatypes.Network_Tunnel_Module_Context_Address_Translation, error)
	getTranslationsMutex       sync.RWMutex
	getTranslationsArgsForCall []struct {
		arg1 int
	}
	getTranslationsReturns struct {
		result1 []datatypes.Network_Tunnel_Module_Context_Address_Translation
		result2 error
	}
	getTranslationsReturnsOnCall map[int]struct {
		result1 []datatypes.Network_Tunnel_Module_Context_Address_Translation
		result2 error
	}
	GetTunnelContextStub        func(int, string) (datatypes.Network_Tunnel_Module_Context, error)
	getTunnelContextMutex       sync.RWMutex
	getTunnelContextArgsForCall []struct {
		arg1 int
		arg2 string
	}
	getTunnelContextReturns struct {
		result1 datatypes.Network_Tunnel_Module_Context
		result2 error
	}
	getTunnelContextReturnsOnCall map[int]struct {
		result1 datatypes.Network_Tunnel_Module_Context
		result2 error
	}
	GetTunnelContextsStub        func(int, string) ([]datatypes.Network_Tunnel_Module_Context, error)
	getTunnelContextsMutex       sync.RWMutex
	getTunnelContextsArgsForCall []struct {
		arg1 int
		arg2 string
	}
	getTunnelContextsReturns struct {
		result1 []datatypes.Network_Tunnel_Module_Context
		result2 error
	}
	getTunnelContextsReturnsOnCall map[int]struct {
		result1 []datatypes.Network_Tunnel_Module_Context
		result2 error
	}
	OrderTunnelContextStub        func(string) (datatypes.Container_Product_Order_Receipt, error)
	orderTunnelContextMutex       sync.RWMutex
	orderTunnelContextArgsForCall []struct {
		arg1 string
	}
	orderTunnelContextReturns struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	orderTunnelContextReturnsOnCall map[int]struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	RemoveInternalSubnetStub        func(int, int) error
	removeInternalSubnetMutex       sync.RWMutex
	removeInternalSubnetArgsForCall []struct {
		arg1 int
		arg2 int
	}
	removeInternalSubnetReturns struct {
		result1 error
	}
	removeInternalSubnetReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveRemoteSubnetStub        func(int, int) error
	removeRemoteSubnetMutex       sync.RWMutex
	removeRemoteSubnetArgsForCall []struct {
		arg1 int
		arg2 int
	}
	removeRemoteSubnetReturns struct {
		result1 error
	}
	removeRemoteSubnetReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveServiceSubnetStub        func(int, int) error
	removeServiceSubnetMutex       sync.RWMutex
	removeServiceSubnetArgsForCall []struct {
		arg1 int
		arg2 int
	}
	removeServiceSubnetReturns struct {
		result1 error
	}
	removeServiceSubnetReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveTranslationStub        func(int, int) error
	removeTranslationMutex       sync.RWMutex
	removeTranslationArgsForCall []struct {
		arg1 int
		arg2 int
	}
	removeTranslationReturns struct {
		result1 error
	}
	removeTranslationReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateTranslationStub        func(int, int, string, string, string) (datatypes.Network_Tunnel_Module_Context_Address_Translation, error)
	updateTranslationMutex       sync.RWMutex
	updateTranslationArgsForCall []struct {
		arg1 int
		arg2 int
		arg3 string
		arg4 string
		arg5 string
	}
	updateTranslationReturns struct {
		result1 datatypes.Network_Tunnel_Module_Context_Address_Translation
		result2 error
	}
	updateTranslationReturnsOnCall map[int]struct {
		result1 datatypes.Network_Tunnel_Module_Context_Address_Translation
		result2 error
	}
	UpdateTunnelContextStub        func(int, string, string, string, string, string, int, int, string, string, int, int, int) (datatypes.Network_Tunnel_Module_Context, error)
	updateTunnelContextMutex       sync.RWMutex
	updateTunnelContextArgsForCall []struct {
		arg1  int
		arg2  string
		arg3  string
		arg4  string
		arg5  string
		arg6  string
		arg7  int
		arg8  int
		arg9  string
		arg10 string
		arg11 int
		arg12 int
		arg13 int
	}
	updateTunnelContextReturns struct {
		result1 datatypes.Network_Tunnel_Module_Context
		result2 error
	}
	updateTunnelContextReturnsOnCall map[int]struct {
		result1 datatypes.Network_Tunnel_Module_Context
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeIPSECManager) AddInternalSubnet(arg1 int, arg2 int) error {
	fake.addInternalSubnetMutex.Lock()
	ret, specificReturn := fake.addInternalSubnetReturnsOnCall[len(fake.addInternalSubnetArgsForCall)]
	fake.addInternalSubnetArgsForCall = append(fake.addInternalSubnetArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.AddInternalSubnetStub
	fakeReturns := fake.addInternalSubnetReturns
	fake.recordInvocation("AddInternalSubnet", []interface{}{arg1, arg2})
	fake.addInternalSubnetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIPSECManager) AddInternalSubnetCallCount() int {
	fake.addInternalSubnetMutex.RLock()
	defer fake.addInternalSubnetMutex.RUnlock()
	return len(fake.addInternalSubnetArgsForCall)
}

func (fake *FakeIPSECManager) AddInternalSubnetCalls(stub func(int, int) error) {
	fake.addInternalSubnetMutex.Lock()
	defer fake.addInternalSubnetMutex.Unlock()
	fake.AddInternalSubnetStub = stub
}

func (fake *FakeIPSECManager) AddInternalSubnetArgsForCall(i int) (int, int) {
	fake.addInternalSubnetMutex.RLock()
	defer fake.addInternalSubnetMutex.RUnlock()
	argsForCall := fake.addInternalSubnetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIPSECManager) AddInternalSubnetReturns(result1 error) {
	fake.addInternalSubnetMutex.Lock()
	defer fake.addInternalSubnetMutex.Unlock()
	fake.AddInternalSubnetStub = nil
	fake.addInternalSubnetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPSECManager) AddInternalSubnetReturnsOnCall(i int, result1 error) {
	fake.addInternalSubnetMutex.Lock()
	defer fake.addInternalSubnetMutex.Unlock()
	fake.AddInternalSubnetStub = nil
	if fake.addInternalSubnetReturnsOnCall == nil {
		fake.addInternalSubnetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addInternalSubnetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPSECManager) AddRemoteSubnet(arg1 int, arg2 int) error {
	fake.addRemoteSubnetMutex.Lock()
	ret, specificReturn := fake.addRemoteSubnetReturnsOnCall[len(fake.addRemoteSubnetArgsForCall)]
	fake.addRemoteSubnetArgsForCall = append(fake.addRemoteSubnetArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.AddRemoteSubnetStub
	fakeReturns := fake.addRemoteSubnetReturns
	fake.recordInvocation("AddRemoteSubnet", []interface{}{arg1, arg2})
	fake.addRemoteSubnetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIPSECManager) AddRemoteSubnetCallCount() int {
	fake.addRemoteSubnetMutex.RLock()
	defer fake.addRemoteSubnetMutex.RUnlock()
	return len(fake.addRemoteSubnetArgsForCall)
}

func (fake *FakeIPSECManager) AddRemoteSubnetCalls(stub func(int, int) error) {
	fake.addRemoteSubnetMutex.Lock()
	defer fake.addRemoteSubnetMutex.Unlock()
	fake.AddRemoteSubnetStub = stub
}

func (fake *FakeIPSECManager) AddRemoteSubnetArgsForCall(i int) (int, int) {
	fake.addRemoteSubnetMutex.RLock()
	defer fake.addRemoteSubnetMutex.RUnlock()
	argsForCall := fake.addRemoteSubnetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIPSECManager) AddRemoteSubnetReturns(result1 error) {
	fake.addRemoteSubnetMutex.Lock()
	defer fake.addRemoteSubnetMutex.Unlock()
	fake.AddRemoteSubnetStub = nil
	fake.addRemoteSubnetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPSECManager) AddRemoteSubnetReturnsOnCall(i int, result1 error) {
	fake.addRemoteSubnetMutex.Lock()
	defer fake.addRemoteSubnetMutex.Unlock()
	fake.AddRemoteSubnetStub = nil
	if fake.addRemoteSubnetReturnsOnCall == nil {
		fake.addRemoteSubnetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addRemoteSubnetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPSECManager) AddServiceSubnet(arg1 int, arg2 int) error {
	fake.addServiceSubnetMutex.Lock()
	ret, specificReturn := fake.addServiceSubnetReturnsOnCall[len(fake.addServiceSubnetArgsForCall)]
	fake.addServiceSubnetArgsForCall = append(fake.addServiceSubnetArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.AddServiceSubnetStub
	fakeReturns := fake.addServiceSubnetReturns
	fake.recordInvocation("AddServiceSubnet", []interface{}{arg1, arg2})
	fake.addServiceSubnetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIPSECManager) AddServiceSubnetCallCount() int {
	fake.addServiceSubnetMutex.RLock()
	defer fake.addServiceSubnetMutex.RUnlock()
	return len(fake.addServiceSubnetArgsForCall)
}

func (fake *FakeIPSECManager) AddServiceSubnetCalls(stub func(int, int) error) {
	fake.addServiceSubnetMutex.Lock()
	defer fake.addServiceSubnetMutex.Unlock()
	fake.AddServiceSubnetStub = stub
}

func (fake *FakeIPSECManager) AddServiceSubnetArgsForCall(i int) (int, int) {
	fake.addServiceSubnetMutex.RLock()
	defer fake.addServiceSubnetMutex.RUnlock()
	argsForCall := fake.addServiceSubnetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIPSECManager) AddServiceSubnetReturns(result1 error) {
	fake.addServiceSubnetMutex.Lock()
	defer fake.addServiceSubnetMutex.Unlock()
	fake.AddServiceSubnetStub = nil
	fake.addServiceSubnetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPSECManager) AddServiceSubnetReturnsOnCall(i int, result1 error) {
	fake.addServiceSubnetMutex.Lock()
	defer fake.addServiceSubnetMutex.Unlock()
	fake.AddServiceSubnetStub = nil
	if fake.addServiceSubnetReturnsOnCall == nil {
		fake.addServiceSubnetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addServiceSubnetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPSECManager) ApplyConfiguration(arg1 int) error {
	fake.applyConfigurationMutex.Lock()
	ret, specificReturn := fake.applyConfigurationReturnsOnCall[len(fake.applyConfigurationArgsForCall)]
	fake.applyConfigurationArgsForCall = append(fake.applyConfigurationArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.ApplyConfigurationStub
	fakeReturns := fake.applyConfigurationReturns
	fake.recordInvocation("ApplyConfiguration", []interface{}{arg1})
	fake.applyConfigurationMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIPSECManager) ApplyConfigurationCallCount() int {
	fake.applyConfigurationMutex.RLock()
	defer fake.applyConfigurationMutex.RUnlock()
	return len(fake.applyConfigurationArgsForCall)
}

func (fake *FakeIPSECManager) ApplyConfigurationCalls(stub func(int) error) {
	fake.applyConfigurationMutex.Lock()
	defer fake.applyConfigurationMutex.Unlock()
	fake.ApplyConfigurationStub = stub
}

func (fake *FakeIPSECManager) ApplyConfigurationArgsForCall(i int) int {
	fake.applyConfigurationMutex.RLock()
	defer fake.applyConfigurationMutex.RUnlock()
	argsForCall := fake.applyConfigurationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIPSECManager) ApplyConfigurationReturns(result1 error) {
	fake.applyConfigurationMutex.Lock()
	defer fake.applyConfigurationMutex.Unlock()
	fake.ApplyConfigurationStub = nil
	fake.applyConfigurationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPSECManager) ApplyConfigurationReturnsOnCall(i int, result1 error) {
	fake.applyConfigurationMutex.Lock()
	defer fake.applyConfigurationMutex.Unlock()
	fake.ApplyConfigurationStub = nil
	if fake.applyConfigurationReturnsOnCall == nil {
		fake.applyConfigurationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.applyConfigurationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPSECManager) CancelTunnelContext(arg1 int, arg2 bool, arg3 string) error {
	fake.cancelTunnelContextMutex.Lock()
	ret, specificReturn := fake.cancelTunnelContextReturnsOnCall[len(fake.cancelTunnelContextArgsForCall)]
	fake.cancelTunnelContextArgsForCall = append(fake.cancelTunnelContextArgsForCall, struct {
		arg1 int
		arg2 bool
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.CancelTunnelContextStub
	fakeReturns := fake.cancelTunnelContextReturns
	fake.recordInvocation("CancelTunnelContext", []interface{}{arg1, arg2, arg3})
	fake.cancelTunnelContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIPSECManager) CancelTunnelContextCallCount() int {
	fake.cancelTunnelContextMutex.RLock()
	defer fake.cancelTunnelContextMutex.RUnlock()
	return len(fake.cancelTunnelContextArgsForCall)
}

func (fake *FakeIPSECManager) CancelTunnelContextCalls(stub func(int, bool, string) error) {
	fake.cancelTunnelContextMutex.Lock()
	defer fake.cancelTunnelContextMutex.Unlock()
	fake.CancelTunnelContextStub = stub
}

func (fake *FakeIPSECManager) CancelTunnelContextArgsForCall(i int) (int, bool, string) {
	fake.cancelTunnelContextMutex.RLock()
	defer fake.cancelTunnelContextMutex.RUnlock()
	argsForCall := fake.cancelTunnelContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIPSECManager) CancelTunnelContextReturns(result1 error) {
	fake.cancelTunnelContextMutex.Lock()
	defer fake.cancelTunnelContextMutex.Unlock()
	fake.CancelTunnelContextStub = nil
	fake.cancelTunnelContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPSECManager) CancelTunnelContextReturnsOnCall(i int, result1 error) {
	fake.cancelTunnelContextMutex.Lock()
	defer fake.cancelTunnelContextMutex.Unlock()
	fake.CancelTunnelContextStub = nil
	if fake.cancelTunnelContextReturnsOnCall == nil {
		fake.cancelTunnelContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelTunnelContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPSECManager) CreateRemoteSubnet(arg1 int, arg2 string, arg3 int) (datatypes.Network_Customer_Subnet, error) {
	fake.createRemoteSubnetMutex.Lock()
	ret, specificReturn := fake.createRemoteSubnetReturnsOnCall[len(fake.createRemoteSubnetArgsForCall)]
	fake.createRemoteSubnetArgsForCall = append(fake.createRemoteSubnetArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.CreateRemoteSubnetStub
	fakeReturns := fake.createRemoteSubnetReturns
	fake.recordInvocation("CreateRemoteSubnet", []interface{}{arg1, arg2, arg3})
	fake.createRemoteSubnetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIPSECManager) CreateRemoteSubnetCallCount() int {
	fake.createRemoteSubnetMutex.RLock()
	defer fake.createRemoteSubnetMutex.RUnlock()
	return len(fake.createRemoteSubnetArgsForCall)
}

func (fake *FakeIPSECManager) CreateRemoteSubnetCalls(stub func(int, string, int) (datatypes.Network_Customer_Subnet, error)) {
	fake.createRemoteSubnetMutex.Lock()
	defer fake.createRemoteSubnetMutex.Unlock()
	fake.CreateRemoteSubnetStub = stub
}

func (fake *FakeIPSECManager) CreateRemoteSubnetArgsForCall(i int) (int, string, int) {
	fake.createRemoteSubnetMutex.RLock()
	defer fake.createRemoteSubnetMutex.RUnlock()
	argsForCall := fake.createRemoteSubnetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIPSECManager) CreateRemoteSubnetReturns(result1 datatypes.Network_Customer_Subnet, result2 error) {
	fake.createRemoteSubnetMutex.Lock()
	defer fake.createRemoteSubnetMutex.Unlock()
	fake.CreateRemoteSubnetStub = nil
	fake.createRemoteSubnetReturns = struct {
		result1 datatypes.Network_Customer_Subnet
		result2 error
	}{result1, result2}
}

func (fake *FakeIPSECManager) CreateRemoteSubnetReturnsOnCall(i int, result1 datatypes.Network_Customer_Subnet, result2 error) {
	fake.createRemoteSubnetMutex.Lock()
	defer fake.createRemoteSubnetMutex.Unlock()
	fake.CreateRemoteSubnetStub = nil
	if fake.createRemoteSubnetReturnsOnCall == nil {
		fake.createRemoteSubnetReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_Customer_Subnet
			result2 error
		})
	}
	fake.createRemoteSubnetReturnsOnCall[i] = struct {
		result1 datatypes.Network_Customer_Subnet
		result2 error
	}{result1, result2}
}

func (fake *FakeIPSECManager) CreateTranslation(arg1 int, arg2 string, arg3 string, arg4 string) (datatypes.Network_Tunnel_Module_Context_Address_Translation, error) {
	fake.createTranslationMutex.Lock()
	ret, specificReturn := fake.createTranslationReturnsOnCall[len(fake.createTranslationArgsForCall)]
	fake.createTranslationArgsForCall = append(fake.createTranslationArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.CreateTranslationStub
	fakeReturns := fake.createTranslationReturns
	fake.recordInvocation("CreateTranslation", []interface{}{arg1, arg2, arg3, arg4})
	fake.createTranslationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIPSECManager) CreateTranslationCallCount() int {
	fake.createTranslationMutex.RLock()
	defer fake.createTranslationMutex.RUnlock()
	return len(fake.createTranslationArgsForCall)
}

func (fake *FakeIPSECManager) CreateTranslationCalls(stub func(int, string, string, string) (datatypes.Network_Tunnel_Module_Context_Address_Translation, error)) {
	fake.createTranslationMutex.Lock()
	defer fake.createTranslationMutex.Unlock()
	fake.CreateTranslationStub = stub
}

func (fake *FakeIPSECManager) CreateTranslationArgsForCall(i int) (int, string, string, string) {
	fake.createTranslationMutex.RLock()
	defer fake.createTranslationMutex.RUnlock()
	argsForCall := fake.createTranslationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeIPSECManager) CreateTranslationReturns(result1 datatypes.Network_Tunnel_Module_Context_Address_Translation, result2 error) {
	fake.createTranslationMutex.Lock()
	defer fake.createTranslationMutex.Unlock()
	fake.CreateTranslationStub = nil
	fake.createTranslationReturns = struct {
		result1 datatypes.Network_Tunnel_Module_Context_Address_Translation
		result2 error
	}{result1, result2}
}

func (fake *FakeIPSECManager) CreateTranslationReturnsOnCall(i int, result1 datatypes.Network_Tunnel_Module_Context_Address_Translation, result2 error) {
	fake.createTranslationMutex.Lock()
	defer fake.createTranslationMutex.Unlock()
	fake.CreateTranslationStub = nil
	if fake.createTranslationReturnsOnCall == nil {
		fake.createTranslationReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_Tunnel_Module_Context_Address_Translation
			result2 error
		})
	}
	fake.createTranslationReturnsOnCall[i] = struct {
		result1 datatypes.Network_Tunnel_Module_Context_Address_Translation
		result2 error
	}{result1, result2}
}

func (fake *FakeIPSECManager) DeleteRemoteSubnet(arg1 int, arg2 int) error {
	fake.deleteRemoteSubnetMutex.Lock()
	ret, specificReturn := fake.deleteRemoteSubnetReturnsOnCall[len(fake.deleteRemoteSubnetArgsForCall)]
	fake.deleteRemoteSubnetArgsForCall = append(fake.deleteRemoteSubnetArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.DeleteRemoteSubnetStub
	fakeReturns := fake.deleteRemoteSubnetReturns
	fake.recordInvocation("DeleteRemoteSubnet", []interface{}{arg1, arg2})
	fake.deleteRemoteSubnetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIPSECManager) DeleteRemoteSubnetCallCount() int {
	fake.deleteRemoteSubnetMutex.RLock()
	defer fake.deleteRemoteSubnetMutex.RUnlock()
	return len(fake.deleteRemoteSubnetArgsForCall)
}

func (fake *FakeIPSECManager) DeleteRemoteSubnetCalls(stub func(int, int) error) {
	fake.deleteRemoteSubnetMutex.Lock()
	defer fake.deleteRemoteSubnetMutex.Unlock()
	fake.DeleteRemoteSubnetStub = stub
}

func (fake *FakeIPSECManager) DeleteRemoteSubnetArgsForCall(i int) (int, int) {
	fake.deleteRemoteSubnetMutex.RLock()
	defer fake.deleteRemoteSubnetMutex.RUnlock()
	argsForCall := fake.deleteRemoteSubnetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIPSECManager) DeleteRemoteSubnetReturns(result1 error) {
	fake.deleteRemoteSubnetMutex.Lock()
	defer fake.deleteRemoteSubnetMutex.Unlock()
	fake.DeleteRemoteSubnetStub = nil
	fake.deleteRemoteSubnetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPSECManager) DeleteRemoteSubnetReturnsOnCall(i int, result1 error) {
	fake.deleteRemoteSubnetMutex.Lock()
	defer fake.deleteRemoteSubnetMutex.Unlock()
	fake.DeleteRemoteSubnetStub = nil
	if fake.deleteRemoteSubnetReturnsOnCall == nil {
		fake.deleteRemoteSubnetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteRemoteSubnetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPSECManager) GetTranslation(arg1 int, arg2 int) (datatypes.Network_Tunnel_Module_Context_Address_Translation, error) {
	fake.getTranslationMutex.Lock()
	ret, specificReturn := fake.getTranslationReturnsOnCall[len(fake.getTranslationArgsForCall)]
	fake.getTranslationArgsForCall = append(fake.getTranslationArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.GetTranslationStub
	fakeReturns := fake.getTranslationReturns
	fake.recordInvocation("GetTranslation", []interface{}{arg1, arg2})
	fake.getTranslationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIPSECManager) GetTranslationCallCount() int {
	fake.getTranslationMutex.RLock()
	defer fake.getTranslationMutex.RUnlock()
	return len(fake.getTranslationArgsForCall)
}

func (fake *FakeIPSECManager) GetTranslationCalls(stub func(int, int) (datatypes.Network_Tunnel_Module_Context_Address_Translation, error)) {
	fake.getTranslationMutex.Lock()
	defer fake.getTranslationMutex.Unlock()
	fake.GetTranslationStub = stub
}

func (fake *FakeIPSECManager) GetTranslationArgsForCall(i int) (int, int) {
	fake.getTranslationMutex.RLock()
	defer fake.getTranslationMutex.RUnlock()
	argsForCall := fake.getTranslationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIPSECManager) GetTranslationReturns(result1 datatypes.Network_Tunnel_Module_Context_Address_Translation, result2 error) {
	fake.getTranslationMutex.Lock()
	defer fake.getTranslationMutex.Unlock()
	fake.GetTranslationStub = nil
	fake.getTranslationReturns = struct {
		result1 datatypes.Network_Tunnel_Module_Context_Address_Translation
		result2 error
	}{result1, result2}
}

func (fake *FakeIPSECManager) GetTranslationReturnsOnCall(i int, result1 datatypes.Network_Tunnel_Module_Context_Address_Translation, result2 error) {
	fake.getTranslationMutex.Lock()
	defer fake.getTranslationMutex.Unlock()
	fake.GetTranslationStub = nil
	if fake.getTranslationReturnsOnCall == nil {
		fake.getTranslationReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_Tunnel_Module_Context_Address_Translation
			result2 error
		})
	}
	fake.getTranslationReturnsOnCall[i] = struct {
		result1 datatypes.Network_Tunnel_Module_Context_Address_Translation
		result2 error
	}{result1, result2}
}

func (fake *FakeIPSECManager) GetTranslations(arg1 int) ([]datatypes.Network_Tunnel_Module_Context_Address_Translation, error) {
	fake.getTranslationsMutex.Lock()
	ret, specificReturn := fake.getTranslationsReturnsOnCall[len(fake.getTranslationsArgsForCall)]
	fake.getTranslationsArgsForCall = append(fake.getTranslationsArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.GetTranslationsStub
	fakeReturns := fake.getTranslationsReturns
	fake.recordInvocation("GetTranslations", []interface{}{arg1})
	fake.getTranslationsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIPSECManager) GetTranslationsCallCount() int {
	fake.getTranslationsMutex.RLock()
	defer fake.getTranslationsMutex.RUnlock()
	return len(fake.getTranslationsArgsForCall)
}

func (fake *FakeIPSECManager) GetTranslationsCalls(stub func(int) ([]datatypes.Network_Tunnel_Module_Context_Address_Translation, error)) {
	fake.getTranslationsMutex.Lock()
	defer fake.getTranslationsMutex.Unlock()
	fake.GetTranslationsStub = stub
}

func (fake *FakeIPSECManager) GetTranslationsArgsForCall(i int) int {
	fake.getTranslationsMutex.RLock()
	defer fake.getTranslationsMutex.RUnlock()
	argsForCall := fake.getTranslationsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIPSECManager) GetTranslationsReturns(result1 []datatypes.Network_Tunnel_Module_Context_Address_Translation, result2 error) {
	fake.getTranslationsMutex.Lock()
	defer fake.getTranslationsMutex.Unlock()
	fake.GetTranslationsStub = nil
	fake.getTranslationsReturns = struct {
		result1 []datatypes.Network_Tunnel_Module_Context_Address_Translation
		result2 error
	}{result1, result2}
}

func (fake *FakeIPSECManager) GetTranslationsReturnsOnCall(i int, result1 []datatypes.Network_Tunnel_Module_Context_Address_Translation, result2 error) {
	fake.getTranslationsMutex.Lock()
	defer fake.getTranslationsMutex.Unlock()
	fake.GetTranslationsStub = nil
	if fake.getTranslationsReturnsOnCall == nil {
		fake.getTranslationsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Network_Tunnel_Module_Context_Address_Translation
			result2 error
		})
	}
	fake.getTranslationsReturnsOnCall[i] = struct {
		result1 []datatypes.Network_Tunnel_Module_Context_Address_Translation
		result2 error
	}{result1, result2}
}

func (fake *FakeIPSECManager) GetTunnelContext(arg1 int, arg2 string) (datatypes.Network_Tunnel_Module_Context, error) {
	fake.getTunnelContextMutex.Lock()
	ret, specificReturn := fake.getTunnelContextReturnsOnCall[len(fake.getTunnelContextArgsForCall)]
	fake.getTunnelContextArgsForCall = append(fake.getTunnelContextArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.GetTunnelContextStub
	fakeReturns := fake.getTunnelContextReturns
	fake.recordInvocation("GetTunnelContext", []interface{}{arg1, arg2})
	fake.getTunnelContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIPSECManager) GetTunnelContextCallCount() int {
	fake.getTunnelContextMutex.RLock()
	defer fake.getTunnelContextMutex.RUnlock()
	return len(fake.getTunnelContextArgsForCall)
}

func (fake *FakeIPSECManager) GetTunnelContextCalls(stub func(int, string) (datatypes.Network_Tunnel_Module_Context, error)) {
	fake.getTunnelContextMutex.Lock()
	defer fake.getTunnelContextMutex.Unlock()
	fake.GetTunnelContextStub = stub
}

func (fake *FakeIPSECManager) GetTunnelContextArgsForCall(i int) (int, string) {
	fake.getTunnelContextMutex.RLock()
	defer fake.getTunnelContextMutex.RUnlock()
	argsForCall := fake.getTunnelContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIPSECManager) GetTunnelContextReturns(result1 datatypes.Network_Tunnel_Module_Context, result2 error) {
	fake.getTunnelContextMutex.Lock()
	defer fake.getTunnelContextMutex.Unlock()
	fake.GetTunnelContextStub = nil
	fake.getTunnelContextReturns = struct {
		result1 datatypes.Network_Tunnel_Module_Context
		result2 error
	}{result1, result2}
}

func (fake *FakeIPSECManager) GetTunnelContextReturnsOnCall(i int, result1 datatypes.Network_Tunnel_Module_Context, result2 error) {
	fake.getTunnelContextMutex.Lock()
	defer fake.getTunnelContextMutex.Unlock()
	fake.GetTunnelContextStub = nil
	if fake.getTunnelContextReturnsOnCall == nil {
		fake.getTunnelContextReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_Tunnel_Module_Context
			result2 error
		})
	}
	fake.getTunnelContextReturnsOnCall[i] = struct {
		result1 datatypes.Network_Tunnel_Module_Context
		result2 error
	}{result1, result2}
}

func (fake *FakeIPSECManager) GetTunnelContexts(arg1 int, arg2 string) ([]datatypes.Network_Tunnel_Module_Context, error) {
	fake.getTunnelContextsMutex.Lock()
	ret, specificReturn := fake.getTunnelContextsReturnsOnCall[len(fake.getTunnelContextsArgsForCall)]
	fake.getTunnelContextsArgsForCall = append(fake.getTunnelContextsArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.GetTunnelContextsStub
	fakeReturns := fake.getTunnelContextsReturns
	fake.recordInvocation("GetTunnelContexts", []interface{}{arg1, arg2})
	fake.getTunnelContextsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIPSECManager) GetTunnelContextsCallCount() int {
	fake.getTunnelContextsMutex.RLock()
	defer fake.getTunnelContextsMutex.RUnlock()
	return len(fake.getTunnelContextsArgsForCall)
}

func (fake *FakeIPSECManager) GetTunnelContextsCalls(stub func(int, string) ([]datatypes.Network_Tunnel_Module_Context, error)) {
	fake.getTunnelContextsMutex.Lock()
	defer fake.getTunnelContextsMutex.Unlock()
	fake.GetTunnelContextsStub = stub
}

func (fake *FakeIPSECManager) GetTunnelContextsArgsForCall(i int) (int, string) {
	fake.getTunnelContextsMutex.RLock()
	defer fake.getTunnelContextsMutex.RUnlock()
	argsForCall := fake.getTunnelContextsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIPSECManager) GetTunnelContextsReturns(result1 []datatypes.Network_Tunnel_Module_Context, result2 error) {
	fake.getTunnelContextsMutex.Lock()
	defer fake.getTunnelContextsMutex.Unlock()
	fake.GetTunnelContextsStub = nil
	fake.getTunnelContextsReturns = struct {
		result1 []datatypes.Network_Tunnel_Module_Context
		result2 error
	}{result1, result2}
}

func (fake *FakeIPSECManager) GetTunnelContextsReturnsOnCall(i int, result1 []datatypes.Network_Tunnel_Module_Context, result2 error) {
	fake.getTunnelContextsMutex.Lock()
	defer fake.getTunnelContextsMutex.Unlock()
	fake.GetTunnelContextsStub = nil
	if fake.getTunnelContextsReturnsOnCall == nil {
		fake.getTunnelContextsReturnsOnCall = make(map[int]struct {
			result1 []datatypes.Network_Tunnel_Module_Context
			result2 error
		})
	}
	fake.getTunnelContextsReturnsOnCall[i] = struct {
		result1 []datatypes.Network_Tunnel_Module_Context
		result2 error
	}{result1, result2}
}

func (fake *FakeIPSECManager) OrderTunnelContext(arg1 string) (datatypes.Container_Product_Order_Receipt, error) {
	fake.orderTunnelContextMutex.Lock()
	ret, specificReturn := fake.orderTunnelContextReturnsOnCall[len(fake.orderTunnelContextArgsForCall)]
	fake.orderTunnelContextArgsForCall = append(fake.orderTunnelContextArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.OrderTunnelContextStub
	fakeReturns := fake.orderTunnelContextReturns
	fake.recordInvocation("OrderTunnelContext", []interface{}{arg1})
	fake.orderTunnelContextMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIPSECManager) OrderTunnelContextCallCount() int {
	fake.orderTunnelContextMutex.RLock()
	defer fake.orderTunnelContextMutex.RUnlock()
	return len(fake.orderTunnelContextArgsForCall)
}

func (fake *FakeIPSECManager) OrderTunnelContextCalls(stub func(string) (datatypes.Container_Product_Order_Receipt, error)) {
	fake.orderTunnelContextMutex.Lock()
	defer fake.orderTunnelContextMutex.Unlock()
	fake.OrderTunnelContextStub = stub
}

func (fake *FakeIPSECManager) OrderTunnelContextArgsForCall(i int) string {
	fake.orderTunnelContextMutex.RLock()
	defer fake.orderTunnelContextMutex.RUnlock()
	argsForCall := fake.orderTunnelContextArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIPSECManager) OrderTunnelContextReturns(result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.orderTunnelContextMutex.Lock()
	defer fake.orderTunnelContextMutex.Unlock()
	fake.OrderTunnelContextStub = nil
	fake.orderTunnelContextReturns = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeIPSECManager) OrderTunnelContextReturnsOnCall(i int, result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.orderTunnelContextMutex.Lock()
	defer fake.orderTunnelContextMutex.Unlock()
	fake.OrderTunnelContextStub = nil
	if fake.orderTunnelContextReturnsOnCall == nil {
		fake.orderTunnelContextReturnsOnCall = make(map[int]struct {
			result1 datatypes.Container_Product_Order_Receipt
			result2 error
		})
	}
	fake.orderTunnelContextReturnsOnCall[i] = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeIPSECManager) RemoveInternalSubnet(arg1 int, arg2 int) error {
	fake.removeInternalSubnetMutex.Lock()
	ret, specificReturn := fake.removeInternalSubnetReturnsOnCall[len(fake.removeInternalSubnetArgsForCall)]
	fake.removeInternalSubnetArgsForCall = append(fake.removeInternalSubnetArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.RemoveInternalSubnetStub
	fakeReturns := fake.removeInternalSubnetReturns
	fake.recordInvocation("RemoveInternalSubnet", []interface{}{arg1, arg2})
	fake.removeInternalSubnetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIPSECManager) RemoveInternalSubnetCallCount() int {
	fake.removeInternalSubnetMutex.RLock()
	defer fake.removeInternalSubnetMutex.RUnlock()
	return len(fake.removeInternalSubnetArgsForCall)
}

func (fake *FakeIPSECManager) RemoveInternalSubnetCalls(stub func(int, int) error) {
	fake.removeInternalSubnetMutex.Lock()
	defer fake.removeInternalSubnetMutex.Unlock()
	fake.RemoveInternalSubnetStub = stub
}

func (fake *FakeIPSECManager) RemoveInternalSubnetArgsForCall(i int) (int, int) {
	fake.removeInternalSubnetMutex.RLock()
	defer fake.removeInternalSubnetMutex.RUnlock()
	argsForCall := fake.removeInternalSubnetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIPSECManager) RemoveInternalSubnetReturns(result1 error) {
	fake.removeInternalSubnetMutex.Lock()
	defer fake.removeInternalSubnetMutex.Unlock()
	fake.RemoveInternalSubnetStub = nil
	fake.removeInternalSubnetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPSECManager) RemoveInternalSubnetReturnsOnCall(i int, result1 error) {
	fake.removeInternalSubnetMutex.Lock()
	defer fake.removeInternalSubnetMutex.Unlock()
	fake.RemoveInternalSubnetStub = nil
	if fake.removeInternalSubnetReturnsOnCall == nil {
		fake.removeInternalSubnetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeInternalSubnetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPSECManager) RemoveRemoteSubnet(arg1 int, arg2 int) error {
	fake.removeRemoteSubnetMutex.Lock()
	ret, specificReturn := fake.removeRemoteSubnetReturnsOnCall[len(fake.removeRemoteSubnetArgsForCall)]
	fake.removeRemoteSubnetArgsForCall = append(fake.removeRemoteSubnetArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.RemoveRemoteSubnetStub
	fakeReturns := fake.removeRemoteSubnetReturns
	fake.recordInvocation("RemoveRemoteSubnet", []interface{}{arg1, arg2})
	fake.removeRemoteSubnetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIPSECManager) RemoveRemoteSubnetCallCount() int {
	fake.removeRemoteSubnetMutex.RLock()
	defer fake.removeRemoteSubnetMutex.RUnlock()
	return len(fake.removeRemoteSubnetArgsForCall)
}

func (fake *FakeIPSECManager) RemoveRemoteSubnetCalls(stub func(int, int) error) {
	fake.removeRemoteSubnetMutex.Lock()
	defer fake.removeRemoteSubnetMutex.Unlock()
	fake.RemoveRemoteSubnetStub = stub
}

func (fake *FakeIPSECManager) RemoveRemoteSubnetArgsForCall(i int) (int, int) {
	fake.removeRemoteSubnetMutex.RLock()
	defer fake.removeRemoteSubnetMutex.RUnlock()
	argsForCall := fake.removeRemoteSubnetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIPSECManager) RemoveRemoteSubnetReturns(result1 error) {
	fake.removeRemoteSubnetMutex.Lock()
	defer fake.removeRemoteSubnetMutex.Unlock()
	fake.RemoveRemoteSubnetStub = nil
	fake.removeRemoteSubnetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPSECManager) RemoveRemoteSubnetReturnsOnCall(i int, result1 error) {
	fake.removeRemoteSubnetMutex.Lock()
	defer fake.removeRemoteSubnetMutex.Unlock()
	fake.RemoveRemoteSubnetStub = nil
	if fake.removeRemoteSubnetReturnsOnCall == nil {
		fake.removeRemoteSubnetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeRemoteSubnetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPSECManager) RemoveServiceSubnet(arg1 int, arg2 int) error {
	fake.removeServiceSubnetMutex.Lock()
	ret, specificReturn := fake.removeServiceSubnetReturnsOnCall[len(fake.removeServiceSubnetArgsForCall)]
	fake.removeServiceSubnetArgsForCall = append(fake.removeServiceSubnetArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.RemoveServiceSubnetStub
	fakeReturns := fake.removeServiceSubnetReturns
	fake.recordInvocation("RemoveServiceSubnet", []interface{}{arg1, arg2})
	fake.removeServiceSubnetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIPSECManager) RemoveServiceSubnetCallCount() int {
	fake.removeServiceSubnetMutex.RLock()
	defer fake.removeServiceSubnetMutex.RUnlock()
	return len(fake.removeServiceSubnetArgsForCall)
}

func (fake *FakeIPSECManager) RemoveServiceSubnetCalls(stub func(int, int) error) {
	fake.removeServiceSubnetMutex.Lock()
	defer fake.removeServiceSubnetMutex.Unlock()
	fake.RemoveServiceSubnetStub = stub
}

func (fake *FakeIPSECManager) RemoveServiceSubnetArgsForCall(i int) (int, int) {
	fake.removeServiceSubnetMutex.RLock()
	defer fake.removeServiceSubnetMutex.RUnlock()
	argsForCall := fake.removeServiceSubnetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIPSECManager) RemoveServiceSubnetReturns(result1 error) {
	fake.removeServiceSubnetMutex.Lock()
	defer fake.removeServiceSubnetMutex.Unlock()
	fake.RemoveServiceSubnetStub = nil
	fake.removeServiceSubnetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPSECManager) RemoveServiceSubnetReturnsOnCall(i int, result1 error) {
	fake.removeServiceSubnetMutex.Lock()
	defer fake.removeServiceSubnetMutex.Unlock()
	fake.RemoveServiceSubnetStub = nil
	if fake.removeServiceSubnetReturnsOnCall == nil {
		fake.removeServiceSubnetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeServiceSubnetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPSECManager) RemoveTranslation(arg1 int, arg2 int) error {
	fake.removeTranslationMutex.Lock()
	ret, specificReturn := fake.removeTranslationReturnsOnCall[len(fake.removeTranslationArgsForCall)]
	fake.removeTranslationArgsForCall = append(fake.removeTranslationArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.RemoveTranslationStub
	fakeReturns := fake.removeTranslationReturns
	fake.recordInvocation("RemoveTranslation", []interface{}{arg1, arg2})
	fake.removeTranslationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIPSECManager) RemoveTranslationCallCount() int {
	fake.removeTranslationMutex.RLock()
	defer fake.removeTranslationMutex.RUnlock()
	return len(fake.removeTranslationArgsForCall)
}

func (fake *FakeIPSECManager) RemoveTranslationCalls(stub func(int, int) error) {
	fake.removeTranslationMutex.Lock()
	defer fake.removeTranslationMutex.Unlock()
	fake.RemoveTranslationStub = stub
}

func (fake *FakeIPSECManager) RemoveTranslationArgsForCall(i int) (int, int) {
	fake.removeTranslationMutex.RLock()
	defer fake.removeTranslationMutex.RUnlock()
	argsForCall := fake.removeTranslationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIPSECManager) RemoveTranslationReturns(result1 error) {
	fake.removeTranslationMutex.Lock()
	defer fake.removeTranslationMutex.Unlock()
	fake.RemoveTranslationStub = nil
	fake.removeTranslationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPSECManager) RemoveTranslationReturnsOnCall(i int, result1 error) {
	fake.removeTranslationMutex.Lock()
	defer fake.removeTranslationMutex.Unlock()
	fake.RemoveTranslationStub = nil
	if fake.removeTranslationReturnsOnCall == nil {
		fake.removeTranslationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeTranslationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPSECManager) UpdateTranslation(arg1 int, arg2 int, arg3 string, arg4 string, arg5 string) (datatypes.Network_Tunnel_Module_Context_Address_Translation, error) {
	fake.updateTranslationMutex.Lock()
	ret, specificReturn := fake.updateTranslationReturnsOnCall[len(fake.updateTranslationArgsForCall)]
	fake.updateTranslationArgsForCall = append(fake.updateTranslationArgsForCall, struct {
		arg1 int
		arg2 int
		arg3 string
		arg4 string
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.UpdateTranslationStub
	fakeReturns := fake.updateTranslationReturns
	fake.recordInvocation("UpdateTranslation", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.updateTranslationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIPSECManager) UpdateTranslationCallCount() int {
	fake.updateTranslationMutex.RLock()
	defer fake.updateTranslationMutex.RUnlock()
	return len(fake.updateTranslationArgsForCall)
}

func (fake *FakeIPSECManager) UpdateTranslationCalls(stub func(int, int, string, string, string) (datatypes.Network_Tunnel_Module_Context_Address_Translation, error)) {
	fake.updateTranslationMutex.Lock()
	defer fake.updateTranslationMutex.Unlock()
	fake.UpdateTranslationStub = stub
}

func (fake *FakeIPSECManager) UpdateTranslationArgsForCall(i int) (int, int, string, string, string) {
	fake.updateTranslationMutex.RLock()
	defer fake.updateTranslationMutex.RUnlock()
	argsForCall := fake.updateTranslationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeIPSECManager) UpdateTranslationReturns(result1 datatypes.Network_Tunnel_Module_Context_Address_Translation, result2 error) {
	fake.updateTranslationMutex.Lock()
	defer fake.updateTranslationMutex.Unlock()
	fake.UpdateTranslationStub = nil
	fake.updateTranslationReturns = struct {
		result1 datatypes.Network_Tunnel_Module_Context_Address_Translation
		result2 error
	}{result1, result2}
}

func (fake *FakeIPSECManager) UpdateTranslationReturnsOnCall(i int, result1 datatypes.Network_Tunnel_Module_Context_Address_Translation, result2 error) {
	fake.updateTranslationMutex.Lock()
	defer fake.updateTranslationMutex.Unlock()
	fake.UpdateTranslationStub = nil
	if fake.updateTranslationReturnsOnCall == nil {
		fake.updateTranslationReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_Tunnel_Module_Context_Address_Translation
			result2 error
		})
	}
	fake.updateTranslationReturnsOnCall[i] = struct {
		result1 datatypes.Network_Tunnel_Module_Context_Address_Translation
		result2 error
	}{result1, result2}
}

func (fake *FakeIPSECManager) UpdateTunnelContext(arg1 int, arg2 string, arg3 string, arg4 string, arg5 string, arg6 string, arg7 int, arg8 int, arg9 string, arg10 string, arg11 int, arg12 int, arg13 int) (datatypes.Network_Tunnel_Module_Context, error) {
	fake.updateTunnelContextMutex.Lock()
	ret, specificReturn := fake.updateTunnelContextReturnsOnCall[len(fake.updateTunnelContextArgsForCall)]
	fake.updateTunnelContextArgsForCall = append(fake.updateTunnelContextArgsForCall, struct {
		arg1  int
		arg2  string
		arg3  string
		arg4  string
		arg5  string
		arg6  string
		arg7  int
		arg8  int
		arg9  string
		arg10 string
		arg11 int
		arg12 int
		arg13 int
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13})
	stub := fake.UpdateTunnelContextStub
	fakeReturns := fake.updateTunnelContextReturns
	fake.recordInvocation("UpdateTunnelContext", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13})
	fake.updateTunnelContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIPSECManager) UpdateTunnelContextCallCount() int {
	fake.updateTunnelContextMutex.RLock()
	defer fake.updateTunnelContextMutex.RUnlock()
	return len(fake.updateTunnelContextArgsForCall)
}

func (fake *FakeIPSECManager) UpdateTunnelContextCalls(stub func(int, string, string, string, string, string, int, int, string, string, int, int, int) (datatypes.Network_Tunnel_Module_Context, error)) {
	fake.updateTunnelContextMutex.Lock()
	defer fake.updateTunnelContextMutex.Unlock()
	fake.UpdateTunnelContextStub = stub
}

func (fake *FakeIPSECManager) UpdateTunnelContextArgsForCall(i int) (int, string, string, string, string, string, int, int, string, string, int, int, int) {
	fake.updateTunnelContextMutex.RLock()
	defer fake.updateTunnelContextMutex.RUnlock()
	argsForCall := fake.updateTunnelContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7, argsForCall.arg8, argsForCall.arg9, argsForCall.arg10, argsForCall.arg11, argsForCall.arg12, argsForCall.arg13
}

func (fake *FakeIPSECManager) UpdateTunnelContextReturns(result1 datatypes.Network_Tunnel_Module_Context, result2 error) {
	fake.updateTunnelContextMutex.Lock()
	defer fake.updateTunnelContextMutex.Unlock()
	fake.UpdateTunnelContextStub = nil
	fake.updateTunnelContextReturns = struct {
		result1 datatypes.Network_Tunnel_Module_Context
		result2 error
	}{result1, result2}
}

func (fake *FakeIPSECManager) UpdateTunnelContextReturnsOnCall(i int, result1 datatypes.Network_Tunnel_Module_Context, result2 error) {
	fake.updateTunnelContextMutex.Lock()
	defer fake.updateTunnelContextMutex.Unlock()
	fake.UpdateTunnelContextStub = nil
	if fake.updateTunnelContextReturnsOnCall == nil {
		fake.updateTunnelContextReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_Tunnel_Module_Context
			result2 error
		})
	}
	fake.updateTunnelContextReturnsOnCall[i] = struct {
		result1 datatypes.Network_Tunnel_Module_Context
		result2 error
	}{result1, result2}
}

func (fake *FakeIPSECManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addInternalSubnetMutex.RLock()
	defer fake.addInternalSubnetMutex.RUnlock()
	fake.addRemoteSubnetMutex.RLock()
	defer fake.addRemoteSubnetMutex.RUnlock()
	fake.addServiceSubnetMutex.RLock()
	defer fake.addServiceSubnetMutex.RUnlock()
	fake.applyConfigurationMutex.RLock()
	defer fake.applyConfigurationMutex.RUnlock()
	fake.cancelTunnelContextMutex.RLock()
	defer fake.cancelTunnelContextMutex.RUnlock()
	fake.createRemoteSubnetMutex.RLock()
	defer fake.createRemoteSubnetMutex.RUnlock()
	fake.createTranslationMutex.RLock()
	defer fake.createTranslationMutex.RUnlock()
	fake.deleteRemoteSubnetMutex.RLock()
	defer fake.deleteRemoteSubnetMutex.RUnlock()
	fake.getTranslationMutex.RLock()
	defer fake.getTranslationMutex.RUnlock()
	fake.getTranslationsMutex.RLock()
	defer fake.getTranslationsMutex.RUnlock()
	fake.getTunnelContextMutex.RLock()
	defer fake.getTunnelContextMutex.RUnlock()
	fake.getTunnelContextsMutex.RLock()
	defer fake.getTunnelContextsMutex.RUnlock()
	fake.orderTunnelContextMutex.RLock()
	defer fake.orderTunnelContextMutex.RUnlock()
	fake.removeInternalSubnetMutex.RLock()
	defer fake.removeInternalSubnetMutex.RUnlock()
	fake.removeRemoteSubnetMutex.RLock()
	defer fake.removeRemoteSubnetMutex.RUnlock()
	fake.removeServiceSubnetMutex.RLock()
	defer fake.removeServiceSubnetMutex.RUnlock()
	fake.removeTranslationMutex.RLock()
	defer fake.removeTranslationMutex.RUnlock()
	fake.updateTranslationMutex.RLock()
	defer fake.updateTranslationMutex.RUnlock()
	fake.updateTunnelContextMutex.RLock()
	defer fake.updateTunnelContextMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeIPSECManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ managers.IPSECManager = new(FakeIPSECManager)
